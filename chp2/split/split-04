= 0)
	win->w_cursor.col = 0;
    else if (win->w_cursor.col >= len)
    {
	/* Allow cursor past end-of-line when:
	 * - in Insert mode or restarting Insert mode
	 * - in Visual mode and 'selection' isn't "old"
	 * - 'virtualedit' is set */
	if ((State & INSERT) || restart_edit
#ifdef FEAT_VISUAL
		|| (VIsual_active && *p_sel != 'o')
#endif
#ifdef FEAT_VIRTUALEDIT
		|| (ve_flags & VE_ONEMORE)
#endif
		|| virtual_active())
	    win->w_cursor.col = len;
	else
	{
	    win->w_cursor.col = len - 1;
#ifdef FEAT_MBYTE
	    /* Move the cursor to the head byte. */
	    if (has_mbyte)
		mb_adjustpos(win->w_buffer, &win->w_cursor);
#endif
	}
    }
    else if (win->w_cursor.col < 0)
	win->w_cursor.col = 0;

#ifdef FEAT_VIRTUALEDIT
    /* If virtual editing is on, we can leave the cursor on the old position,
     * only we must set it to virtual.  But don't do it when at the end of the
     * line. */
    if (oldcol == MAXCOL)
	win->w_cursor.coladd = 0;
    else if (ve_flags == VE_ALL)
    {
	if (oldcoladd > win->w_cursor.col)
	    win->w_cursor.coladd = oldcoladd - win->w_cursor.col;
	else
	    /* avoid weird number when there is a miscalculation or overflow */
	    win->w_cursor.coladd = 0;
    }
#endif
}

/*
 * make sure curwin->w_cursor in on a valid character
 */
    void
check_cursor()
{
    check_cursor_lnum();
    check_cursor_col();
}

#if defined(FEAT_TEXTOBJ) || defined(PROTO)
/*
 * Make sure curwin->w_cursor is not on the NUL at the end of the line.
 * Allow it when in Visual mode and 'selection' is not "old".
 */
    void
adjust_cursor_col()
{
    if (curwin->w_cursor.col > 0
# ifdef FEAT_VISUAL
	    && (!VIsual_active || *p_sel == 'o')
# endif
	    && gchar_cursor() == NUL)
	--curwin->w_cursor.col;
}
#endif

/*
 * When curwin->w_leftcol has changed, adjust the cursor position.
 * Return TRUE if the cursor was moved.
 */
    int
leftcol_changed()
{
    long	lastcol;
    colnr_T	s, e;
    int		retval = FALSE;

    changed_cline_bef_curs();
    lastcol = curwin->w_leftcol + W_WIDTH(curwin) - curwin_col_off() - 1;
    validate_virtcol();

    /*
     * If the cursor is right or left of the screen, move it to last or first
     * character.
     */
    if (curwin->w_virtcol > (colnr_T)(lastcol - p_siso))
    {
	retval = TRUE;
	coladvance((colnr_T)(lastcol - p_siso));
    }
    else if (curwin->w_virtcol < curwin->w_leftcol + p_siso)
    {
	retval = TRUE;
	(void)coladvance((colnr_T)(curwin->w_leftcol + p_siso));
    }

    /*
     * If the start of the character under the cursor is not on the screen,
     * advance the cursor one more char.  If this fails (last char of the
     * line) adjust the scrolling.
     */
    getvvcol(curwin, &curwin->w_cursor, &s, NULL, &e);
    if (e > (colnr_T)lastcol)
    {
	retval = TRUE;
	coladvance(s - 1);
    }
    else if (s < curwin->w_leftcol)
    {
	retval = TRUE;
	if (coladvance(e + 1) == FAIL)	/* there isn't another character */
	{
	    curwin->w_leftcol = s;	/* adjust w_leftcol instead */
	    changed_cline_bef_curs();
	}
    }

    if (retval)
	curwin->w_set_curswant = TRUE;
    redraw_later(NOT_VALID);
    return retval;
}

/**********************************************************************
 * Various routines dealing with allocation and deallocation of memory.
 */

#if defined(MEM_PROFILE) || defined(PROTO)

# define MEM_SIZES  8200
static long_u mem_allocs[MEM_SIZES];
static long_u mem_frees[MEM_SIZES];
static long_u mem_allocated;
static long_u mem_freed;
static long_u mem_peak;
static long_u num_alloc;
static long_u num_freed;

static void mem_pre_alloc_s __ARGS((size_t *sizep));
static void mem_pre_alloc_l __ARGS((long_u *sizep));
static void mem_post_alloc __ARGS((void **pp, size_t size));
static void mem_pre_free __ARGS((void **pp));

    static void
mem_pre_alloc_s(sizep)
    size_t *sizep;
{
    *sizep += sizeof(size_t);
}

    static void
mem_pre_alloc_l(sizep)
    long_u *sizep;
{
    *sizep += sizeof(size_t);
}

    static void
mem_post_alloc(pp, size)
    void **pp;
    size_t size;
{
    if (*pp == NULL)
	return;
    size -= sizeof(size_t);
    *(long_u *)*pp = size;
    if (size <= MEM_SIZES-1)
	mem_allocs[size-1]++;
    else
	mem_allocs[MEM_SIZES-1]++;
    mem_allocated += size;
    if (mem_allocated - mem_freed > mem_peak)
	mem_peak = mem_allocated - mem_freed;
    num_alloc++;
    *pp = (void *)((char *)*pp + sizeof(size_t));
}

    static void
mem_pre_free(pp)
    void **pp;
{
    long_u size;

    *pp = (void *)((char *)*pp - sizeof(size_t));
    size = *(size_t *)*pp;
    if (size <= MEM_SIZES-1)
	mem_frees[size-1]++;
    else
	mem_frees[MEM_SIZES-1]++;
    mem_freed += size;
    num_freed++;
}

/*
 * called on exit via atexit()
 */
    void
vim_mem_profile_dump()
{
    int i, j;

    printf("\r\n");
    j = 0;
    for (i = 0; i < MEM_SIZES - 1; i++)
    {
	if (mem_allocs[i] || mem_frees[i])
	{
	    if (mem_frees[i] > mem_allocs[i])
		printf("\r\n%s", _("ERROR: "));
	    printf("[%4d / %4lu-%-4lu] ", i + 1, mem_allocs[i], mem_frees[i]);
	    j++;
	    if (j > 3)
	    {
		j = 0;
		printf("\r\n");
	    }
	}
    }

    i = MEM_SIZES - 1;
    if (mem_allocs[i])
    {
	printf("\r\n");
	if (mem_frees[i] > mem_allocs[i])
	    puts(_("ERROR: "));
	printf("[>%d / %4lu-%-4lu]", i, mem_allocs[i], mem_frees[i]);
    }

    printf(_("\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\n"),
	    mem_allocated, mem_freed, mem_allocated - mem_freed, mem_peak);
    printf(_("[calls] total re/malloc()'s %lu, total free()'s %lu\n\n"),
	    num_alloc, num_freed);
}

#endif /* MEM_PROFILE */

/*
 * Some memory is reserved for error messages and for being able to
 * call mf_release_all(), which needs some memory for mf_trans_add().
 */
#if defined(MSDOS) && !defined(DJGPP)
# define SMALL_MEM
# define KEEP_ROOM 8192L
#else
# define KEEP_ROOM (2 * 8192L)
#endif
#define KEEP_ROOM_KB (KEEP_ROOM / 1024L)

/*
 * Note: if unsigned is 16 bits we can only allocate up to 64K with alloc().
 * Use lalloc for larger blocks.
 */
    char_u *
alloc(size)
    unsigned	    size;
{
    return (lalloc((long_u)size, TRUE));
}

/*
 * Allocate memory and set all bytes to zero.
 */
    char_u *
alloc_clear(size)
    unsigned	    size;
{
    char_u *p;

    p = lalloc((long_u)size, TRUE);
    if (p != NULL)
	(void)vim_memset(p, 0, (size_t)size);
    return p;
}

/*
 * alloc() with check for maximum line length
 */
    char_u *
alloc_check(size)
    unsigned	    size;
{
#if !defined(UNIX) && !defined(__EMX__)
    if (sizeof(int) == 2 && size > 0x7fff)
    {
	/* Don't hide this message */
	emsg_silent = 0;
	EMSG(_("E340: Line is becoming too long"));
	return NULL;
    }
#endif
    return (lalloc((long_u)size, TRUE));
}

/*
 * Allocate memory like lalloc() and set all bytes to zero.
 */
    char_u *
lalloc_clear(size, message)
    long_u	size;
    int		message;
{
    char_u *p;

    p = (lalloc(size, message));
    if (p != NULL)
	(void)vim_memset(p, 0, (size_t)size);
    return p;
}

/*
 * Low level memory allocation function.
 * This is used often, KEEP IT FAST!
 */
    char_u *
lalloc(size, message)
    long_u	size;
    int		message;
{
    char_u	*p;		    /* pointer to new storage space */
    static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
    int		try_again;
#if defined(HAVE_AVAIL_MEM) && !defined(SMALL_MEM)
    static long_u allocated = 0;    /* allocated since last avail check */
#endif

    /* Safety check for allocating zero bytes */
    if (size == 0)
    {
	/* Don't hide this message */
	emsg_silent = 0;
	EMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
	return NULL;
    }

#ifdef MEM_PROFILE
    mem_pre_alloc_l(&size);
#endif

#if defined(MSDOS) && !defined(DJGPP)
    if (size >= 0xfff0)		/* in MSDOS we can't deal with >64K blocks */
	p = NULL;
    else
#endif

    /*
     * Loop when out of memory: Try to release some memfile blocks and
     * if some blocks are released call malloc again.
     */
    for (;;)
    {
	/*
	 * Handle three kind of systems:
	 * 1. No check for available memory: Just return.
	 * 2. Slow check for available memory: call mch_avail_mem() after
	 *    allocating KEEP_ROOM amount of memory.
	 * 3. Strict check for available memory: call mch_avail_mem()
	 */
	if ((p = (char_u *)malloc((size_t)size)) != NULL)
	{
#ifndef HAVE_AVAIL_MEM
	    /* 1. No check for available memory: Just return. */
	    goto theend;
#else
# ifndef SMALL_MEM
	    /* 2. Slow check for available memory: call mch_avail_mem() after
	     *    allocating (KEEP_ROOM / 2) amount of memory. */
	    allocated += size;
	    if (allocated < KEEP_ROOM / 2)
		goto theend;
	    allocated = 0;
# endif
	    /* 3. check for available memory: call mch_avail_mem() */
	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
	    {
		free((char *)p);	/* System is low... no go! */
		p = NULL;
	    }
	    else
		goto theend;
#endif
	}
	/*
	 * Remember that mf_release_all() is being called to avoid an endless
	 * loop, because mf_release_all() may call alloc() recursively.
	 */
	if (releasing)
	    break;
	releasing = TRUE;

	clear_sb_text();	      /* free any scrollback text */
	try_again = mf_release_all(); /* release as many blocks as possible */
#ifdef FEAT_EVAL
	try_again |= garbage_collect(); /* cleanup recursive lists/dicts */
#endif

	releasing = FALSE;
	if (!try_again)
	    break;
    }

    if (message && p == NULL)
	do_outofmem_msg(size);

theend:
#ifdef MEM_PROFILE
    mem_post_alloc((void **)&p, (size_t)size);
#endif
    return p;
}

#if defined(MEM_PROFILE) || defined(PROTO)
/*
 * realloc() with memory profiling.
 */
    void *
mem_realloc(ptr, size)
    void *ptr;
    size_t size;
{
    void *p;

    mem_pre_free(&ptr);
    mem_pre_alloc_s(&size);

    p = realloc(ptr, size);

    mem_post_alloc(&p, size);

    return p;
}
#endif

/*
* Avoid repeating the error message many times (they take 1 second each).
* Did_outofmem_msg is reset when a character is read.
*/
    void
do_outofmem_msg(size)
    long_u	size;
{
    if (!did_outofmem_msg)
    {
	/* Don't hide this message */
	emsg_silent = 0;

	/* Must come first to avoid coming back here when printing the error
	 * message fails, e.g. when setting v:errmsg. */
	did_outofmem_msg = TRUE;

	EMSGN(_("E342: Out of memory!  (allocating %lu bytes)"), size);
    }
}

#if defined(EXITFREE) || defined(PROTO)

# if defined(FEAT_SEARCHPATH)
static void free_findfile __ARGS((void));
# endif

/*
 * Free everything that we allocated.
 * Can be used to detect memory leaks, e.g., with ccmalloc.
 * NOTE: This is tricky!  Things are freed that functions depend on.  Don't be
 * surprised if Vim crashes...
 * Some things can't be freed, esp. things local to a library function.
 */
    void
free_all_mem()
{
    buf_T	*buf, *nextbuf;
    static int	entered = FALSE;

    /* When we cause a crash here it is caught and Vim tries to exit cleanly.
     * Don't try freeing everything again. */
    if (entered)
	return;
    entered = TRUE;

# ifdef FEAT_AUTOCMD
    block_autocmds();	    /* don't want to trigger autocommands here */
# endif

# ifdef FEAT_WINDOWS
    /* Close all tabs and windows.  Reset 'equalalways' to avoid redraws. */
    p_ea = FALSE;
    if (first_tabpage->tp_next != NULL)
	do_cmdline_cmd((char_u *)"tabonly!");
    if (firstwin != lastwin)
	do_cmdline_cmd((char_u *)"only!");
# endif

# if defined(FEAT_SPELL)
    /* Free all spell info. */
    spell_free_all();
# endif

# if defined(FEAT_USR_CMDS)
    /* Clear user commands (before deleting buffers). */
    ex_comclear(NULL);
# endif

# ifdef FEAT_MENU
    /* Clear menus. */
    do_cmdline_cmd((char_u *)"aunmenu *");
#  ifdef FEAT_MULTI_LANG
    do_cmdline_cmd((char_u *)"menutranslate clear");
#  endif
# endif

    /* Clear mappings, abbreviations, breakpoints. */
    do_cmdline_cmd((char_u *)"lmapclear");
    do_cmdline_cmd((char_u *)"xmapclear");
    do_cmdline_cmd((char_u *)"mapclear");
    do_cmdline_cmd((char_u *)"mapclear!");
    do_cmdline_cmd((char_u *)"abclear");
# if defined(FEAT_EVAL)
    do_cmdline_cmd((char_u *)"breakdel *");
# endif
# if defined(FEAT_PROFILE)
    do_cmdline_cmd((char_u *)"profdel *");
# endif
# if defined(FEAT_KEYMAP)
    do_cmdline_cmd((char_u *)"set keymap=");
#endif

# ifdef FEAT_TITLE
    free_titles();
# endif
# if defined(FEAT_SEARCHPATH)
    free_findfile();
# endif

    /* Obviously named calls. */
# if defined(FEAT_AUTOCMD)
    free_all_autocmds();
# endif
    clear_termcodes();
    free_all_options();
    free_all_marks();
    alist_clear(&global_alist);
    free_homedir();
# if defined(FEAT_CMDL_COMPL)
    free_users();
# endif
    free_search_patterns();
    free_old_sub();
    free_last_insert();
    free_prev_shellcmd();
    free_regexp_stuff();
    free_tag_stuff();
    free_cd_dir();
# ifdef FEAT_SIGNS
    free_signs();
# endif
# ifdef FEAT_EVAL
    set_expr_line(NULL);
# endif
# ifdef FEAT_DIFF
    diff_clear(curtab);
# endif
    clear_sb_text();	      /* free any scrollback text */

    /* Free some global vars. */
    vim_free(username);
# ifdef FEAT_CLIPBOARD
    vim_regfree(clip_exclude_prog);
# endif
    vim_free(last_cmdline);
# ifdef FEAT_CMDHIST
    vim_free(new_last_cmdline);
# endif
    set_keep_msg(NULL, 0);
    vim_free(ff_expand_buffer);

    /* Clear cmdline history. */
    p_hi = 0;
# ifdef FEAT_CMDHIST
    init_history();
# endif

#ifdef FEAT_QUICKFIX
    {
	win_T	    *win;
	tabpage_T   *tab;

	qf_free_all(NULL);
	/* Free all location lists */
	FOR_ALL_TAB_WINDOWS(tab, win)
	    qf_free_all(win);
    }
#endif

    /* Close all script inputs. */
    close_all_scripts();

#if defined(FEAT_WINDOWS)
    /* Destroy all windows.  Must come before freeing buffers. */
    win_free_all();
#endif

    /* Free all buffers.  Reset 'autochdir' to avoid accessing things that
     * were freed already. */
#ifdef FEAT_AUTOCHDIR
    p_acd = FALSE;
#endif
    for (buf = firstbuf; buf != NULL; )
    {
	nextbuf = buf->b_next;
	close_buffer(NULL, buf, DOBUF_WIPE, FALSE);
	if (buf_valid(buf))
	    buf = nextbuf;	/* didn't work, try next one */
	else
	    buf = firstbuf;
    }

#ifdef FEAT_ARABIC
    free_cmdline_buf();
#endif

    /* Clear registers. */
    clear_registers();
    ResetRedobuff();
    ResetRedobuff();

#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
    vim_free(serverDelayedStartName);
#endif

    /* highlight info */
    free_highlight();

    reset_last_sourcing();

#ifdef FEAT_WINDOWS
    free_tabpage(first_tabpage);
    first_tabpage = NULL;
#endif

# ifdef UNIX
    /* Machine-specific free. */
    mch_free_mem();
# endif

    /* message history */
    for (;;)
	if (delete_first_msg() == FAIL)
	    break;

# ifdef FEAT_EVAL
    eval_clear();
# endif

    free_termoptions();

    /* screenlines (can't display anything now!) */
    free_screenlines();

#if defined(USE_XSMP)
    xsmp_close();
#endif
#ifdef FEAT_GUI_GTK
    gui_mch_free_all();
#endif
    clear_hl_tables();

    vim_free(IObuff);
    vim_free(NameBuff);
}
#endif

/*
 * Copy "string" into newly allocated memory.
 */
    char_u *
vim_strsave(string)
    char_u	*string;
{
    char_u	*p;
    unsigned	len;

    len = (unsigned)STRLEN(string) + 1;
    p = alloc(len);
    if (p != NULL)
	mch_memmove(p, string, (size_t)len);
    return p;
}

/*
 * Copy up to "len" bytes of "string" into newly allocated memory and
 * terminate with a NUL.
 * The allocated memory always has size "len + 1", also when "string" is
 * shorter.
 */
    char_u *
vim_strnsave(string, len)
    char_u	*string;
    int		len;
{
    char_u	*p;

    p = alloc((unsigned)(len + 1));
    if (p != NULL)
    {
	STRNCPY(p, string, len);
	p[len] = NUL;
    }
    return p;
}

/*
 * Same as vim_strsave(), but any characters found in esc_chars are preceded
 * by a backslash.
 */
    char_u *
vim_strsave_escaped(string, esc_chars)
    char_u	*string;
    char_u	*esc_chars;
{
    return vim_strsave_escaped_ext(string, esc_chars, '\\', FALSE);
}

/*
 * Same as vim_strsave_escaped(), but when "bsl" is TRUE also escape
 * characters where rem_backslash() would remove the backslash.
 * Escape the characters with "cc".
 */
    char_u *
vim_strsave_escaped_ext(string, esc_chars, cc, bsl)
    char_u	*string;
    char_u	*esc_chars;
    int		cc;
    int		bsl;
{
    char_u	*p;
    char_u	*p2;
    char_u	*escaped_string;
    unsigned	length;
#ifdef FEAT_MBYTE
    int		l;
#endif

    /*
     * First count the number of backslashes required.
     * Then allocate the memory and insert them.
     */
    length = 1;				/* count the trailing NUL */
    for (p = string; *p; p++)
    {
#ifdef FEAT_MBYTE
	if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
	{
	    length += l;		/* count a multibyte char */
	    p += l - 1;
	    continue;
	}
#endif
	if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
	    ++length;			/* count a backslash */
	++length;			/* count an ordinary char */
    }
    escaped_string = alloc(length);
    if (escaped_string != NULL)
    {
	p2 = escaped_string;
	for (p = string; *p; p++)
	{
#ifdef FEAT_MBYTE
	    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
	    {
		mch_memmove(p2, p, (size_t)l);
		p2 += l;
		p += l - 1;		/* skip multibyte char  */
		continue;
	    }
#endif
	    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
		*p2++ = cc;
	    *p2++ = *p;
	}
	*p2 = NUL;
    }
    return escaped_string;
}

/*
 * Return TRUE when 'shell' has "csh" in the tail.
 */
    int
csh_like_shell()
{
    return (strstr((char *)gettail(p_sh), "csh") != NULL);
}

/*
 * Escape "string" for use as a shell argument with system().
 * This uses single quotes, except when we know we need to use double quotes
 * (MS-DOS and MS-Windows without 'shellslash' set).
 * Escape a newline, depending on the 'shell' option.
 * When "do_special" is TRUE also replace "!", "%", "#" and things starting
 * with "<" like "<cfile>".
 * Returns the result in allocated memory, NULL if we have run out.
 */
    char_u *
vim_strsave_shellescape(string, do_special)
    char_u	*string;
    int		do_special;
{
    unsigned	length;
    char_u	*p;
    char_u	*d;
    char_u	*escaped_string;
    int		l;
    int		csh_like;

    /* Only csh and similar shells expand '!' within single quotes.  For sh and
     * the like we must not put a backslash before it, it will be taken
     * literally.  If do_special is set the '!' will be escaped twice.
     * Csh also needs to have "\n" escaped twice when do_special is set. */
    csh_like = csh_like_shell();

    /* First count the number of extra bytes required. */
    length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
    for (p = string; *p != NUL; mb_ptr_adv(p))
    {
# if defined(WIN32) || defined(WIN16) || defined(DOS)
	if (!p_ssl)
	{
	    if (*p == '"')
		++length;		/* " -> "" */
	}
	else
# endif
	if (*p == '\'')
	    length += 3;		/* ' => '\'' */
	if (*p == '\n' || (*p == '!' && (csh_like || do_special)))
	{
	    ++length;			/* insert backslash */
	    if (csh_like && do_special)
		++length;		/* insert backslash */
	}
	if (do_special && find_cmdline_var(p, &l) >= 0)
	{
	    ++length;			/* insert backslash */
	    p += l - 1;
	}
    }

    /* Allocate memory for the result and fill it. */
    escaped_string = alloc(length);
    if (escaped_string != NULL)
    {
	d = escaped_string;

	/* add opening quote */
# if defined(WIN32) || defined(WIN16) || defined(DOS)
	if (!p_ssl)
	    *d++ = '"';
	else
# endif
	    *d++ = '\'';

	for (p = string; *p != NUL; )
	{
# if defined(WIN32) || defined(WIN16) || defined(DOS)
	    if (!p_ssl)
	    {
		if (*p == '"')
		{
		    *d++ = '"';
		    *d++ = '"';
		    ++p;
		    continue;
		}
	    }
	    else
# endif
	    if (*p == '\'')
	    {
		*d++ = '\'';
		*d++ = '\\';
		*d++ = '\'';
		*d++ = '\'';
		++p;
		continue;
	    }
	    if (*p == '\n' || (*p == '!' && (csh_like || do_special)))
	    {
		*d++ = '\\';
		if (csh_like && do_special)
		    *d++ = '\\';
		*d++ = *p++;
		continue;
	    }
	    if (do_special && find_cmdline_var(p, &l) >= 0)
	    {
		*d++ = '\\';		/* insert backslash */
		while (--l >= 0)	/* copy the var */
		    *d++ = *p++;
		continue;
	    }

	    MB_COPY_CHAR(p, d);
	}

	/* add terminating quote and finish with a NUL */
# if defined(WIN32) || defined(WIN16) || defined(DOS)
	if (!p_ssl)
	    *d++ = '"';
	else
# endif
	    *d++ = '\'';
	*d = NUL;
    }

    return escaped_string;
}

/*
 * Like vim_strsave(), but make all characters uppercase.
 * This uses ASCII lower-to-upper case translation, language independent.
 */
    char_u *
vim_strsave_up(string)
    char_u	*string;
{
    char_u *p1;

    p1 = vim_strsave(string);
    vim_strup(p1);
    return p1;
}

/*
 * Like vim_strnsave(), but make all characters uppercase.
 * This uses ASCII lower-to-upper case translation, language independent.
 */
    char_u *
vim_strnsave_up(string, len)
    char_u	*string;
    int		len;
{
    char_u *p1;

    p1 = vim_strnsave(string, len);
    vim_strup(p1);
    return p1;
}

/*
 * ASCII lower-to-upper case translation, language independent.
 */
    void
vim_strup(p)
    char_u	*p;
{
    char_u  *p2;
    int	    c;

    if (p != NULL)
    {
	p2 = p;
	while ((c = *p2) != NUL)
#ifdef EBCDIC
	    *p2++ = isalpha(c) ? toupper(c) : c;
#else
	    *p2++ = (c < 'a' || c > 'z') ? c : (c - 0x20);
#endif
    }
}

#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)
/*
 * Make string "s" all upper-case and return it in allocated memory.
 * Handles multi-byte characters as well as possible.
 * Returns NULL when out of memory.
 */
    char_u *
strup_save(orig)
    char_u	*orig;
{
    char_u	*p;
    char_u	*res;

    res = p = vim_strsave(orig);

    if (res != NULL)
	while (*p != NUL)
	{
# ifdef FEAT_MBYTE
	    int		l;

	    if (enc_utf8)
	    {
		int	c, uc;
		int	newl;
		char_u	*s;

		c = utf_ptr2char(p);
		uc = utf_toupper(c);

		/* Reallocate string when byte count changes.  This is rare,
		 * thus it's OK to do another malloc()/free(). */
		l = utf_ptr2len(p);
		newl = utf_char2len(uc);
		if (newl != l)
		{
		    s = alloc((unsigned)STRLEN(res) + 1 + newl - l);
		    if (s == NULL)
			break;
		    mch_memmove(s, res, p - res);
		    STRCPY(s + (p - res) + newl, p + l);
		    p = s + (p - res);
		    vim_free(res);
		    res = s;
		}

		utf_char2bytes(uc, p);
		p += newl;
	    }
	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
		p += l;		/* skip multi-byte character */
	    else
# endif
	    {
		*p = TOUPPER_LOC(*p); /* note that toupper() can be a macro */
		p++;
	    }
	}

    return res;
}
#endif

/*
 * copy a space a number of times
 */
    void
copy_spaces(ptr, count)
    char_u	*ptr;
    size_t	count;
{
    size_t	i = count;
    char_u	*p = ptr;

    while (i--)
	*p++ = ' ';
}

#if defined(FEAT_VISUALEXTRA) || defined(PROTO)
/*
 * Copy a character a number of times.
 * Does not work for multi-byte characters!
 */
    void
copy_chars(ptr, count, c)
    char_u	*ptr;
    size_t	count;
    int		c;
{
    size_t	i = count;
    char_u	*p = ptr;

    while (i--)
	*p++ = c;
}
#endif

/*
 * delete spaces at the end of a string
 */
    void
del_trailing_spaces(ptr)
    char_u	*ptr;
{
    char_u	*q;

    q = ptr + STRLEN(ptr);
    while (--q > ptr && vim_iswhite(q[0]) && q[-1] != '\\' && q[-1] != Ctrl_V)
	*q = NUL;
}

/*
 * Like strncpy(), but always terminate the result with one NUL.
 * "to" must be "len + 1" long!
 */
    void
vim_strncpy(to, from, len)
    char_u	*to;
    char_u	*from;
    size_t	len;
{
    STRNCPY(to, from, len);
    to[len] = NUL;
}

/*
 * Like strcat(), but make sure the result fits in "tosize" bytes and is
 * always NUL terminated.
 */
    void
vim_strcat(to, from, tosize)
    char_u	*to;
    char_u	*from;
    size_t	tosize;
{
    size_t tolen = STRLEN(to);
    size_t fromlen = STRLEN(from);

    if (tolen + fromlen + 1 > tosize)
    {
	mch_memmove(to + tolen, from, tosize - tolen - 1);
	to[tosize - 1] = NUL;
    }
    else
	STRCPY(to + tolen, from);
}

/*
 * Isolate one part of a string option where parts are separated with
 * "sep_chars".
 * The part is copied into "buf[maxlen]".
 * "*option" is advanced to the next part.
 * The length is returned.
 */
    int
copy_option_part(option, buf, maxlen, sep_chars)
    char_u	**option;
    char_u	*buf;
    int		maxlen;
    char	*sep_chars;
{
    int	    len = 0;
    char_u  *p = *option;

    /* skip '.' at start of option part, for 'suffixes' */
    if (*p == '.')
	buf[len++] = *p++;
    while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL)
    {
	/*
	 * Skip backslash before a separator character and space.
	 */
	if (p[0] == '\\' && vim_strchr((char_u *)sep_chars, p[1]) != NULL)
	    ++p;
	if (len < maxlen - 1)
	    buf[len++] = *p;
	++p;
    }
    buf[len] = NUL;

    if (*p != NUL && *p != ',')	/* skip non-standard separator */
	++p;
    p = skip_to_option_part(p);	/* p points to next file name */

    *option = p;
    return len;
}

/*
 * Replacement for free() that ignores NULL pointers.
 * Also skip free() when exiting for sure, this helps when we caught a deadly
 * signal that was caused by a crash in free().
 */
    void
vim_free(x)
    void *x;
{
    if (x != NULL && !really_exiting)
    {
#ifdef MEM_PROFILE
	mem_pre_free(&x);
#endif
	free(x);
    }
}

#ifndef HAVE_MEMSET
    void *
vim_memset(ptr, c, size)
    void    *ptr;
    int	    c;
    size_t  size;
{
    char *p = ptr;

    while (size-- > 0)
	*p++ = c;
    return ptr;
}
#endif

#ifdef VIM_MEMCMP
/*
 * Return zero when "b1" and "b2" are the same for "len" bytes.
 * Return non-zero otherwise.
 */
    int
vim_memcmp(b1, b2, len)
    void    *b1;
    void    *b2;
    size_t  len;
{
    char_u  *p1 = (char_u *)b1, *p2 = (char_u *)b2;

    for ( ; len > 0; --len)
    {
	if (*p1 != *p2)
	    return 1;
	++p1;
	++p2;
    }
    return 0;
}
#endif

#ifdef VIM_MEMMOVE
/*
 * Version of memmove() that handles overlapping source and destination.
 * For systems that don't have a function that is guaranteed to do that (SYSV).
 */
    void
mch_memmove(dst_arg, src_arg, len)
    void    *src_arg, *dst_arg;
    size_t  len;
{
    /*
     * A void doesn't have a size, we use char pointers.
     */
    char *dst = dst_arg, *src = src_arg;

					/* overlap, copy backwards */
    if (dst > src && dst < src + len)
    {
	src += len;
	dst += len;
	while (len-- > 0)
	    *--dst = *--src;
    }
    else				/* copy forwards */
	while (len-- > 0)
	    *dst++ = *src++;
}
#endif

#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP)) || defined(PROTO)
/*
 * Compare two strings, ignoring case, using current locale.
 * Doesn't work for multi-byte characters.
 * return 0 for match, < 0 for smaller, > 0 for bigger
 */
    int
vim_stricmp(s1, s2)
    char	*s1;
    char	*s2;
{
    int		i;

    for (;;)
    {
	i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);
	if (i != 0)
	    return i;			    /* this character different */
	if (*s1 == NUL)
	    break;			    /* strings match until NUL */
	++s1;
	++s2;
    }
    return 0;				    /* strings match */
}
#endif

#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP)) || defined(PROTO)
/*
 * Compare two strings, for length "len", ignoring case, using current locale.
 * Doesn't work for multi-byte characters.
 * return 0 for match, < 0 for smaller, > 0 for bigger
 */
    int
vim_strnicmp(s1, s2, len)
    char	*s1;
    char	*s2;
    size_t	len;
{
    int		i;

    while (len > 0)
    {
	i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);
	if (i != 0)
	    return i;			    /* this character different */
	if (*s1 == NUL)
	    break;			    /* strings match until NUL */
	++s1;
	++s2;
	--len;
    }
    return 0;				    /* strings match */
}
#endif

/*
 * Version of strchr() and strrchr() that handle unsigned char strings
 * with characters from 128 to 255 correctly.  It also doesn't return a
 * pointer to the NUL at the end of the string.
 */
    char_u  *
vim_strchr(string, c)
    char_u	*string;
    int		c;
{
    char_u	*p;
    int		b;

    p = string;
#ifdef FEAT_MBYTE
    if (enc_utf8 && c >= 0x80)
    {
	while (*p != NUL)
	{
	    if (utf_ptr2char(p) == c)
		return p;
	    p += (*mb_ptr2len)(p);
	}
	return NULL;
    }
    if (enc_dbcs != 0 && c > 255)
    {
	int	n2 = c & 0xff;

	c = ((unsigned)c >> 8) & 0xff;
	while ((b = *p) != NUL)
	{
	    if (b == c && p[1] == n2)
		return p;
	    p += (*mb_ptr2len)(p);
	}
	return NULL;
    }
    if (has_mbyte)
    {
	while ((b = *p) != NUL)
	{
	    if (b == c)
		return p;
	    p += (*mb_ptr2len)(p);
	}
	return NULL;
    }
#endif
    while ((b = *p) != NUL)
    {
	if (b == c)
	    return p;
	++p;
    }
    return NULL;
}

/*
 * Version of strchr() that only works for bytes and handles unsigned char
 * strings with characters above 128 correctly. It also doesn't return a
 * pointer to the NUL at the end of the string.
 */
    char_u  *
vim_strbyte(string, c)
    char_u	*string;
    int		c;
{
    char_u	*p = string;

    while (*p != NUL)
    {
	if (*p == c)
	    return p;
	++p;
    }
    return NULL;
}

/*
 * Search for last occurrence of "c" in "string".
 * Return NULL if not found.
 * Does not handle multi-byte char for "c"!
 */
    char_u  *
vim_strrchr(string, c)
    char_u	*string;
    int		c;
{
    char_u	*retval = NULL;
    char_u	*p = string;

    while (*p)
    {
	if (*p == c)
	    retval = p;
	mb_ptr_adv(p);
    }
    return retval;
}

/*
 * Vim's version of strpbrk(), in case it's missing.
 * Don't generate a prototype for this, causes problems when it's not used.
 */
#ifndef PROTO
# ifndef HAVE_STRPBRK
#  ifdef vim_strpbrk
#   undef vim_strpbrk
#  endif
    char_u *
vim_strpbrk(s, charset)
    char_u	*s;
    char_u	*charset;
{
    while (*s)
    {
	if (vim_strchr(charset, *s) != NULL)
	    return s;
	mb_ptr_adv(s);
    }
    return NULL;
}
# endif
#endif

/*
 * Vim has its own isspace() function, because on some machines isspace()
 * can't handle characters above 128.
 */
    int
vim_isspace(x)
    int	    x;
{
    return ((x >= 9 && x <= 13) || x == ' ');
}

/************************************************************************
 * Functions for handling growing arrays.
 */

/*
 * Clear an allocated growing array.
 */
    void
ga_clear(gap)
    garray_T *gap;
{
    vim_free(gap->ga_data);
    ga_init(gap);
}

/*
 * Clear a growing array that contains a list of strings.
 */
    void
ga_clear_strings(gap)
    garray_T *gap;
{
    int		i;

    for (i = 0; i < gap->ga_len; ++i)
	vim_free(((char_u **)(gap->ga_data))[i]);
    ga_clear(gap);
}

/*
 * Initialize a growing array.	Don't forget to set ga_itemsize and
 * ga_growsize!  Or use ga_init2().
 */
    void
ga_init(gap)
    garray_T *gap;
{
    gap->ga_data = NULL;
    gap->ga_maxlen = 0;
    gap->ga_len = 0;
}

    void
ga_init2(gap, itemsize, growsize)
    garray_T	*gap;
    int		itemsize;
    int		growsize;
{
    ga_init(gap);
    gap->ga_itemsize = itemsize;
    gap->ga_growsize = growsize;
}

/*
 * Make room in growing array "gap" for at least "n" items.
 * Return FAIL for failure, OK otherwise.
 */
    int
ga_grow(gap, n)
    garray_T	*gap;
    int		n;
{
    size_t	old_len;
    size_t	new_len;
    char_u	*pp;

    if (gap->ga_maxlen - gap->ga_len < n)
    {
	if (n < gap->ga_growsize)
	    n = gap->ga_growsize;
	new_len = gap->ga_itemsize * (gap->ga_len + n);
	pp = (gap->ga_data == NULL)
	      ? alloc((unsigned)new_len) : vim_realloc(gap->ga_data, new_len);
	if (pp == NULL)
	    return FAIL;
	old_len = gap->ga_itemsize * gap->ga_maxlen;
	vim_memset(pp + old_len, 0, new_len - old_len);
	gap->ga_maxlen = gap->ga_len + n;
	gap->ga_data = pp;
    }
    return OK;
}

/*
 * For a growing array that contains a list of strings: concatenate all the
 * strings with a separating comma.
 * Returns NULL when out of memory.
 */
    char_u *
ga_concat_strings(gap)
    garray_T *gap;
{
    int		i;
    int		len = 0;
    char_u	*s;

    for (i = 0; i < gap->ga_len; ++i)
	len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + 1;

    s = alloc(len + 1);
    if (s != NULL)
    {
	*s = NUL;
	for (i = 0; i < gap->ga_len; ++i)
	{
	    if (*s != NUL)
		STRCAT(s, ",");
	    STRCAT(s, ((char_u **)(gap->ga_data))[i]);
	}
    }
    return s;
}

/*
 * Concatenate a string to a growarray which contains characters.
 * Note: Does NOT copy the NUL at the end!
 */
    void
ga_concat(gap, s)
    garray_T	*gap;
    char_u	*s;
{
    int    len = (int)STRLEN(s);

    if (ga_grow(gap, len) == OK)
    {
	mch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);
	gap->ga_len += len;
    }
}

/*
 * Append one byte to a growarray which contains bytes.
 */
    void
ga_append(gap, c)
    garray_T	*gap;
    int		c;
{
    if (ga_grow(gap, 1) == OK)
    {
	*((char *)gap->ga_data + gap->ga_len) = c;
	++gap->ga_len;
    }
}

#if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(WIN3264)
/*
 * Append the text in "gap" below the cursor line and clear "gap".
 */
    void
append_ga_line(gap)
    garray_T	*gap;
{
    /* Remove trailing CR. */
    if (gap->ga_len > 0
	    && !curbuf->b_p_bin
	    && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)
	--gap->ga_len;
    ga_append(gap, NUL);
    ml_append(curwin->w_cursor.lnum++, gap->ga_data, 0, FALSE);
    gap->ga_len = 0;
}
#endif

/************************************************************************
 * functions that use lookup tables for various things, generally to do with
 * special key codes.
 */

/*
 * Some useful tables.
 */

static struct modmasktable
{
    short	mod_mask;	/* Bit-mask for particular key modifier */
    short	mod_flag;	/* Bit(s) for particular key modifier */
    char_u	name;		/* Single letter name of modifier */
} mod_mask_table[] =
{
    {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'M'},
    {MOD_MASK_META,		MOD_MASK_META,		(char_u)'T'},
    {MOD_MASK_CTRL,		MOD_MASK_CTRL,		(char_u)'C'},
    {MOD_MASK_SHIFT,		MOD_MASK_SHIFT,		(char_u)'S'},
    {MOD_MASK_MULTI_CLICK,	MOD_MASK_2CLICK,	(char_u)'2'},
    {MOD_MASK_MULTI_CLICK,	MOD_MASK_3CLICK,	(char_u)'3'},
    {MOD_MASK_MULTI_CLICK,	MOD_MASK_4CLICK,	(char_u)'4'},
#ifdef MACOS
    {MOD_MASK_CMD,		MOD_MASK_CMD,		(char_u)'D'},
#endif
    /* 'A' must be the last one */
    {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'A'},
    {0, 0, NUL}
};

/*
 * Shifted key terminal codes and their unshifted equivalent.
 * Don't add mouse codes here, they are handled separately!
 */
#define MOD_KEYS_ENTRY_SIZE 5

static char_u modifier_keys_table[] =
{
/*  mod mask	    with modifier		without modifier */
    MOD_MASK_SHIFT, '&', '9',			'@', '1',	/* begin */
    MOD_MASK_SHIFT, '&', '0',			'@', '2',	/* cancel */
    MOD_MASK_SHIFT, '*', '1',			'@', '4',	/* command */
    MOD_MASK_SHIFT, '*', '2',			'@', '5',	/* copy */
    MOD_MASK_SHIFT, '*', '3',			'@', '6',	/* create */
    MOD_MASK_SHIFT, '*', '4',			'k', 'D',	/* delete char */
    MOD_MASK_SHIFT, '*', '5',			'k', 'L',	/* delete line */
    MOD_MASK_SHIFT, '*', '7',			'@', '7',	/* end */
    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,	'@', '7',	/* end */
    MOD_MASK_SHIFT, '*', '9',			'@', '9',	/* exit */
    MOD_MASK_SHIFT, '*', '0',			'@', '0',	/* find */
    MOD_MASK_SHIFT, '#', '1',			'%', '1',	/* help */
    MOD_MASK_SHIFT, '#', '2',			'k', 'h',	/* home */
    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,	'k', 'h',	/* home */
    MOD_MASK_SHIFT, '#', '3',			'k', 'I',	/* insert */
    MOD_MASK_SHIFT, '#', '4',			'k', 'l',	/* left arrow */
    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,	'k', 'l',	/* left arrow */
    MOD_MASK_SHIFT, '%', 'a',			'%', '3',	/* message */
    MOD_MASK_SHIFT, '%', 'b',			'%', '4',	/* move */
    MOD_MASK_SHIFT, '%', 'c',			'%', '5',	/* next */
    MOD_MASK_SHIFT, '%', 'd',			'%', '7',	/* options */
    MOD_MASK_SHIFT, '%', 'e',			'%', '8',	/* previous */
    MOD_MASK_SHIFT, '%', 'f',			'%', '9',	/* print */
    MOD_MASK_SHIFT, '%', 'g',			'%', '0',	/* redo */
    MOD_MASK_SHIFT, '%', 'h',			'&', '3',	/* replace */
    MOD_MASK_SHIFT, '%', 'i',			'k', 'r',	/* right arr. */
    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,	'k', 'r',	/* right arr. */
    MOD_MASK_SHIFT, '%', 'j',			'&', '5',	/* resume */
    MOD_MASK_SHIFT, '!', '1',			'&', '6',	/* save */
    MOD_MASK_SHIFT, '!', '2',			'&', '7',	/* suspend */
    MOD_MASK_SHIFT, '!', '3',			'&', '8',	/* undo */
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,	'k', 'u',	/* up arrow */
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,	'k', 'd',	/* down arrow */

								/* vt100 F1 */
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,	KS_EXTRA, (int)KE_XF1,
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF2,	KS_EXTRA, (int)KE_XF2,
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF3,	KS_EXTRA, (int)KE_XF3,
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF4,	KS_EXTRA, (int)KE_XF4,

    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,	'k', '1',	/* F1 */
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,	'k', '2',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F3,	'k', '3',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F4,	'k', '4',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F5,	'k', '5',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F6,	'k', '6',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F7,	'k', '7',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F8,	'k', '8',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,	'k', '9',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,	'k', ';',	/* F10 */

    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F11,	'F', '1',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F12,	'F', '2',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F13,	'F', '3',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F14,	'F', '4',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F15,	'F', '5',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F16,	'F', '6',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F17,	'F', '7',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F18,	'F', '8',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F19,	'F', '9',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F20,	'F', 'A',

    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F21,	'F', 'B',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F22,	'F', 'C',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F23,	'F', 'D',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F24,	'F', 'E',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F25,	'F', 'F',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F26,	'F', 'G',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F27,	'F', 'H',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F28,	'F', 'I',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F29,	'F', 'J',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F30,	'F', 'K',

    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F31,	'F', 'L',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F32,	'F', 'M',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F33,	'F', 'N',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F34,	'F', 'O',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F35,	'F', 'P',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F36,	'F', 'Q',
    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F37,	'F', 'R',

							    /* TAB pseudo code*/
    MOD_MASK_SHIFT, 'k', 'B',			KS_EXTRA, (int)KE_TAB,

    NUL
};

static struct key_name_entry
{
    int	    key;	/* Special key code or ascii value */
    char_u  *name;	/* Name of key */
} key_names_table[] =
{
    {' ',		(char_u *)"Space"},
    {TAB,		(char_u *)"Tab"},
    {K_TAB,		(char_u *)"Tab"},
    {NL,		(char_u *)"NL"},
    {NL,		(char_u *)"NewLine"},	/* Alternative name */
    {NL,		(char_u *)"LineFeed"},	/* Alternative name */
    {NL,		(char_u *)"LF"},	/* Alternative name */
    {CAR,		(char_u *)"CR"},
    {CAR,		(char_u *)"Return"},	/* Alternative name */
    {CAR,		(char_u *)"Enter"},	/* Alternative name */
    {K_BS,		(char_u *)"BS"},
    {K_BS,		(char_u *)"BackSpace"},	/* Alternative name */
    {ESC,		(char_u *)"Esc"},
    {CSI,		(char_u *)"CSI"},
    {K_CSI,		(char_u *)"xCSI"},
    {'|',		(char_u *)"Bar"},
    {'\\',		(char_u *)"Bslash"},
    {K_DEL,		(char_u *)"Del"},
    {K_DEL,		(char_u *)"Delete"},	/* Alternative name */
    {K_KDEL,		(char_u *)"kDel"},
    {K_UP,		(char_u *)"Up"},
    {K_DOWN,		(char_u *)"Down"},
    {K_LEFT,		(char_u *)"Left"},
    {K_RIGHT,		(char_u *)"Right"},
    {K_XUP,		(char_u *)"xUp"},
    {K_XDOWN,		(char_u *)"xDown"},
    {K_XLEFT,		(char_u *)"xLeft"},
    {K_XRIGHT,		(char_u *)"xRight"},

    {K_F1,		(char_u *)"F1"},
    {K_F2,		(char_u *)"F2"},
    {K_F3,		(char_u *)"F3"},
    {K_F4,		(char_u *)"F4"},
    {K_F5,		(char_u *)"F5"},
    {K_F6,		(char_u *)"F6"},
    {K_F7,		(char_u *)"F7"},
    {K_F8,		(char_u *)"F8"},
    {K_F9,		(char_u *)"F9"},
    {K_F10,		(char_u *)"F10"},

    {K_F11,		(char_u *)"F11"},
    {K_F12,		(char_u *)"F12"},
    {K_F13,		(char_u *)"F13"},
    {K_F14,		(char_u *)"F14"},
    {K_F15,		(char_u *)"F15"},
    {K_F16,		(char_u *)"F16"},
    {K_F17,		(char_u *)"F17"},
    {K_F18,		(char_u *)"F18"},
    {K_F19,		(char_u *)"F19"},
    {K_F20,		(char_u *)"F20"},

    {K_F21,		(char_u *)"F21"},
    {K_F22,		(char_u *)"F22"},
    {K_F23,		(char_u *)"F23"},
    {K_F24,		(char_u *)"F24"},
    {K_F25,		(char_u *)"F25"},
    {K_F26,		(char_u *)"F26"},
    {K_F27,		(char_u *)"F27"},
    {K_F28,		(char_u *)"F28"},
    {K_F29,		(char_u *)"F29"},
    {K_F30,		(char_u *)"F30"},

    {K_F31,		(char_u *)"F31"},
    {K_F32,		(char_u *)"F32"},
    {K_F33,		(char_u *)"F33"},
    {K_F34,		(char_u *)"F34"},
    {K_F35,		(char_u *)"F35"},
    {K_F36,		(char_u *)"F36"},
    {K_F37,		(char_u *)"F37"},

    {K_XF1,		(char_u *)"xF1"},
    {K_XF2,		(char_u *)"xF2"},
    {K_XF3,		(char_u *)"xF3"},
    {K_XF4,		(char_u *)"xF4"},

    {K_HELP,		(char_u *)"Help"},
    {K_UNDO,		(char_u *)"Undo"},
    {K_INS,		(char_u *)"Insert"},
    {K_INS,		(char_u *)"Ins"},	/* Alternative name */
    {K_KINS,		(char_u *)"kInsert"},
    {K_HOME,		(char_u *)"Home"},
    {K_KHOME,		(char_u *)"kHome"},
    {K_XHOME,		(char_u *)"xHome"},
    {K_ZHOME,		(char_u *)"zHome"},
    {K_END,		(char_u *)"End"},
    {K_KEND,		(char_u *)"kEnd"},
    {K_XEND,		(char_u *)"xEnd"},
    {K_ZEND,		(char_u *)"zEnd"},
    {K_PAGEUP,		(char_u *)"PageUp"},
    {K_PAGEDOWN,	(char_u *)"PageDown"},
    {K_KPAGEUP,		(char_u *)"kPageUp"},
    {K_KPAGEDOWN,	(char_u *)"kPageDown"},

    {K_KPLUS,		(char_u *)"kPlus"},
    {K_KMINUS,		(char_u *)"kMinus"},
    {K_KDIVIDE,		(char_u *)"kDivide"},
    {K_KMULTIPLY,	(char_u *)"kMultiply"},
    {K_KENTER,		(char_u *)"kEnter"},
    {K_KPOINT,		(char_u *)"kPoint"},

    {K_K0,		(char_u *)"k0"},
    {K_K1,		(char_u *)"k1"},
    {K_K2,		(char_u *)"k2"},
    {K_K3,		(char_u *)"k3"},
    {K_K4,		(char_u *)"k4"},
    {K_K5,		(char_u *)"k5"},
    {K_K6,		(char_u *)"k6"},
    {K_K7,		(char_u *)"k7"},
    {K_K8,		(char_u *)"k8"},
    {K_K9,		(char_u *)"k9"},

    {'<',		(char_u *)"lt"},

    {K_MOUSE,		(char_u *)"Mouse"},
#ifdef FEAT_MOUSE_NET
    {K_NETTERM_MOUSE,	(char_u *)"NetMouse"},
#endif
#ifdef FEAT_MOUSE_DEC
    {K_DEC_MOUSE,	(char_u *)"DecMouse"},
#endif
#ifdef FEAT_MOUSE_JSB
    {K_JSBTERM_MOUSE,	(char_u *)"JsbMouse"},
#endif
#ifdef FEAT_MOUSE_PTERM
    {K_PTERM_MOUSE,	(char_u *)"PtermMouse"},
#endif
#ifdef FEAT_MOUSE_URXVT
    {K_URXVT_MOUSE,	(char_u *)"UrxvtMouse"},
#endif
#ifdef FEAT_MOUSE_SGR
    {K_SGR_MOUSE,	(char_u *)"SgrMouse"},
#endif
    {K_LEFTMOUSE,	(char_u *)"LeftMouse"},
    {K_LEFTMOUSE_NM,	(char_u *)"LeftMouseNM"},
    {K_LEFTDRAG,	(char_u *)"LeftDrag"},
    {K_LEFTRELEASE,	(char_u *)"LeftRelease"},
    {K_LEFTRELEASE_NM,	(char_u *)"LeftReleaseNM"},
    {K_MIDDLEMOUSE,	(char_u *)"MiddleMouse"},
    {K_MIDDLEDRAG,	(char_u *)"MiddleDrag"},
    {K_MIDDLERELEASE,	(char_u *)"MiddleRelease"},
    {K_RIGHTMOUSE,	(char_u *)"RightMouse"},
    {K_RIGHTDRAG,	(char_u *)"RightDrag"},
    {K_RIGHTRELEASE,	(char_u *)"RightRelease"},
    {K_MOUSEDOWN,	(char_u *)"ScrollWheelUp"},
    {K_MOUSEUP,		(char_u *)"ScrollWheelDown"},
    {K_MOUSELEFT,	(char_u *)"ScrollWheelRight"},
    {K_MOUSERIGHT,	(char_u *)"ScrollWheelLeft"},
    {K_MOUSEDOWN,	(char_u *)"MouseDown"}, /* OBSOLETE: Use	  */
    {K_MOUSEUP,		(char_u *)"MouseUp"},	/* ScrollWheelXXX instead */
    {K_X1MOUSE,		(char_u *)"X1Mouse"},
    {K_X1DRAG,		(char_u *)"X1Drag"},
    {K_X1RELEASE,		(char_u *)"X1Release"},
    {K_X2MOUSE,		(char_u *)"X2Mouse"},
    {K_X2DRAG,		(char_u *)"X2Drag"},
    {K_X2RELEASE,		(char_u *)"X2Release"},
    {K_DROP,		(char_u *)"Drop"},
    {K_ZERO,		(char_u *)"Nul"},
#ifdef FEAT_EVAL
    {K_SNR,		(char_u *)"SNR"},
#endif
    {K_PLUG,		(char_u *)"Plug"},
    {0,			NULL}
};

#define KEY_NAMES_TABLE_LEN (sizeof(key_names_table) / sizeof(struct key_name_entry))

#ifdef FEAT_MOUSE
static struct mousetable
{
    int	    pseudo_code;	/* Code for pseudo mouse event */
    int	    button;		/* Which mouse button is it? */
    int	    is_click;		/* Is it a mouse button click event? */
    int	    is_drag;		/* Is it a mouse drag event? */
} mouse_table[] =
{
    {(int)KE_LEFTMOUSE,		MOUSE_LEFT,	TRUE,	FALSE},
#ifdef FEAT_GUI
    {(int)KE_LEFTMOUSE_NM,	MOUSE_LEFT,	TRUE,	FALSE},
#endif
    {(int)KE_LEFTDRAG,		MOUSE_LEFT,	FALSE,	TRUE},
    {(int)KE_LEFTRELEASE,	MOUSE_LEFT,	FALSE,	FALSE},
#ifdef FEAT_GUI
    {(int)KE_LEFTRELEASE_NM,	MOUSE_LEFT,	FALSE,	FALSE},
#endif
    {(int)KE_MIDDLEMOUSE,	MOUSE_MIDDLE,	TRUE,	FALSE},
    {(int)KE_MIDDLEDRAG,	MOUSE_MIDDLE,	FALSE,	TRUE},
    {(int)KE_MIDDLERELEASE,	MOUSE_MIDDLE,	FALSE,	FALSE},
    {(int)KE_RIGHTMOUSE,	MOUSE_RIGHT,	TRUE,	FALSE},
    {(int)KE_RIGHTDRAG,		MOUSE_RIGHT,	FALSE,	TRUE},
    {(int)KE_RIGHTRELEASE,	MOUSE_RIGHT,	FALSE,	FALSE},
    {(int)KE_X1MOUSE,		MOUSE_X1,	TRUE,	FALSE},
    {(int)KE_X1DRAG,		MOUSE_X1,	FALSE,	TRUE},
    {(int)KE_X1RELEASE,		MOUSE_X1,	FALSE,	FALSE},
    {(int)KE_X2MOUSE,		MOUSE_X2,	TRUE,	FALSE},
    {(int)KE_X2DRAG,		MOUSE_X2,	FALSE,	TRUE},
    {(int)KE_X2RELEASE,		MOUSE_X2,	FALSE,	FALSE},
    /* DRAG without CLICK */
    {(int)KE_IGNORE,		MOUSE_RELEASE,	FALSE,	TRUE},
    /* RELEASE without CLICK */
    {(int)KE_IGNORE,		MOUSE_RELEASE,	FALSE,	FALSE},
    {0,				0,		0,	0},
};
#endif /* FEAT_MOUSE */

/*
 * Return the modifier mask bit (MOD_MASK_*) which corresponds to the given
 * modifier name ('S' for Shift, 'C' for Ctrl etc).
 */
    int
name_to_mod_mask(c)
    int	    c;
{
    int	    i;

    c = TOUPPER_ASC(c);
    for (i = 0; mod_mask_table[i].mod_mask != 0; i++)
	if (c == mod_mask_table[i].name)
	    return mod_mask_table[i].mod_flag;
    return 0;
}

/*
 * Check if if there is a special key code for "key" that includes the
 * modifiers specified.
 */
    int
simplify_key(key, modifiers)
    int	    key;
    int	    *modifiers;
{
    int	    i;
    int	    key0;
    int	    key1;

    if (*modifiers & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT))
    {
	/* TAB is a special case */
	if (key == TAB && (*modifiers & MOD_MASK_SHIFT))
	{
	    *modifiers &= ~MOD_MASK_SHIFT;
	    return K_S_TAB;
	}
	key0 = KEY2TERMCAP0(key);
	key1 = KEY2TERMCAP1(key);
	for (i = 0; modifier_keys_table[i] != NUL; i += MOD_KEYS_ENTRY_SIZE)
	    if (key0 == modifier_keys_table[i + 3]
		    && key1 == modifier_keys_table[i + 4]
		    && (*modifiers & modifier_keys_table[i]))
	    {
		*modifiers &= ~modifier_keys_table[i];
		return TERMCAP2KEY(modifier_keys_table[i + 1],
						   modifier_keys_table[i + 2]);
	    }
    }
    return key;
}

/*
 * Change <xHome> to <Home>, <xUp> to <Up>, etc.
 */
    int
handle_x_keys(key)
    int	    key;
{
    switch (key)
    {
	case K_XUP:	return K_UP;
	case K_XDOWN:	return K_DOWN;
	case K_XLEFT:	return K_LEFT;
	case K_XRIGHT:	return K_RIGHT;
	case K_XHOME:	return K_HOME;
	case K_ZHOME:	return K_HOME;
	case K_XEND:	return K_END;
	case K_ZEND:	return K_END;
	case K_XF1:	return K_F1;
	case K_XF2:	return K_F2;
	case K_XF3:	return K_F3;
	case K_XF4:	return K_F4;
	case K_S_XF1:	return K_S_F1;
	case K_S_XF2:	return K_S_F2;
	case K_S_XF3:	return K_S_F3;
	case K_S_XF4:	return K_S_F4;
    }
    return key;
}

/*
 * Return a string which contains the name of the given key when the given
 * modifiers are down.
 */
    char_u *
get_special_key_name(c, modifiers)
    int	    c;
    int	    modifiers;
{
    static char_u string[MAX_KEY_NAME_LEN + 1];

    int	    i, idx;
    int	    table_idx;
    char_u  *s;

    string[0] = '<';
    idx = 1;

    /* Key that stands for a normal character. */
    if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)
	c = KEY2TERMCAP1(c);

    /*
     * Translate shifted special keys into unshifted keys and set modifier.
     * Same for CTRL and ALT modifiers.
     */
    if (IS_SPECIAL(c))
    {
	for (i = 0; modifier_keys_table[i] != 0; i += MOD_KEYS_ENTRY_SIZE)
	    if (       KEY2TERMCAP0(c) == (int)modifier_keys_table[i + 1]
		    && (int)KEY2TERMCAP1(c) == (int)modifier_keys_table[i + 2])
	    {
		modifiers |= modifier_keys_table[i];
		c = TERMCAP2KEY(modifier_keys_table[i + 3],
						   modifier_keys_table[i + 4]);
		break;
	    }
    }

    /* try to find the key in the special key table */
    table_idx = find_special_key_in_table(c);

    /*
     * When not a known special key, and not a printable character, try to
     * extract modifiers.
     */
    if (c > 0
#ifdef FEAT_MBYTE
	    && (*mb_char2len)(c) == 1
#endif
       )
    {
	if (table_idx < 0
		&& (!vim_isprintc(c) || (c & 0x7f) == ' ')
		&& (c & 0x80))
	{
	    c &= 0x7f;
	    modifiers |= MOD_MASK_ALT;
	    /* try again, to find the un-alted key in the special key table */
	    table_idx = find_special_key_in_table(c);
	}
	if (table_idx < 0 && !vim_isprintc(c) && c < ' ')
	{
#ifdef EBCDIC
	    c = CtrlChar(c);
#else
	    c += '@';
#endif
	    modifiers |= MOD_MASK_CTRL;
	}
    }

    /* translate the modifier into a string */
    for (i = 0; mod_mask_table[i].name != 'A'; i++)
	if ((modifiers & mod_mask_table[i].mod_mask)
						== mod_mask_table[i].mod_flag)
	{
	    string[idx++] = mod_mask_table[i].name;
	    string[idx++] = (char_u)'-';
	}

    if (table_idx < 0)		/* unknown special key, may output t_xx */
    {
	if (IS_SPECIAL(c))
	{
	    string[idx++] = 't';
	    string[idx++] = '_';
	    string[idx++] = KEY2TERMCAP0(c);
	    string[idx++] = KEY2TERMCAP1(c);
	}
	/* Not a special key, only modifiers, output directly */
	else
	{
#ifdef FEAT_MBYTE
	    if (has_mbyte && (*mb_char2len)(c) > 1)
		idx += (*mb_char2bytes)(c, string + idx);
	    else
#endif
	    if (vim_isprintc(c))
		string[idx++] = c;
	    else
	    {
		s = transchar(c);
		while (*s)
		    string[idx++] = *s++;
	    }
	}
    }
    else		/* use name of special key */
    {
	STRCPY(string + idx, key_names_table[table_idx].name);
	idx = (int)STRLEN(string);
    }
    string[idx++] = '>';
    string[idx] = NUL;
    return string;
}

/*
 * Try translating a <> name at (*srcp)[] to dst[].
 * Return the number of characters added to dst[], zero for no match.
 * If there is a match, srcp is advanced to after the <> name.
 * dst[] must be big enough to hold the result (up to six characters)!
 */
    int
trans_special(srcp, dst, keycode)
    char_u	**srcp;
    char_u	*dst;
    int		keycode; /* prefer key code, e.g. K_DEL instead of DEL */
{
    int		modifiers = 0;
    int		key;
    int		dlen = 0;

    key = find_special_key(srcp, &modifiers, keycode, FALSE);
    if (key == 0)
	return 0;

    /* Put the appropriate modifier in a string */
    if (modifiers != 0)
    {
	dst[dlen++] = K_SPECIAL;
	dst[dlen++] = KS_MODIFIER;
	dst[dlen++] = modifiers;
    }

    if (IS_SPECIAL(key))
    {
	dst[dlen++] = K_SPECIAL;
	dst[dlen++] = KEY2TERMCAP0(key);
	dst[dlen++] = KEY2TERMCAP1(key);
    }
#ifdef FEAT_MBYTE
    else if (has_mbyte && !keycode)
	dlen += (*mb_char2bytes)(key, dst + dlen);
#endif
    else if (keycode)
	dlen = (int)(add_char2buf(key, dst + dlen) - dst);
    else
	dst[dlen++] = key;

    return dlen;
}

/*
 * Try translating a <> name at (*srcp)[], return the key and modifiers.
 * srcp is advanced to after the <> name.
 * returns 0 if there is no match.
 */
    int
find_special_key(srcp, modp, keycode, keep_x_key)
    char_u	**srcp;
    int		*modp;
    int		keycode;     /* prefer key code, e.g. K_DEL instead of DEL */
    int		keep_x_key;  /* don't translate xHome to Home key */
{
    char_u	*last_dash;
    char_u	*end_of_name;
    char_u	*src;
    char_u	*bp;
    int		modifiers;
    int		bit;
    int		key;
    unsigned long n;
    int		l;

    src = *srcp;
    if (src[0] != '<')
	return 0;

    /* Find end of modifier list */
    last_dash = src;
    for (bp = src + 1; *bp == '-' || vim_isIDc(*bp); bp++)
    {
	if (*bp == '-')
	{
	    last_dash = bp;
	    if (bp[1] != NUL)
	    {
#ifdef FEAT_MBYTE
		if (has_mbyte)
		    l = mb_ptr2len(bp + 1);
		else
#endif
		    l = 1;
		if (bp[l + 1] == '>')
		    bp += l;	/* anything accepted, like <C-?> */
	    }
	}
	if (bp[0] == 't' && bp[1] == '_' && bp[2] && bp[3])
	    bp += 3;	/* skip t_xx, xx may be '-' or '>' */
	else if (STRNICMP(bp, "char-", 5) == 0)
	{
	    vim_str2nr(bp + 5, NULL, &l, TRUE, TRUE, NULL, NULL);
	    bp += l + 5;
	    break;
	}
    }

    if (*bp == '>')	/* found matching '>' */
    {
	end_of_name = bp + 1;

	/* Which modifiers are given? */
	modifiers = 0x0;
	for (bp = src + 1; bp < last_dash; bp++)
	{
	    if (*bp != '-')
	    {
		bit = name_to_mod_mask(*bp);
		if (bit == 0x0)
		    break;	/* Illegal modifier name */
		modifiers |= bit;
	    }
	}

	/*
	 * Legal modifier name.
	 */
	if (bp >= last_dash)
	{
	    if (STRNICMP(last_dash + 1, "char-", 5) == 0
						 && VIM_ISDIGIT(last_dash[6]))
	    {
		/* <Char-123> or <Char-033> or <Char-0x33> */
		vim_str2nr(last_dash + 6, NULL, NULL, TRUE, TRUE, NULL, &n);
		key = (int)n;
	    }
	    else
	    {
		/*
		 * Modifier with single letter, or special key name.
		 */
#ifdef FEAT_MBYTE
		if (has_mbyte)
		    l = mb_ptr2len(last_dash + 1);
		else
#endif
		    l = 1;
		if (modifiers != 0 && last_dash[l + 1] == '>')
		    key = PTR2CHAR(last_dash + 1);
		else
		{
		    key = get_special_key_code(last_dash + 1);
		    if (!keep_x_key)
			key = handle_x_keys(key);
		}
	    }

	    /*
	     * get_special_key_code() may return NUL for invalid
	     * special key name.
	     */
	    if (key != NUL)
	    {
		/*
		 * Only use a modifier when there is no special key code that
		 * includes the modifier.
		 */
		key = simplify_key(key, &modifiers);

		if (!keycode)
		{
		    /* don't want keycode, use single byte code */
		    if (key == K_BS)
			key = BS;
		    else if (key == K_DEL || key == K_KDEL)
			key = DEL;
		}

		/*
		 * Normal Key with modifier: Try to make a single byte code.
		 */
		if (!IS_SPECIAL(key))
		    key = extract_modifiers(key, &modifiers);

		*modp = modifiers;
		*srcp = end_of_name;
		return key;
	    }
	}
    }
    return 0;
}

/*
 * Try to include modifiers in the key.
 * Changes "Shift-a" to 'A', "Alt-A" to 0xc0, etc.
 */
    int
extract_modifiers(key, modp)
    int	    key;
    int	    *modp;
{
    int	modifiers = *modp;

#ifdef MACOS
    /* Command-key really special, no fancynest */
    if (!(modifiers & MOD_MASK_CMD))
#endif
    if ((modifiers & MOD_MASK_SHIFT) && ASCII_ISALPHA(key))
    {
	key = TOUPPER_ASC(key);
	modifiers &= ~MOD_MASK_SHIFT;
    }
    if ((modifiers & MOD_MASK_CTRL)
#ifdef EBCDIC
	    /* * TODO: EBCDIC Better use:
	     * && (Ctrl_chr(key) || key == '?')
	     * ???  */
	    && strchr("?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_", key)
						       != NULL
#else
	    && ((key >= '?' && key <= '_') || ASCII_ISALPHA(key))
#endif
	    )
    {
	key = Ctrl_chr(key);
	modifiers &= ~MOD_MASK_CTRL;
	/* <C-@> is <Nul> */
	if (key == 0)
	    key = K_ZERO;
    }
#ifdef MACOS
    /* Command-key really special, no fancynest */
    if (!(modifiers & MOD_MASK_CMD))
#endif
    if ((modifiers & MOD_MASK_ALT) && key < 0x80
#ifdef FEAT_MBYTE
	    && !enc_dbcs		/* avoid creating a lead byte */
#endif
	    )
    {
	key |= 0x80;
	modifiers &= ~MOD_MASK_ALT;	/* remove the META modifier */
    }

    *modp = modifiers;
    return key;
}

/*
 * Try to find key "c" in the special key table.
 * Return the index when found, -1 when not found.
 */
    int
find_special_key_in_table(c)
    int	    c;
{
    int	    i;

    for (i = 0; key_names_table[i].name != NULL; i++)
	if (c == key_names_table[i].key)
	    break;
    if (key_names_table[i].name == NULL)
	i = -1;
    return i;
}

/*
 * Find the special key with the given name (the given string does not have to
 * end with NUL, the name is assumed to end before the first non-idchar).
 * If the name starts with "t_" the next two characters are interpreted as a
 * termcap name.
 * Return the key code, or 0 if not found.
 */
    int
get_special_key_code(name)
    char_u  *name;
{
    char_u  *table_name;
    char_u  string[3];
    int	    i, j;

    /*
     * If it's <t_xx> we get the code for xx from the termcap
     */
    if (name[0] == 't' && name[1] == '_' && name[2] != NUL && name[3] != NUL)
    {
	string[0] = name[2];
	string[1] = name[3];
	string[2] = NUL;
	if (add_termcap_entry(string, FALSE) == OK)
	    return TERMCAP2KEY(name[2], name[3]);
    }
    else
	for (i = 0; key_names_table[i].name != NULL; i++)
	{
	    table_name = key_names_table[i].name;
	    for (j = 0; vim_isIDc(name[j]) && table_name[j] != NUL; j++)
		if (TOLOWER_ASC(table_name[j]) != TOLOWER_ASC(name[j]))
		    break;
	    if (!vim_isIDc(name[j]) && table_name[j] == NUL)
		return key_names_table[i].key;
	}
    return 0;
}

#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
    char_u *
get_key_name(i)
    int	    i;
{
    if (i >= (int)KEY_NAMES_TABLE_LEN)
	return NULL;
    return  key_names_table[i].name;
}
#endif

#if defined(FEAT_MOUSE) || defined(PROTO)
/*
 * Look up the given mouse code to return the relevant information in the other
 * arguments.  Return which button is down or was released.
 */
    int
get_mouse_button(code, is_click, is_drag)
    int	    code;
    int	    *is_click;
    int	    *is_drag;
{
    int	    i;

    for (i = 0; mouse_table[i].pseudo_code; i++)
	if (code == mouse_table[i].pseudo_code)
	{
	    *is_click = mouse_table[i].is_click;
	    *is_drag = mouse_table[i].is_drag;
	    return mouse_table[i].button;
	}
    return 0;	    /* Shouldn't get here */
}

/*
 * Return the appropriate pseudo mouse event token (KE_LEFTMOUSE etc) based on
 * the given information about which mouse button is down, and whether the
 * mouse was clicked, dragged or released.
 */
    int
get_pseudo_mouse_code(button, is_click, is_drag)
    int	    button;	/* eg MOUSE_LEFT */
    int	    is_click;
    int	    is_drag;
{
    int	    i;

    for (i = 0; mouse_table[i].pseudo_code; i++)
	if (button == mouse_table[i].button
	    && is_click == mouse_table[i].is_click
	    && is_drag == mouse_table[i].is_drag)
	{
#ifdef FEAT_GUI
	    /* Trick: a non mappable left click and release has mouse_col -1
	     * or added MOUSE_COLOFF.  Used for 'mousefocus' in
	     * gui_mouse_moved() */
	    if (mouse_col < 0 || mouse_col > MOUSE_COLOFF)
	    {
		if (mouse_col < 0)
		    mouse_col = 0;
		else
		    mouse_col -= MOUSE_COLOFF;
		if (mouse_table[i].pseudo_code == (int)KE_LEFTMOUSE)
		    return (int)KE_LEFTMOUSE_NM;
		if (mouse_table[i].pseudo_code == (int)KE_LEFTRELEASE)
		    return (int)KE_LEFTRELEASE_NM;
	    }
#endif
	    return mouse_table[i].pseudo_code;
	}
    return (int)KE_IGNORE;	    /* not recognized, ignore it */
}
#endif /* FEAT_MOUSE */

/*
 * Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.
 */
    int
get_fileformat(buf)
    buf_T	*buf;
{
    int		c = *buf->b_p_ff;

    if (buf->b_p_bin || c == 'u')
	return EOL_UNIX;
    if (c == 'm')
	return EOL_MAC;
    return EOL_DOS;
}

/*
 * Like get_fileformat(), but override 'fileformat' with "p" for "++opt=val"
 * argument.
 */
    int
get_fileformat_force(buf, eap)
    buf_T	*buf;
    exarg_T	*eap;	    /* can be NULL! */
{
    int		c;

    if (eap != NULL && eap->force_ff != 0)
	c = eap->cmd[eap->force_ff];
    else
    {
	if ((eap != NULL && eap->force_bin != 0)
			       ? (eap->force_bin == FORCE_BIN) : buf->b_p_bin)
	    return EOL_UNIX;
	c = *buf->b_p_ff;
    }
    if (c == 'u')
	return EOL_UNIX;
    if (c == 'm')
	return EOL_MAC;
    return EOL_DOS;
}

/*
 * Set the current end-of-line type to EOL_DOS, EOL_UNIX or EOL_MAC.
 * Sets both 'textmode' and 'fileformat'.
 * Note: Does _not_ set global value of 'textmode'!
 */
    void
set_fileformat(t, opt_flags)
    int		t;
    int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
{
    char	*p = NULL;

    switch (t)
    {
    case EOL_DOS:
	p = FF_DOS;
	curbuf->b_p_tx = TRUE;
	break;
    case EOL_UNIX:
	p = FF_UNIX;
	curbuf->b_p_tx = FALSE;
	break;
    case EOL_MAC:
	p = FF_MAC;
	curbuf->b_p_tx = FALSE;
	break;
    }
    if (p != NULL)
	set_string_option_direct((char_u *)"ff", -1, (char_u *)p,
						     OPT_FREE | opt_flags, 0);

#ifdef FEAT_WINDOWS
    /* This may cause the buffer to become (un)modified. */
    check_status(curbuf);
    redraw_tabline = TRUE;
#endif
#ifdef FEAT_TITLE
    need_maketitle = TRUE;	    /* set window title later */
#endif
}

/*
 * Return the default fileformat from 'fileformats'.
 */
    int
default_fileformat()
{
    switch (*p_ffs)
    {
	case 'm':   return EOL_MAC;
	case 'd':   return EOL_DOS;
    }
    return EOL_UNIX;
}

/*
 * Call shell.	Calls mch_call_shell, with 'shellxquote' added.
 */
    int
call_shell(cmd, opt)
    char_u	*cmd;
    int		opt;
{
    char_u	*ncmd;
    int		retval;
#ifdef FEAT_PROFILE
    proftime_T	wait_time;
#endif

    if (p_verbose > 3)
    {
	verbose_enter();
	smsg((char_u *)_("Calling shell to execute: \"%s\""),
						    cmd == NULL ? p_sh : cmd);
	out_char('\n');
	cursor_on();
	verbose_leave();
    }

#ifdef FEAT_PROFILE
    if (do_profiling == PROF_YES)
	prof_child_enter(&wait_time);
#endif

    if (*p_sh == NUL)
    {
	EMSG(_(e_shellempty));
	retval = -1;
    }
    else
    {
#ifdef FEAT_GUI_MSWIN
	/* Don't hide the pointer while executing a shell command. */
	gui_mch_mousehide(FALSE);
#endif
#ifdef FEAT_GUI
	++hold_gui_events;
#endif
	/* The external command may update a tags file, clear cached tags. */
	tag_freematch();

	if (cmd == NULL || *p_sxq == NUL)
	    retval = mch_call_shell(cmd, opt);
	else
	{
	    char_u *ecmd = cmd;

	    if (*p_sxe != NUL && STRCMP(p_sxq, "(") == 0)
	    {
		ecmd = vim_strsave_escaped_ext(cmd, p_sxe, '^', FALSE);
		if (ecmd == NULL)
		    ecmd = cmd;
	    }
	    ncmd = alloc((unsigned)(STRLEN(ecmd) + STRLEN(p_sxq) * 2 + 1));
	    if (ncmd != NULL)
	    {
		STRCPY(ncmd, p_sxq);
		STRCAT(ncmd, ecmd);
		/* When 'shellxquote' is ( append ).
		 * When 'shellxquote' is "( append )". */
		STRCAT(ncmd, STRCMP(p_sxq, "(") == 0 ? (char_u *)")"
			   : STRCMP(p_sxq, "\"(") == 0 ? (char_u *)")\""
			   : p_sxq);
		retval = mch_call_shell(ncmd, opt);
		vim_free(ncmd);
	    }
	    else
		retval = -1;
	    if (ecmd != cmd)
		vim_free(ecmd);
	}
#ifdef FEAT_GUI
	--hold_gui_events;
#endif
	/*
	 * Check the window size, in case it changed while executing the
	 * external command.
	 */
	shell_resized_check();
    }

#ifdef FEAT_EVAL
    set_vim_var_nr(VV_SHELL_ERROR, (long)retval);
# ifdef FEAT_PROFILE
    if (do_profiling == PROF_YES)
	prof_child_exit(&wait_time);
# endif
#endif

    return retval;
}

/*
 * VISUAL, SELECTMODE and OP_PENDING State are never set, they are equal to
 * NORMAL State with a condition.  This function returns the real State.
 */
    int
get_real_state()
{
    if (State & NORMAL)
    {
#ifdef FEAT_VISUAL
	if (VIsual_active)
	{
	    if (VIsual_select)
		return SELECTMODE;
	    return VISUAL;
	}
	else
#endif
	    if (finish_op)
		return OP_PENDING;
    }
    return State;
}

#if defined(FEAT_MBYTE) || defined(PROTO)
/*
 * Return TRUE if "p" points to just after a path separator.
 * Takes care of multi-byte characters.
 * "b" must point to the start of the file name
 */
    int
after_pathsep(b, p)
    char_u	*b;
    char_u	*p;
{
    return p > b && vim_ispathsep(p[-1])
			     && (!has_mbyte || (*mb_head_off)(b, p - 1) == 0);
}
#endif

/*
 * Return TRUE if file names "f1" and "f2" are in the same directory.
 * "f1" may be a short name, "f2" must be a full path.
 */
    int
same_directory(f1, f2)
    char_u	*f1;
    char_u	*f2;
{
    char_u	ffname[MAXPATHL];
    char_u	*t1;
    char_u	*t2;

    /* safety check */
    if (f1 == NULL || f2 == NULL)
	return FALSE;

    (void)vim_FullName(f1, ffname, MAXPATHL, FALSE);
    t1 = gettail_sep(ffname);
    t2 = gettail_sep(f2);
    return (t1 - ffname == t2 - f2
	     && pathcmp((char *)ffname, (char *)f2, (int)(t1 - ffname)) == 0);
}

#if defined(FEAT_SESSION) || defined(MSWIN) || defined(FEAT_GUI_MAC) \
	|| ((defined(FEAT_GUI_GTK)) \
			&& ( defined(FEAT_WINDOWS) || defined(FEAT_DND)) ) \
	|| defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
	|| defined(PROTO)
/*
 * Change to a file's directory.
 * Caller must call shorten_fnames()!
 * Return OK or FAIL.
 */
    int
vim_chdirfile(fname)
    char_u	*fname;
{
    char_u	dir[MAXPATHL];

    vim_strncpy(dir, fname, MAXPATHL - 1);
    *gettail_sep(dir) = NUL;
    return mch_chdir((char *)dir) == 0 ? OK : FAIL;
}
#endif

#if defined(STAT_IGNORES_SLASH) || defined(PROTO)
/*
 * Check if "name" ends in a slash and is not a directory.
 * Used for systems where stat() ignores a trailing slash on a file name.
 * The Vim code assumes a trailing slash is only ignored for a directory.
 */
    int
illegal_slash(name)
    char *name;
{
    if (name[0] == NUL)
	return FALSE;	    /* no file name is not illegal */
    if (name[strlen(name) - 1] != '/')
	return FALSE;	    /* no trailing slash */
    if (mch_isdir((char_u *)name))
	return FALSE;	    /* trailing slash for a directory */
    return TRUE;
}
#endif

#if defined(CURSOR_SHAPE) || defined(PROTO)

/*
 * Handling of cursor and mouse pointer shapes in various modes.
 */

cursorentry_T shape_table[SHAPE_IDX_COUNT] =
{
    /* The values will be filled in from the 'guicursor' and 'mouseshape'
     * defaults when Vim starts.
     * Adjust the SHAPE_IDX_ defines when making changes! */
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "n", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "v", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "i", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "r", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "c", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "ci", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "cr", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "o", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0, 700L, 400L, 250L, 0, 0, "ve", SHAPE_CURSOR+SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "e", SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "s", SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "sd", SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "vs", SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "vd", SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "m", SHAPE_MOUSE},
    {0,	0, 0,   0L,   0L,   0L, 0, 0, "ml", SHAPE_MOUSE},
    {0,	0, 0, 100L, 100L, 100L, 0, 0, "sm", SHAPE_CURSOR},
};

#ifdef FEAT_MOUSESHAPE
/*
 * Table with names for mouse shapes.  Keep in sync with all the tables for
 * mch_set_mouse_shape()!.
 */
static char * mshape_names[] =
{
    "arrow",	/* default, must be the first one */
    "blank",	/* hidden */
    "beam",
    "updown",
    "udsizing",
    "leftright",
    "lrsizing",
    "busy",
    "no",
    "crosshair",
    "hand1",
    "hand2",
    "pencil",
    "question",
    "rightup-arrow",
    "up-arrow",
    NULL
};
#endif

/*
 * Parse the 'guicursor' option ("what" is SHAPE_CURSOR) or 'mouseshape'
 * ("what" is SHAPE_MOUSE).
 * Returns error message for an illegal option, NULL otherwise.
 */
    char_u *
parse_shape_opt(what)
    int		what;
{
    char_u	*modep;
    char_u	*colonp;
    char_u	*commap;
    char_u	*slashp;
    char_u	*p, *endp;
    int		idx = 0;		/* init for GCC */
    int		all_idx;
    int		len;
    int		i;
    long	n;
    int		found_ve = FALSE;	/* found "ve" flag */
    int		round;

    /*
     * First round: check for errors; second round: do it for real.
     */
    for (round = 1; round <= 2; ++round)
    {
	/*
	 * Repeat for all comma separated parts.
	 */
#ifdef FEAT_MOUSESHAPE
	if (what == SHAPE_MOUSE)
	    modep = p_mouseshape;
	else
#endif
	    modep = p_guicursor;
	while (*modep != NUL)
	{
	    colonp = vim_strchr(modep, ':');
	    if (colonp == NULL)
		return (char_u *)N_("E545: Missing colon");
	    if (colonp == modep)
		return (char_u *)N_("E546: Illegal mode");
	    commap = vim_strchr(modep, ',');

	    /*
	     * Repeat for all mode's before the colon.
	     * For the 'a' mode, we loop to handle all the modes.
	     */
	    all_idx = -1;
	    while (modep < colonp || all_idx >= 0)
	    {
		if (all_idx < 0)
		{
		    /* Find the mode. */
		    if (modep[1] == '-' || modep[1] == ':')
			len = 1;
		    else
			len = 2;
		    if (len == 1 && TOLOWER_ASC(modep[0]) == 'a')
			all_idx = SHAPE_IDX_COUNT - 1;
		    else
		    {
			for (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)
			    if (STRNICMP(modep, shape_table[idx].name, len)
									 == 0)
				break;
			if (idx == SHAPE_IDX_COUNT
				   || (shape_table[idx].used_for & what) == 0)
			    return (char_u *)N_("E546: Illegal mode");
			if (len == 2 && modep[0] == 'v' && modep[1] == 'e')
			    found_ve = TRUE;
		    }
		    modep += len + 1;
		}

		if (all_idx >= 0)
		    idx = all_idx--;
		else if (round == 2)
		{
#ifdef FEAT_MOUSESHAPE
		    if (what == SHAPE_MOUSE)
		    {
			/* Set the default, for the missing parts */
			shape_table[idx].mshape = 0;
		    }
		    else
#endif
		    {
			/* Set the defaults, for the missing parts */
			shape_table[idx].shape = SHAPE_BLOCK;
			shape_table[idx].blinkwait = 700L;
			shape_table[idx].blinkon = 400L;
			shape_table[idx].blinkoff = 250L;
		    }
		}

		/* Parse the part after the colon */
		for (p = colonp + 1; *p && *p != ','; )
		{
#ifdef FEAT_MOUSESHAPE
		    if (what == SHAPE_MOUSE)
		    {
			for (i = 0; ; ++i)
			{
			    if (mshape_names[i] == NULL)
			    {
				if (!VIM_ISDIGIT(*p))
				    return (char_u *)N_("E547: Illegal mouseshape");
				if (round == 2)
				    shape_table[idx].mshape =
					      getdigits(&p) + MSHAPE_NUMBERED;
				else
				    (void)getdigits(&p);
				break;
			    }
			    len = (int)STRLEN(mshape_names[i]);
			    if (STRNICMP(p, mshape_names[i], len) == 0)
			    {
				if (round == 2)
				    shape_table[idx].mshape = i;
				p += len;
				break;
			    }
			}
		    }
		    else /* if (what == SHAPE_MOUSE) */
#endif
		    {
			/*
			 * First handle the ones with a number argument.
			 */
			i = *p;
			len = 0;
			if (STRNICMP(p, "ver", 3) == 0)
			    len = 3;
			else if (STRNICMP(p, "hor", 3) == 0)
			    len = 3;
			else if (STRNICMP(p, "blinkwait", 9) == 0)
			    len = 9;
			else if (STRNICMP(p, "blinkon", 7) == 0)
			    len = 7;
			else if (STRNICMP(p, "blinkoff", 8) == 0)
			    len = 8;
			if (len != 0)
			{
			    p += len;
			    if (!VIM_ISDIGIT(*p))
				return (char_u *)N_("E548: digit expected");
			    n = getdigits(&p);
			    if (len == 3)   /* "ver" or "hor" */
			    {
				if (n == 0)
				    return (char_u *)N_("E549: Illegal percentage");
				if (round == 2)
				{
				    if (TOLOWER_ASC(i) == 'v')
					shape_table[idx].shape = SHAPE_VER;
				    else
					shape_table[idx].shape = SHAPE_HOR;
				    shape_table[idx].percentage = n;
				}
			    }
			    else if (round == 2)
			    {
				if (len == 9)
				    shape_table[idx].blinkwait = n;
				else if (len == 7)
				    shape_table[idx].blinkon = n;
				else
				    shape_table[idx].blinkoff = n;
			    }
			}
			else if (STRNICMP(p, "block", 5) == 0)
			{
			    if (round == 2)
				shape_table[idx].shape = SHAPE_BLOCK;
			    p += 5;
			}
			else	/* must be a highlight group name then */
			{
			    endp = vim_strchr(p, '-');
			    if (commap == NULL)		    /* last part */
			    {
				if (endp == NULL)
				    endp = p + STRLEN(p);   /* find end of part */
			    }
			    else if (endp > commap || endp == NULL)
				endp = commap;
			    slashp = vim_strchr(p, '/');
			    if (slashp != NULL && slashp < endp)
			    {
				/* "group/langmap_group" */
				i = syn_check_group(p, (int)(slashp - p));
				p = slashp + 1;
			    }
			    if (round == 2)
			    {
				shape_table[idx].id = syn_check_group(p,
							     (int)(endp - p));
				shape_table[idx].id_lm = shape_table[idx].id;
				if (slashp != NULL && slashp < endp)
				    shape_table[idx].id = i;
			    }
			    p = endp;
			}
		    } /* if (what != SHAPE_MOUSE) */

		    if (*p == '-')
			++p;
		}
	    }
	    modep = p;
	    if (*modep == ',')
		++modep;
	}
    }

    /* If the 's' flag is not given, use the 'v' cursor for 's' */
    if (!found_ve)
    {
#ifdef FEAT_MOUSESHAPE
	if (what == SHAPE_MOUSE)
	{
	    shape_table[SHAPE_IDX_VE].mshape = shape_table[SHAPE_IDX_V].mshape;
	}
	else
#endif
	{
	    shape_table[SHAPE_IDX_VE].shape = shape_table[SHAPE_IDX_V].shape;
	    shape_table[SHAPE_IDX_VE].percentage =
					 shape_table[SHAPE_IDX_V].percentage;
	    shape_table[SHAPE_IDX_VE].blinkwait =
					  shape_table[SHAPE_IDX_V].blinkwait;
	    shape_table[SHAPE_IDX_VE].blinkon =
					    shape_table[SHAPE_IDX_V].blinkon;
	    shape_table[SHAPE_IDX_VE].blinkoff =
					   shape_table[SHAPE_IDX_V].blinkoff;
	    shape_table[SHAPE_IDX_VE].id = shape_table[SHAPE_IDX_V].id;
	    shape_table[SHAPE_IDX_VE].id_lm = shape_table[SHAPE_IDX_V].id_lm;
	}
    }

    return NULL;
}

# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \
	|| defined(FEAT_MOUSESHAPE) || defined(PROTO)
/*
 * Return the index into shape_table[] for the current mode.
 * When "mouse" is TRUE, consider indexes valid for the mouse pointer.
 */
    int
get_shape_idx(mouse)
    int	mouse;
{
#ifdef FEAT_MOUSESHAPE
    if (mouse && (State == HITRETURN || State == ASKMORE))
    {
# ifdef FEAT_GUI
	int x, y;
	gui_mch_getmouse(&x, &y);
	if (Y_2_ROW(y) == Rows - 1)
	    return SHAPE_IDX_MOREL;
# endif
	return SHAPE_IDX_MORE;
    }
    if (mouse && drag_status_line)
	return SHAPE_IDX_SDRAG;
# ifdef FEAT_VERTSPLIT
    if (mouse && drag_sep_line)
	return SHAPE_IDX_VDRAG;
# endif
#endif
    if (!mouse && State == SHOWMATCH)
	return SHAPE_IDX_SM;
#ifdef FEAT_VREPLACE
    if (State & VREPLACE_FLAG)
	return SHAPE_IDX_R;
#endif
    if (State & REPLACE_FLAG)
	return SHAPE_IDX_R;
    if (State & INSERT)
	return SHAPE_IDX_I;
    if (State & CMDLINE)
    {
	if (cmdline_at_end())
	    return SHAPE_IDX_C;
	if (cmdline_overstrike())
	    return SHAPE_IDX_CR;
	return SHAPE_IDX_CI;
    }
    if (finish_op)
	return SHAPE_IDX_O;
#ifdef FEAT_VISUAL
    if (VIsual_active)
    {
	if (*p_sel == 'e')
	    return SHAPE_IDX_VE;
	else
	    return SHAPE_IDX_V;
    }
#endif
    return SHAPE_IDX_N;
}
#endif

# if defined(FEAT_MOUSESHAPE) || defined(PROTO)
static int old_mouse_shape = 0;

/*
 * Set the mouse shape:
 * If "shape" is -1, use shape depending on the current mode,
 * depending on the current state.
 * If "shape" is -2, only update the shape when it's CLINE or STATUS (used
 * when the mouse moves off the status or command line).
 */
    void
update_mouseshape(shape_idx)
    int	shape_idx;
{
    int new_mouse_shape;

    /* Only works in GUI mode. */
    if (!gui.in_use || gui.starting)
	return;

    /* Postpone the updating when more is to come.  Speeds up executing of
     * mappings. */
    if (shape_idx == -1 && char_avail())
    {
	postponed_mouseshape = TRUE;
	return;
    }

    /* When ignoring the mouse don't change shape on the statusline. */
    if (*p_mouse == NUL
	    && (shape_idx == SHAPE_IDX_CLINE
		|| shape_idx == SHAPE_IDX_STATUS
		|| shape_idx == SHAPE_IDX_VSEP))
	shape_idx = -2;

    if (shape_idx == -2
	    && old_mouse_shape != shape_table[SHAPE_IDX_CLINE].mshape
	    && old_mouse_shape != shape_table[SHAPE_IDX_STATUS].mshape
	    && old_mouse_shape != shape_table[SHAPE_IDX_VSEP].mshape)
	return;
    if (shape_idx < 0)
	new_mouse_shape = shape_table[get_shape_idx(TRUE)].mshape;
    else
	new_mouse_shape = shape_table[shape_idx].mshape;
    if (new_mouse_shape != old_mouse_shape)
    {
	mch_set_mouse_shape(new_mouse_shape);
	old_mouse_shape = new_mouse_shape;
    }
    postponed_mouseshape = FALSE;
}
# endif

#endif /* CURSOR_SHAPE */


#ifdef FEAT_CRYPT
/*
 * Optional encryption support.
 * Mohsin Ahmed, mosh@sasi.com, 98-09-24
 * Based on zip/crypt sources.
 *
 * NOTE FOR USA: Since 2000 exporting this code from the USA is allowed to
 * most countries.  There are a few exceptions, but that still should not be a
 * problem since this code was originally created in Europe and India.
 *
 * Blowfish addition originally made by Mohsin Ahmed,
 * http://www.cs.albany.edu/~mosh 2010-03-14
 * Based on blowfish by Bruce Schneier (http://www.schneier.com/blowfish.html)
 * and sha256 by Christophe Devine.
 */

/* from zip.h */

typedef unsigned short ush;	/* unsigned 16-bit value */
typedef unsigned long  ulg;	/* unsigned 32-bit value */

static void make_crc_tab __ARGS((void));

static ulg crc_32_tab[256];

/*
 * Fill the CRC table.
 */
    static void
make_crc_tab()
{
    ulg		s,t,v;
    static int	done = FALSE;

    if (done)
	return;
    for (t = 0; t < 256; t++)
    {
	v = t;
	for (s = 0; s < 8; s++)
	    v = (v >> 1) ^ ((v & 1) * (ulg)0xedb88320L);
	crc_32_tab[t] = v;
    }
    done = TRUE;
}

#define CRC32(c, b) (crc_32_tab[((int)(c) ^ (b)) & 0xff] ^ ((c) >> 8))

static ulg keys[3]; /* keys defining the pseudo-random sequence */

/*
 * Return the next byte in the pseudo-random sequence.
 */
#define DECRYPT_BYTE_ZIP(t) { \
    ush temp; \
 \
    temp = (ush)keys[2] | 2; \
    t = (int)(((unsigned)(temp * (temp ^ 1U)) >> 8) & 0xff); \
}

/*
 * Update the encryption keys with the next byte of plain text.
 */
#define UPDATE_KEYS_ZIP(c) { \
    keys[0] = CRC32(keys[0], (c)); \
    keys[1] += keys[0] & 0xff; \
    keys[1] = keys[1] * 134775813L + 1; \
    keys[2] = CRC32(keys[2], (int)(keys[1] >> 24)); \
}

static int crypt_busy = 0;
static ulg saved_keys[3];
static int saved_crypt_method;

/*
 * Return int value for crypt method string:
 * 0 for "zip", the old method.  Also for any non-valid value.
 * 1 for "blowfish".
 */
    int
crypt_method_from_string(s)
    char_u  *s;
{
    return *s == 'b' ? 1 : 0;
}

/*
 * Get the crypt method for buffer "buf" as a number.
 */
    int
get_crypt_method(buf)
    buf_T *buf;
{
    return crypt_method_from_string(*buf->b_p_cm == NUL ? p_cm : buf->b_p_cm);
}

/*
 * Set the crypt method for buffer "buf" to "method" using the int value as
 * returned by crypt_method_from_string().
 */
    void
set_crypt_method(buf, method)
    buf_T   *buf;
    int	    method;
{
    free_string_option(buf->b_p_cm);
    buf->b_p_cm = vim_strsave((char_u *)(method == 0 ? "zip" : "blowfish"));
}

/*
 * Prepare for initializing encryption.  If already doing encryption then save
 * the state.
 * Must always be called symmetrically with crypt_pop_state().
 */
    void
crypt_push_state()
{
    if (crypt_busy == 1)
    {
	/* save the state */
	if (use_crypt_method == 0)
	{
	    saved_keys[0] = keys[0];
	    saved_keys[1] = keys[1];
	    saved_keys[2] = keys[2];
	}
	else
	    bf_crypt_save();
	saved_crypt_method = use_crypt_method;
    }
    else if (crypt_busy > 1)
	EMSG2(_(e_intern2), "crypt_push_state()");
    ++crypt_busy;
}

/*
 * End encryption.  If doing encryption before crypt_push_state() then restore
 * the saved state.
 * Must always be called symmetrically with crypt_push_state().
 */
    void
crypt_pop_state()
{
    --crypt_busy;
    if (crypt_busy == 1)
    {
	use_crypt_method = saved_crypt_method;
	if (use_crypt_method == 0)
	{
	    keys[0] = saved_keys[0];
	    keys[1] = saved_keys[1];
	    keys[2] = saved_keys[2];
	}
	else
	    bf_crypt_restore();
    }
}

/*
 * Encrypt "from[len]" into "to[len]".
 * "from" and "to" can be equal to encrypt in place.
 */
    void
crypt_encode(from, len, to)
    char_u	*from;
    size_t	len;
    char_u	*to;
{
    size_t	i;
    int		ztemp, t;

    if (use_crypt_method == 0)
	for (i = 0; i < len; ++i)
	{
	    ztemp = from[i];
	    DECRYPT_BYTE_ZIP(t);
	    UPDATE_KEYS_ZIP(ztemp);
	    to[i] = t ^ ztemp;
	}
    else
	bf_crypt_encode(from, len, to);
}

/*
 * Decrypt "ptr[len]" in place.
 */
    void
crypt_decode(ptr, len)
    char_u	*ptr;
    long	len;
{
    char_u *p;

    if (use_crypt_method == 0)
	for (p = ptr; p < ptr + len; ++p)
	{
	    ush temp;

	    temp = (ush)keys[2] | 2;
	    temp = (int)(((unsigned)(temp * (temp ^ 1U)) >> 8) & 0xff);
	    UPDATE_KEYS_ZIP(*p ^= temp);
	}
    else
	bf_crypt_decode(ptr, len);
}

/*
 * Initialize the encryption keys and the random header according to
 * the given password.
 * If "passwd" is NULL or empty, don't do anything.
 */
    void
crypt_init_keys(passwd)
    char_u *passwd;		/* password string with which to modify keys */
{
    if (passwd != NULL && *passwd != NUL)
    {
	if (use_crypt_method == 0)
	{
	    char_u *p;

	    make_crc_tab();
	    keys[0] = 305419896L;
	    keys[1] = 591751049L;
	    keys[2] = 878082192L;
	    for (p = passwd; *p!= NUL; ++p)
	    {
		UPDATE_KEYS_ZIP((int)*p);
	    }
	}
	else
	    bf_crypt_init_keys(passwd);
    }
}

/*
 * Free an allocated crypt key.  Clear the text to make sure it doesn't stay
 * in memory anywhere.
 */
    void
free_crypt_key(key)
    char_u *key;
{
    char_u *p;

    if (key != NULL)
    {
	for (p = key; *p != NUL; ++p)
	    *p = 0;
	vim_free(key);
    }
}

/*
 * Ask the user for a crypt key.
 * When "store" is TRUE, the new key is stored in the 'key' option, and the
 * 'key' option value is returned: Don't free it.
 * When "store" is FALSE, the typed key is returned in allocated memory.
 * Returns NULL on failure.
 */
    char_u *
get_crypt_key(store, twice)
    int		store;
    int		twice;	    /* Ask for the key twice. */
{
    char_u	*p1, *p2 = NULL;
    int		round;

    for (round = 0; ; ++round)
    {
	cmdline_star = TRUE;
	cmdline_row = msg_row;
	p1 = getcmdline_prompt(NUL, round == 0
		? (char_u *)_("Enter encryption key: ")
		: (char_u *)_("Enter same key again: "), 0, EXPAND_NOTHING,
		NULL);
	cmdline_star = FALSE;

	if (p1 == NULL)
	    break;

	if (round == twice)
	{
	    if (p2 != NULL && STRCMP(p1, p2) != 0)
	    {
		MSG(_("Keys don't match!"));
		free_crypt_key(p1);
		free_crypt_key(p2);
		p2 = NULL;
		round = -1;		/* do it again */
		continue;
	    }

	    if (store)
	    {
		set_option_value((char_u *)"key", 0L, p1, OPT_LOCAL);
		free_crypt_key(p1);
		p1 = curbuf->b_p_key;
	    }
	    break;
	}
	p2 = p1;
    }

    /* since the user typed this, no need to wait for return */
    if (msg_didout)
	msg_putchar('\n');
    need_wait_return = FALSE;
    msg_didout = FALSE;

    free_crypt_key(p2);
    return p1;
}

#endif /* FEAT_CRYPT */

/* TODO: make some #ifdef for this */
/*--------[ file searching ]-------------------------------------------------*/
/*
 * File searching functions for 'path', 'tags' and 'cdpath' options.
 * External visible functions:
 * vim_findfile_init()		creates/initialises the search context
 * vim_findfile_free_visited()	free list of visited files/dirs of search
 *				context
 * vim_findfile()		find a file in the search context
 * vim_findfile_cleanup()	cleanup/free search context created by
 *				vim_findfile_init()
 *
 * All static functions and variables start with 'ff_'
 *
 * In general it works like this:
 * First you create yourself a search context by calling vim_findfile_init().
 * It is possible to give a search context from a previous call to
 * vim_findfile_init(), so it can be reused. After this you call vim_findfile()
 * until you are satisfied with the result or it returns NULL. On every call it
 * returns the next file which matches the conditions given to
 * vim_findfile_init(). If it doesn't find a next file it returns NULL.
 *
 * It is possible to call vim_findfile_init() again to reinitialise your search
 * with some new parameters. Don't forget to pass your old search context to
 * it, so it can reuse it and especially reuse the list of already visited
 * directories. If you want to delete the list of already visited directories
 * simply call vim_findfile_free_visited().
 *
 * When you are done call vim_findfile_cleanup() to free the search context.
 *
 * The function vim_findfile_init() has a long comment, which describes the
 * needed parameters.
 *
 *
 *
 * ATTENTION:
 * ==========
 *	Also we use an allocated search context here, this functions are NOT
 *	thread-safe!!!!!
 *
 *	To minimize parameter passing (or because I'm to lazy), only the
 *	external visible functions get a search context as a parameter. This is
 *	then assigned to a static global, which is used throughout the local
 *	functions.
 */

/*
 * type for the directory search stack
 */
typedef struct ff_stack
{
    struct ff_stack	*ffs_prev;

    /* the fix part (no wildcards) and the part containing the wildcards
     * of the search path
     */
    char_u		*ffs_fix_path;
#ifdef FEAT_PATH_EXTRA
    char_u		*ffs_wc_path;
#endif

    /* files/dirs found in the above directory, matched by the first wildcard
     * of wc_part
     */
    char_u		**ffs_filearray;
    int			ffs_filearray_size;
    char_u		ffs_filearray_cur;   /* needed for partly handled dirs */

    /* to store status of partly handled directories
     * 0: we work on this directory for the first time
     * 1: this directory was partly searched in an earlier step
     */
    int			ffs_stage;

    /* How deep are we in the directory tree?
     * Counts backward from value of level parameter to vim_findfile_init
     */
    int			ffs_level;

    /* Did we already expand '**' to an empty string? */
    int			ffs_star_star_empty;
} ff_stack_T;

/*
 * type for already visited directories or files.
 */
typedef struct ff_visited
{
    struct ff_visited	*ffv_next;

#ifdef FEAT_PATH_EXTRA
    /* Visited directories are different if the wildcard string are
     * different. So we have to save it.
     */
    char_u		*ffv_wc_path;
#endif
    /* for unix use inode etc for comparison (needed because of links), else
     * use filename.
     */
#ifdef UNIX
    int			ffv_dev_valid;	/* ffv_dev and ffv_ino were set */
    dev_t		ffv_dev;	/* device number */
    ino_t		ffv_ino;	/* inode number */
#endif
    /* The memory for this struct is allocated according to the length of
     * ffv_fname.
     */
    char_u		ffv_fname[1];	/* actually longer */
} ff_visited_T;

/*
 * We might have to manage several visited lists during a search.
 * This is especially needed for the tags option. If tags is set to:
 *      "./++/tags,./++/TAGS,++/tags"  (replace + with *)
 * So we have to do 3 searches:
 *   1) search from the current files directory downward for the file "tags"
 *   2) search from the current files directory downward for the file "TAGS"
 *   3) search from Vims current directory downwards for the file "tags"
 * As you can see, the first and the third search are for the same file, so for
 * the third search we can use the visited list of the first search. For the
 * second search we must start from a empty visited list.
 * The struct ff_visited_list_hdr is used to manage a linked list of already
 * visited lists.
 */
typedef struct ff_visited_list_hdr
{
    struct ff_visited_list_hdr	*ffvl_next;

    /* the filename the attached visited list is for */
    char_u			*ffvl_filename;

    ff_visited_T		*ffvl_visited_list;

} ff_visited_list_hdr_T;


/*
 * '**' can be expanded to several directory levels.
 * Set the default maximum depth.
 */
#define FF_MAX_STAR_STAR_EXPAND ((char_u)30)

/*
 * The search context:
 *   ffsc_stack_ptr:	the stack for the dirs to search
 *   ffsc_visited_list: the currently active visited list
 *   ffsc_dir_visited_list: the currently active visited list for search dirs
 *   ffsc_visited_lists_list: the list of all visited lists
 *   ffsc_dir_visited_lists_list: the list of all visited lists for search dirs
 *   ffsc_file_to_search:     the file to search for
 *   ffsc_start_dir:	the starting directory, if search path was relative
 *   ffsc_fix_path:	the fix part of the given path (without wildcards)
 *			Needed for upward search.
 *   ffsc_wc_path:	the part of the given path containing wildcards
 *   ffsc_level:	how many levels of dirs to search downwards
 *   ffsc_stopdirs_v:	array of stop directories for upward search
 *   ffsc_find_what:	FINDFILE_BOTH, FINDFILE_DIR or FINDFILE_FILE
 *   ffsc_tagfile:	searching for tags file, don't use 'suffixesadd'
 */
typedef struct ff_search_ctx_T
{
     ff_stack_T			*ffsc_stack_ptr;
     ff_visited_list_hdr_T	*ffsc_visited_list;
     ff_visited_list_hdr_T	*ffsc_dir_visited_list;
     ff_visited_list_hdr_T	*ffsc_visited_lists_list;
     ff_visited_list_hdr_T	*ffsc_dir_visited_lists_list;
     char_u			*ffsc_file_to_search;
     char_u			*ffsc_start_dir;
     char_u			*ffsc_fix_path;
#ifdef FEAT_PATH_EXTRA
     char_u			*ffsc_wc_path;
     int			ffsc_level;
     char_u			**ffsc_stopdirs_v;
#endif
     int			ffsc_find_what;
     int			ffsc_tagfile;
} ff_search_ctx_T;

/* locally needed functions */
#ifdef FEAT_PATH_EXTRA
static int ff_check_visited __ARGS((ff_visited_T **, char_u *, char_u *));
#else
static int ff_check_visited __ARGS((ff_visited_T **, char_u *));
#endif
static void vim_findfile_free_visited_list __ARGS((ff_visited_list_hdr_T **list_headp));
static void ff_free_visited_list __ARGS((ff_visited_T *vl));
static ff_visited_list_hdr_T* ff_get_visited_list __ARGS((char_u *, ff_visited_list_hdr_T **list_headp));
#ifdef FEAT_PATH_EXTRA
static int ff_wc_equal __ARGS((char_u *s1, char_u *s2));
#endif

static void ff_push __ARGS((ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr));
static ff_stack_T *ff_pop __ARGS((ff_search_ctx_T *search_ctx));
static void ff_clear __ARGS((ff_search_ctx_T *search_ctx));
static void ff_free_stack_element __ARGS((ff_stack_T *stack_ptr));
#ifdef FEAT_PATH_EXTRA
static ff_stack_T *ff_create_stack_element __ARGS((char_u *, char_u *, int, int));
#else
static ff_stack_T *ff_create_stack_element __ARGS((char_u *, int, int));
#endif
#ifdef FEAT_PATH_EXTRA
static int ff_path_in_stoplist __ARGS((char_u *, int, char_u **));
#endif

static char_u e_pathtoolong[] = N_("E854: path too long for completion");

#if 0
/*
 * if someone likes findfirst/findnext, here are the functions
 * NOT TESTED!!
 */

static void *ff_fn_search_context = NULL;

    char_u *
vim_findfirst(path, filename, level)
    char_u	*path;
    char_u	*filename;
    int		level;
{
    ff_fn_search_context =
	vim_findfile_init(path, filename, NULL, level, TRUE, FALSE,
		ff_fn_search_context, rel_fname);
    if (NULL == ff_fn_search_context)
	return NULL;
    else
	return vim_findnext()
}

    char_u *
vim_findnext()
{
    char_u *ret = vim_findfile(ff_fn_search_context);

    if (NULL == ret)
    {
	vim_findfile_cleanup(ff_fn_search_context);
	ff_fn_search_context = NULL;
    }
    return ret;
}
#endif

/*
 * Initialization routine for vim_findfile().
 *
 * Returns the newly allocated search context or NULL if an error occurred.
 *
 * Don't forget to clean up by calling vim_findfile_cleanup() if you are done
 * with the search context.
 *
 * Find the file 'filename' in the directory 'path'.
 * The parameter 'path' may contain wildcards. If so only search 'level'
 * directories deep. The parameter 'level' is the absolute maximum and is
 * not related to restricts given to the '**' wildcard. If 'level' is 100
 * and you use '**200' vim_findfile() will stop after 100 levels.
 *
 * 'filename' cannot contain wildcards!  It is used as-is, no backslashes to
 * escape special characters.
 *
 * If 'stopdirs' is not NULL and nothing is found downward, the search is
 * restarted on the next higher directory level. This is repeated until the
 * start-directory of a search is contained in 'stopdirs'. 'stopdirs' has the
 * format ";*<dirname>*\(;<dirname>\)*;\=$".
 *
 * If the 'path' is relative, the starting dir for the search is either VIM's
 * current dir or if the path starts with "./" the current files dir.
 * If the 'path' is absolute, the starting dir is that part of the path before
 * the first wildcard.
 *
 * Upward search is only done on the starting dir.
 *
 * If 'free_visited' is TRUE the list of already visited files/directories is
 * cleared. Set this to FALSE if you just want to search from another
 * directory, but want to be sure that no directory from a previous search is
 * searched again. This is useful if you search for a file at different places.
 * The list of visited files/dirs can also be cleared with the function
 * vim_findfile_free_visited().
 *
 * Set the parameter 'find_what' to FINDFILE_DIR if you want to search for
 * directories only, FINDFILE_FILE for files only, FINDFILE_BOTH for both.
 *
 * A search context returned by a previous call to vim_findfile_init() can be
 * passed in the parameter "search_ctx_arg".  This context is reused and
 * reinitialized with the new parameters.  The list of already visited
 * directories from this context is only deleted if the parameter
 * "free_visited" is true.  Be aware that the passed "search_ctx_arg" is freed
 * if the reinitialization fails.
 *
 * If you don't have a search context from a previous call "search_ctx_arg"
 * must be NULL.
 *
 * This function silently ignores a few errors, vim_findfile() will have
 * limited functionality then.
 */
    void *
vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
					   search_ctx_arg, tagfile, rel_fname)
    char_u	*path;
    char_u	*filename;
    char_u	*stopdirs UNUSED;
    int		level;
    int		free_visited;
    int		find_what;
    void	*search_ctx_arg;
    int		tagfile;	/* expanding names of tags files */
    char_u	*rel_fname;	/* file name to use for "." */
{
#ifdef FEAT_PATH_EXTRA
    char_u		*wc_part;
#endif
    ff_stack_T		*sptr;
    ff_search_ctx_T	*search_ctx;

    /* If a search context is given by the caller, reuse it, else allocate a
     * new one.
     */
    if (search_ctx_arg != NULL)
	search_ctx = search_ctx_arg;
    else
    {
	search_ctx = (ff_search_ctx_T*)alloc((unsigned)sizeof(ff_search_ctx_T));
	if (search_ctx == NULL)
	    goto error_return;
	vim_memset(search_ctx, 0, sizeof(ff_search_ctx_T));
    }
    search_ctx->ffsc_find_what = find_what;
    search_ctx->ffsc_tagfile = tagfile;

    /* clear the search context, but NOT the visited lists */
    ff_clear(search_ctx);

    /* clear visited list if wanted */
    if (free_visited == TRUE)
	vim_findfile_free_visited(search_ctx);
    else
    {
	/* Reuse old visited lists. Get the visited list for the given
	 * filename. If no list for the current filename exists, creates a new
	 * one. */
	search_ctx->ffsc_visited_list = ff_get_visited_list(filename,
					&search_ctx->ffsc_visited_lists_list);
	if (search_ctx->ffsc_visited_list == NULL)
	    goto error_return;
	search_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,
				    &search_ctx->ffsc_dir_visited_lists_list);
	if (search_ctx->ffsc_dir_visited_list == NULL)
	    goto error_return;
    }

    if (ff_expand_buffer == NULL)
    {
	ff_expand_buffer = (char_u*)alloc(MAXPATHL);
	if (ff_expand_buffer == NULL)
	    goto error_return;
    }

    /* Store information on starting dir now if path is relative.
     * If path is absolute, we do that later.  */
    if (path[0] == '.'
	    && (vim_ispathsep(path[1]) || path[1] == NUL)
	    && (!tagfile || vim_strchr(p_cpo, CPO_DOTTAG) == NULL)
	    && rel_fname != NULL)
    {
	int	len = (int)(gettail(rel_fname) - rel_fname);

	if (!vim_isAbsName(rel_fname) && len + 1 < MAXPATHL)
	{
	    /* Make the start dir an absolute path name. */
	    vim_strncpy(ff_expand_buffer, rel_fname, len);
	    search_ctx->ffsc_start_dir = FullName_save(ff_expand_buffer, FALSE);
	}
	else
	    search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);
	if (search_ctx->ffsc_start_dir == NULL)
	    goto error_return;
	if (*++path != NUL)
	    ++path;
    }
    else if (*path == NUL || !vim_isAbsName(path))
    {
#ifdef BACKSLASH_IN_FILENAME
	/* "c:dir" needs "c:" to be expanded, otherwise use current dir */
	if (*path != NUL && path[1] == ':')
	{
	    char_u  drive[3];

	    drive[0] = path[0];
	    drive[1] = ':';
	    drive[2] = NUL;
	    if (vim_FullName(drive, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)
		goto error_return;
	    path += 2;
	}
	else
#endif
	if (mch_dirname(ff_expand_buffer, MAXPATHL) == FAIL)
	    goto error_return;

	search_ctx->ffsc_start_dir = vim_strsave(ff_expand_buffer);
	if (search_ctx->ffsc_start_dir == NULL)
	    goto error_return;

#ifdef BACKSLASH_IN_FILENAME
	/* A path that starts with "/dir" is relative to the drive, not to the
	 * directory (but not for "//machine/dir").  Only use the drive name. */
	if ((*path == '/' || *path == '\\')
		&& path[1] != path[0]
		&& search_ctx->ffsc_start_dir[1] == ':')
	    search_ctx->ffsc_start_dir[2] = NUL;
#endif
    }

#ifdef FEAT_PATH_EXTRA
    /*
     * If stopdirs are given, split them into an array of pointers.
     * If this fails (mem allocation), there is no upward search at all or a
     * stop directory is not recognized -> continue silently.
     * If stopdirs just contains a ";" or is empty,
     * search_ctx->ffsc_stopdirs_v will only contain a  NULL pointer. This
     * is handled as unlimited upward search.  See function
     * ff_path_in_stoplist() for details.
     */
    if (stopdirs != NULL)
    {
	char_u	*walker = stopdirs;
	int	dircount;

	while (*walker == ';')
	    walker++;

	dircount = 1;
	search_ctx->ffsc_stopdirs_v =
				 (char_u **)alloc((unsigned)sizeof(char_u *));

	if (search_ctx->ffsc_stopdirs_v != NULL)
	{
	    do
	    {
		char_u	*helper;
		void	*ptr;

		helper = walker;
		ptr = vim_realloc(search_ctx->ffsc_stopdirs_v,
					   (dircount + 1) * sizeof(char_u *));
		if (ptr)
		    search_ctx->ffsc_stopdirs_v = ptr;
		else
		    /* ignore, keep what we have and continue */
		    break;
		walker = vim_strchr(walker, ';');
		if (walker)
		{
		    search_ctx->ffsc_stopdirs_v[dircount-1] =
				 vim_strnsave(helper, (int)(walker - helper));
		    walker++;
		}
		else
		    /* this might be "", which means ascent till top
		     * of directory tree.
		     */
		    search_ctx->ffsc_stopdirs_v[dircount-1] =
							  vim_strsave(helper);

		dircount++;

	    } while (walker != NULL);
	    search_ctx->ffsc_stopdirs_v[dircount-1] = NULL;
	}
    }
#endif

#ifdef FEAT_PATH_EXTRA
    search_ctx->ffsc_level = level;

    /* split into:
     *  -fix path
     *  -wildcard_stuff (might be NULL)
     */
    wc_part = vim_strchr(path, '*');
    if (wc_part != NULL)
    {
	int	llevel;
	int	len;
	char	*errpt;

	/* save the fix part of the path */
	search_ctx->ffsc_fix_path = vim_strnsave(path, (int)(wc_part - path));

	/*
	 * copy wc_path and add restricts to the '**' wildcard.
	 * The octet after a '**' is used as a (binary) counter.
	 * So '**3' is transposed to '**^C' ('^C' is ASCII value 3)
	 * or '**76' is transposed to '**N'( 'N' is ASCII value 76).
	 * For EBCDIC you get different character values.
	 * If no restrict is given after '**' the default is used.
	 * Due to this technique the path looks awful if you print it as a
	 * string.
	 */
	len = 0;
	while (*wc_part != NUL)
	{
	    if (len + 5 >= MAXPATHL)
	    {
		EMSG(_(e_pathtoolong));
		break;
	    }
	    if (STRNCMP(wc_part, "**", 2) == 0)
	    {
		ff_expand_buffer[len++] = *wc_part++;
		ff_expand_buffer[len++] = *wc_part++;

		llevel = strtol((char *)wc_part, &errpt, 10);
		if ((char_u *)errpt != wc_part && llevel > 0 && llevel < 255)
		    ff_expand_buffer[len++] = llevel;
		else if ((char_u *)errpt != wc_part && llevel == 0)
		    /* restrict is 0 -> remove already added '**' */
		    len -= 2;
		else
		    ff_expand_buffer[len++] = FF_MAX_STAR_STAR_EXPAND;
		wc_part = (char_u *)errpt;
		if (*wc_part != NUL && !vim_ispathsep(*wc_part))
		{
		    EMSG2(_("E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'."), PATHSEPSTR);
		    goto error_return;
		}
	    }
	    else
		ff_expand_buffer[len++] = *wc_part++;
	}
	ff_expand_buffer[len] = NUL;
	search_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);

	if (search_ctx->ffsc_wc_path == NULL)
	    goto error_return;
    }
    else
#endif
	search_ctx->ffsc_fix_path = vim_strsave(path);

    if (search_ctx->ffsc_start_dir == NULL)
    {
	/* store the fix part as startdir.
	 * This is needed if the parameter path is fully qualified.
	 */
	search_ctx->ffsc_start_dir = vim_strsave(search_ctx->ffsc_fix_path);
	if (search_ctx->ffsc_start_dir == NULL)
	    goto error_return;
	search_ctx->ffsc_fix_path[0] = NUL;
    }

    /* create an absolute path */
    if (STRLEN(search_ctx->ffsc_start_dir)
			  + STRLEN(search_ctx->ffsc_fix_path) + 3 >= MAXPATHL)
    {
	EMSG(_(e_pathtoolong));
	goto error_return;
    }
    STRCPY(ff_expand_buffer, search_ctx->ffsc_start_dir);
    add_pathsep(ff_expand_buffer);
    {
	int    eb_len = (int)STRLEN(ff_expand_buffer);
	char_u *buf = alloc(eb_len
				+ (int)STRLEN(search_ctx->ffsc_fix_path) + 1);

	STRCPY(buf, ff_expand_buffer);
	STRCPY(buf + eb_len, search_ctx->ffsc_fix_path);
	if (mch_isdir(buf))
	{
	    STRCAT(ff_expand_buffer, search_ctx->ffsc_fix_path);
	    add_pathsep(ff_expand_buffer);
	}
#ifdef FEAT_PATH_EXTRA
	else
	{
	    char_u *p =  gettail(search_ctx->ffsc_fix_path);
	    char_u *wc_path = NUL;
	    char_u *temp = NUL;
	    int    len = 0;

	    if (p > search_ctx->ffsc_fix_path)
	    {
		len = (int)(p - search_ctx->ffsc_fix_path) - 1;
		STRNCAT(ff_expand_buffer, search_ctx->ffsc_fix_path, len);
		add_pathsep(ff_expand_buffer);
	    }
	    else
		len = (int)STRLEN(search_ctx->ffsc_fix_path);

	    if (search_ctx->ffsc_wc_path != NULL)
	    {
		wc_path = vim_strsave(search_ctx->ffsc_wc_path);
		temp = alloc((int)(STRLEN(search_ctx->ffsc_wc_path)
				 + STRLEN(search_ctx->ffsc_fix_path + len)
				 + 1));
	    }

	    if (temp == NULL || wc_path == NULL)
	    {
		vim_free(buf);
		vim_free(temp);
		vim_free(wc_path);
		goto error_return;
	    }

	    STRCPY(temp, search_ctx->ffsc_fix_path + len);
	    STRCAT(temp, search_ctx->ffsc_wc_path);
	    vim_free(search_ctx->ffsc_wc_path);
	    vim_free(wc_path);
	    search_ctx->ffsc_wc_path = temp;
	}
#endif
	vim_free(buf);
    }

    sptr = ff_create_stack_element(ff_expand_buffer,
#ifdef FEAT_PATH_EXTRA
	    search_ctx->ffsc_wc_path,
#endif
	    level, 0);

    if (sptr == NULL)
	goto error_return;

    ff_push(search_ctx, sptr);

    search_ctx->ffsc_file_to_search = vim_strsave(filename);
    if (search_ctx->ffsc_file_to_search == NULL)
	goto error_return;

    return search_ctx;

error_return:
    /*
     * We clear the search context now!
     * Even when the caller gave us a (perhaps valid) context we free it here,
     * as we might have already destroyed it.
     */
    vim_findfile_cleanup(search_ctx);
    return NULL;
}

#if defined(FEAT_PATH_EXTRA) || defined(PROTO)
/*
 * Get the stopdir string.  Check that ';' is not escaped.
 */
    char_u *
vim_findfile_stopdir(buf)
    char_u	*buf;
{
    char_u	*r_ptr = buf;

    while (*r_ptr != NUL && *r_ptr != ';')
    {
	if (r_ptr[0] == '\\' && r_ptr[1] == ';')
	{
	    /* Overwrite the escape char,
	     * use STRLEN(r_ptr) to move the trailing '\0'. */
	    STRMOVE(r_ptr, r_ptr + 1);
	    r_ptr++;
	}
	r_ptr++;
    }
    if (*r_ptr == ';')
    {
	*r_ptr = 0;
	r_ptr++;
    }
    else if (*r_ptr == NUL)
	r_ptr = NULL;
    return r_ptr;
}
#endif

/*
 * Clean up the given search context. Can handle a NULL pointer.
 */
    void
vim_findfile_cleanup(ctx)
    void	*ctx;
{
    if (ctx == NULL)
	return;

    vim_findfile_free_visited(ctx);
    ff_clear(ctx);
    vim_free(ctx);
}

/*
 * Find a file in a search context.
 * The search context was created with vim_findfile_init() above.
 * Return a pointer to an allocated file name or NULL if nothing found.
 * To get all matching files call this function until you get NULL.
 *
 * If the passed search_context is NULL, NULL is returned.
 *
 * The search algorithm is depth first. To change this replace the
 * stack with a list (don't forget to leave partly searched directories on the
 * top of the list).
 */
    char_u *
vim_findfile(search_ctx_arg)
    void	*search_ctx_arg;
{
    char_u	*file_path;
#ifdef FEAT_PATH_EXTRA
    char_u	*rest_of_wildcards;
    char_u	*path_end = NULL;
#endif
    ff_stack_T	*stackp;
#if defined(FEAT_SEARCHPATH) || defined(FEAT_PATH_EXTRA)
    int		len;
#endif
    int		i;
    char_u	*p;
#ifdef FEAT_SEARCHPATH
    char_u	*suf;
#endif
    ff_search_ctx_T *search_ctx;

    if (search_ctx_arg == NULL)
	return NULL;

    search_ctx = (ff_search_ctx_T *)search_ctx_arg;

    /*
     * filepath is used as buffer for various actions and as the storage to
     * return a found filename.
     */
    if ((file_path = alloc((int)MAXPATHL)) == NULL)
	return NULL;

#ifdef FEAT_PATH_EXTRA
    /* store the end of the start dir -- needed for upward search */
    if (search_ctx->ffsc_start_dir != NULL)
	path_end = &search_ctx->ffsc_start_dir[
					  STRLEN(search_ctx->ffsc_start_dir)];
#endif

#ifdef FEAT_PATH_EXTRA
    /* upward search loop */
    for (;;)
    {
#endif
	/* downward search loop */
	for (;;)
	{
	    /* check if user user wants to stop the search*/
	    ui_breakcheck();
	    if (got_int)
		break;

	    /* get directory to work on from stack */
	    stackp = ff_pop(search_ctx);
	    if (stackp == NULL)
		break;

	    /*
	     * TODO: decide if we leave this test in
	     *
	     * GOOD: don't search a directory(-tree) twice.
	     * BAD:  - check linked list for every new directory entered.
	     *       - check for double files also done below
	     *
	     * Here we check if we already searched this directory.
	     * We already searched a directory if:
	     * 1) The directory is the same.
	     * 2) We would use the same wildcard string.
	     *
	     * Good if you have links on same directory via several ways
	     *  or you have selfreferences in directories (e.g. SuSE Linux 6.3:
	     *  /etc/rc.d/init.d is linked to /etc/rc.d -> endless loop)
	     *
	     * This check is only needed for directories we work on for the
	     * first time (hence stackp->ff_filearray == NULL)
	     */
	    if (stackp->ffs_filearray == NULL
		    && ff_check_visited(&search_ctx->ffsc_dir_visited_list
							  ->ffvl_visited_list,
			stackp->ffs_fix_path
#ifdef FEAT_PATH_EXTRA
			, stackp->ffs_wc_path
#endif
			) == FAIL)
	    {
#ifdef FF_VERBOSE
		if (p_verbose >= 5)
		{
		    verbose_enter_scroll();
		    smsg((char_u *)"Already Searched: %s (%s)",
				   stackp->ffs_fix_path, stackp->ffs_wc_path);
		    /* don't overwrite this either */
		    msg_puts((char_u *)"\n");
		    verbose_leave_scroll();
		}
#endif
		ff_free_stack_element(stackp);
		continue;
	    }
#ifdef FF_VERBOSE
	    else if (p_verbose >= 5)
	    {
		verbose_enter_scroll();
		smsg((char_u *)"Searching: %s (%s)",
				   stackp->ffs_fix_path, stackp->ffs_wc_path);
		/* don't overwrite this either */
		msg_puts((char_u *)"\n");
		verbose_leave_scroll();
	    }
#endif

	    /* check depth */
	    if (stackp->ffs_level <= 0)
	    {
		ff_free_stack_element(stackp);
		continue;
	    }

	    file_path[0] = NUL;

	    /*
	     * If no filearray till now expand wildcards
	     * The function expand_wildcards() can handle an array of paths
	     * and all possible expands are returned in one array. We use this
	     * to handle the expansion of '**' into an empty string.
	     */
	    if (stackp->ffs_filearray == NULL)
	    {
		char_u *dirptrs[2];

		/* we use filepath to build the path expand_wildcards() should
		 * expand.
		 */
		dirptrs[0] = file_path;
		dirptrs[1] = NULL;

		/* if we have a start dir copy it in */
		if (!vim_isAbsName(stackp->ffs_fix_path)
						&& search_ctx->ffsc_start_dir)
		{
		    STRCPY(file_path, search_ctx->ffsc_start_dir);
		    add_pathsep(file_path);
		}

		/* append the fix part of the search path */
		STRCAT(file_path, stackp->ffs_fix_path);
		add_pathsep(file_path);

#ifdef FEAT_PATH_EXTRA
		rest_of_wildcards = stackp->ffs_wc_path;
		if (*rest_of_wildcards != NUL)
		{
		    len = (int)STRLEN(file_path);
		    if (STRNCMP(rest_of_wildcards, "**", 2) == 0)
		    {
			/* pointer to the restrict byte
			 * The restrict byte is not a character!
			 */
			p = rest_of_wildcards + 2;

			if (*p > 0)
			{
			    (*p)--;
			    file_path[len++] = '*';
			}

			if (*p == 0)
			{
			    /* remove '**<numb> from wildcards */
			    STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);
			}
			else
			    rest_of_wildcards += 3;

			if (stackp->ffs_star_star_empty == 0)
			{
			    /* if not done before, expand '**' to empty */
			    stackp->ffs_star_star_empty = 1;
			    dirptrs[1] = stackp->ffs_fix_path;
			}
		    }

		    /*
		     * Here we copy until the next path separator or the end of
		     * the path. If we stop at a path separator, there is
		     * still something else left. This is handled below by
		     * pushing every directory returned from expand_wildcards()
		     * on the stack again for further search.
		     */
		    while (*rest_of_wildcards
			    && !vim_ispathsep(*rest_of_wildcards))
			file_path[len++] = *rest_of_wildcards++;

		    file_path[len] = NUL;
		    if (vim_ispathsep(*rest_of_wildcards))
			rest_of_wildcards++;
		}
#endif

		/*
		 * Expand wildcards like "*" and "$VAR".
		 * If the path is a URL don't try this.
		 */
		if (path_with_url(dirptrs[0]))
		{
		    stackp->ffs_filearray = (char_u **)
					      alloc((unsigned)sizeof(char *));
		    if (stackp->ffs_filearray != NULL
			    && (stackp->ffs_filearray[0]
				= vim_strsave(dirptrs[0])) != NULL)
			stackp->ffs_filearray_size = 1;
		    else
			stackp->ffs_filearray_size = 0;
		}
		else
		    /* Add EW_NOTWILD because the expanded path may contain
		     * wildcard characters that are to be taken literally.
		     * This is a bit of a hack. */
		    expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,
			    &stackp->ffs_filearray_size,
			    &stackp->ffs_filearray,
			    EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);

		stackp->ffs_filearray_cur = 0;
		stackp->ffs_stage = 0;
	    }
#ifdef FEAT_PATH_EXTRA
	    else
		rest_of_wildcards = &stackp->ffs_wc_path[
						 STRLEN(stackp->ffs_wc_path)];
#endif

	    if (stackp->ffs_stage == 0)
	    {
		/* this is the first time we work on this directory */
#ifdef FEAT_PATH_EXTRA
		if (*rest_of_wildcards == NUL)
#endif
		{
		    /*
		     * We don't have further wildcards to expand, so we have to
		     * check for the final file now.
		     */
		    for (i = stackp->ffs_filearray_cur;
					  i < stackp->ffs_filearray_size; ++i)
		    {
			if (!path_with_url(stackp->ffs_filearray[i])
				      && !mch_isdir(stackp->ffs_filearray[i]))
			    continue;   /* not a directory */

			/* prepare the filename to be checked for existence
			 * below */
			STRCPY(file_path, stackp->ffs_filearray[i]);
			add_pathsep(file_path);
			STRCAT(file_path, search_ctx->ffsc_file_to_search);

			/*
			 * Try without extra suffix and then with suffixes
			 * from 'suffixesadd'.
			 */
#ifdef FEAT_SEARCHPATH
			len = (int)STRLEN(file_path);
			if (search_ctx->ffsc_tagfile)
			    suf = (char_u *)"";
			else
			    suf = curbuf->b_p_sua;
			for (;;)
#endif
			{
			    /* if file exists and we didn't already find it */
			    if ((path_with_url(file_path)
				  || (mch_getperm(file_path) >= 0
				      && (search_ctx->ffsc_find_what
							      == FINDFILE_BOTH
					  || ((search_ctx->ffsc_find_what
							      == FINDFILE_DIR)
						   == mch_isdir(file_path)))))
#ifndef FF_VERBOSE
				    && (ff_check_visited(
					    &search_ctx->ffsc_visited_list->ffvl_visited_list,
					    file_path
#ifdef FEAT_PATH_EXTRA
					    , (char_u *)""
#endif
					    ) == OK)
#endif
			       )
			    {
#ifdef FF_VERBOSE
				if (ff_check_visited(
					    &search_ctx->ffsc_visited_list->ffvl_visited_list,
					    file_path
#ifdef FEAT_PATH_EXTRA
					    , (char_u *)""
#endif
						    ) == FAIL)
				{
				    if (p_verbose >= 5)
				    {
					verbose_enter_scroll();
					smsg((char_u *)"Already: %s",
								   file_path);
					/* don't overwrite this either */
					msg_puts((char_u *)"\n");
					verbose_leave_scroll();
				    }
				    continue;
				}
#endif

				/* push dir to examine rest of subdirs later */
				stackp->ffs_filearray_cur = i + 1;
				ff_push(search_ctx, stackp);

				if (!path_with_url(file_path))
				    simplify_filename(file_path);
				if (mch_dirname(ff_expand_buffer, MAXPATHL)
									== OK)
				{
				    p = shorten_fname(file_path,
							    ff_expand_buffer);
				    if (p != NULL)
					STRMOVE(file_path, p);
				}
#ifdef FF_VERBOSE
				if (p_verbose >= 5)
				{
				    verbose_enter_scroll();
				    smsg((char_u *)"HIT: %s", file_path);
				    /* don't overwrite this either */
				    msg_puts((char_u *)"\n");
				    verbose_leave_scroll();
				}
#endif
				return file_path;
			    }

#ifdef FEAT_SEARCHPATH
			    /* Not found or found already, try next suffix. */
			    if (*suf == NUL)
				break;
			    copy_option_part(&suf, file_path + len,
							 MAXPATHL - len, ",");
#endif
			}
		    }
		}
#ifdef FEAT_PATH_EXTRA
		else
		{
		    /*
		     * still wildcards left, push the directories for further
		     * search
		     */
		    for (i = stackp->ffs_filearray_cur;
					  i < stackp->ffs_filearray_size; ++i)
		    {
			if (!mch_isdir(stackp->ffs_filearray[i]))
			    continue;	/* not a directory */

			ff_push(search_ctx,
				ff_create_stack_element(
						     stackp->ffs_filearray[i],
						     rest_of_wildcards,
						     stackp->ffs_level - 1, 0));
		    }
		}
#endif
		stackp->ffs_filearray_cur = 0;
		stackp->ffs_stage = 1;
	    }

#ifdef FEAT_PATH_EXTRA
	    /*
	     * if wildcards contains '**' we have to descent till we reach the
	     * leaves of the directory tree.
	     */
	    if (STRNCMP(stackp->ffs_wc_path, "**", 2) == 0)
	    {
		for (i = stackp->ffs_filearray_cur;
					  i < stackp->ffs_filearray_size; ++i)
		{
		    if (fnamecmp(stackp->ffs_filearray[i],
						   stackp->ffs_fix_path) == 0)
			continue; /* don't repush same directory */
		    if (!mch_isdir(stackp->ffs_filearray[i]))
			continue;   /* not a directory */
		    ff_push(search_ctx,
			    ff_create_stack_element(stackp->ffs_filearray[i],
				stackp->ffs_wc_path, stackp->ffs_level - 1, 1));
		}
	    }
#endif

	    /* we are done with the current directory */
	    ff_free_stack_element(stackp);

	}

#ifdef FEAT_PATH_EXTRA
	/* If we reached this, we didn't find anything downwards.
	 * Let's check if we should do an upward search.
	 */
	if (search_ctx->ffsc_start_dir
		&& search_ctx->ffsc_stopdirs_v != NULL && !got_int)
	{
	    ff_stack_T  *sptr;

	    /* is the last starting directory in the stop list? */
	    if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,
		       (int)(path_end - search_ctx->ffsc_start_dir),
		       search_ctx->ffsc_stopdirs_v) == TRUE)
		break;

	    /* cut of last dir */
	    while (path_end > search_ctx->ffsc_start_dir
						  && vim_ispathsep(*path_end))
		path_end--;
	    while (path_end > search_ctx->ffsc_start_dir
					      && !vim_ispathsep(path_end[-1]))
		path_end--;
	    *path_end = 0;
	    path_end--;

	    if (*search_ctx->ffsc_start_dir == 0)
		break;

	    STRCPY(file_path, search_ctx->ffsc_start_dir);
	    add_pathsep(file_path);
	    STRCAT(file_path, search_ctx->ffsc_fix_path);

	    /* create a new stack entry */
	    sptr = ff_create_stack_element(file_path,
		    search_ctx->ffsc_wc_path, search_ctx->ffsc_level, 0);
	    if (sptr == NULL)
		break;
	    ff_push(search_ctx, sptr);
	}
	else
	    break;
    }
#endif

    vim_free(file_path);
    return NULL;
}

/*
 * Free the list of lists of visited files and directories
 * Can handle it if the passed search_context is NULL;
 */
    void
vim_findfile_free_visited(search_ctx_arg)
    void	*search_ctx_arg;
{
    ff_search_ctx_T *search_ctx;

    if (search_ctx_arg == NULL)
	return;

    search_ctx = (ff_search_ctx_T *)search_ctx_arg;
    vim_findfile_free_visited_list(&search_ctx->ffsc_visited_lists_list);
    vim_findfile_free_visited_list(&search_ctx->ffsc_dir_visited_lists_list);
}

    static void
vim_findfile_free_visited_list(list_headp)
    ff_visited_list_hdr_T	**list_headp;
{
    ff_visited_list_hdr_T *vp;

    while (*list_headp != NULL)
    {
	vp = (*list_headp)->ffvl_next;
	ff_free_visited_list((*list_headp)->ffvl_visited_list);

	vim_free((*list_headp)->ffvl_filename);
	vim_free(*list_headp);
	*list_headp = vp;
    }
    *list_headp = NULL;
}

    static void
ff_free_visited_list(vl)
    ff_visited_T *vl;
{
    ff_visited_T *vp;

    while (vl != NULL)
    {
	vp = vl->ffv_next;
#ifdef FEAT_PATH_EXTRA
	vim_free(vl->ffv_wc_path);
#endif
	vim_free(vl);
	vl = vp;
    }
    vl = NULL;
}

/*
 * Returns the already visited list for the given filename. If none is found it
 * allocates a new one.
 */
    static ff_visited_list_hdr_T*
ff_get_visited_list(filename, list_headp)
    char_u			*filename;
    ff_visited_list_hdr_T	**list_headp;
{
    ff_visited_list_hdr_T  *retptr = NULL;

    /* check if a visited list for the given filename exists */
    if (*list_headp != NULL)
    {
	retptr = *list_headp;
	while (retptr != NULL)
	{
	    if (fnamecmp(filename, retptr->ffvl_filename) == 0)
	    {
#ifdef FF_VERBOSE
		if (p_verbose >= 5)
		{
		    verbose_enter_scroll();
		    smsg((char_u *)"ff_get_visited_list: FOUND list for %s",
								    filename);
		    /* don't overwrite this either */
		    msg_puts((char_u *)"\n");
		    verbose_leave_scroll();
		}
#endif
		return retptr;
	    }
	    retptr = retptr->ffvl_next;
	}
    }

#ifdef FF_VERBOSE
    if (p_verbose >= 5)
    {
	verbose_enter_scroll();
	smsg((char_u *)"ff_get_visited_list: new list for %s", filename);
	/* don't overwrite this either */
	msg_puts((char_u *)"\n");
	verbose_leave_scroll();
    }
#endif

    /*
     * if we reach this we didn't find a list and we have to allocate new list
     */
    retptr = (ff_visited_list_hdr_T*)alloc((unsigned)sizeof(*retptr));
    if (retptr == NULL)
	return NULL;

    retptr->ffvl_visited_list = NULL;
    retptr->ffvl_filename = vim_strsave(filename);
    if (retptr->ffvl_filename == NULL)
    {
	vim_free(retptr);
	return NULL;
    }
    retptr->ffvl_next = *list_headp;
    *list_headp = retptr;

    return retptr;
}

#ifdef FEAT_PATH_EXTRA
/*
 * check if two wildcard paths are equal. Returns TRUE or FALSE.
 * They are equal if:
 *  - both paths are NULL
 *  - they have the same length
 *  - char by char comparison is OK
 *  - the only differences are in the counters behind a '**', so
 *    '**\20' is equal to '**\24'
 */
    static int
ff_wc_equal(s1, s2)
    char_u	*s1;
    char_u	*s2;
{
    int		i;
    int		prev1 = NUL;
    int		prev2 = NUL;

    if (s1 == s2)
	return TRUE;

    if (s1 == NULL || s2 == NULL)
	return FALSE;

    if (STRLEN(s1) != STRLEN(s2))
	return FAIL;

    for (i = 0; s1[i] != NUL && s2[i] != NUL; i += MB_PTR2LEN(s1 + i))
    {
	int c1 = PTR2CHAR(s1 + i);
	int c2 = PTR2CHAR(s2 + i);

	if ((p_fic ? MB_TOLOWER(c1) != MB_TOLOWER(c2) : c1 != c2)
		&& (prev1 != '*' || prev2 != '*'))
	    return FAIL;
	prev2 = prev1;
	prev1 = c1;
    }
    return TRUE;
}
#endif

/*
 * maintains the list of already visited files and dirs
 * returns FAIL if the given file/dir is already in the list
 * returns OK if it is newly added
 *
 * TODO: What to do on memory allocation problems?
 *	 -> return TRUE - Better the file is found several times instead of
 *	    never.
 */
    static int
ff_check_visited(visited_list, fname
#ifdef FEAT_PATH_EXTRA
	, wc_path
#endif
	)
    ff_visited_T	**visited_list;
    char_u		*fname;
#ifdef FEAT_PATH_EXTRA
    char_u		*wc_path;
#endif
{
    ff_visited_T	*vp;
#ifdef UNIX
    struct stat		st;
    int			url = FALSE;
#endif

    /* For an URL we only compare the name, otherwise we compare the
     * device/inode (unix) or the full path name (not Unix). */
    if (path_with_url(fname))
    {
	vim_strncpy(ff_expand_buffer, fname, MAXPATHL - 1);
#ifdef UNIX
	url = TRUE;
#endif
    }
    else
    {
	ff_expand_buffer[0] = NUL;
#ifdef UNIX
	if (mch_stat((char *)fname, &st) < 0)
#else
	if (vim_FullName(fname, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)
#endif
	    return FAIL;
    }

    /* check against list of already visited files */
    for (vp = *visited_list; vp != NULL; vp = vp->ffv_next)
    {
	if (
#ifdef UNIX
		!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev
						  && vp->ffv_ino == st.st_ino)
		     :
#endif
		fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0
	   )
	{
#ifdef FEAT_PATH_EXTRA
	    /* are the wildcard parts equal */
	    if (ff_wc_equal(vp->ffv_wc_path, wc_path) == TRUE)
#endif
		/* already visited */
		return FAIL;
	}
    }

    /*
     * New file/dir.  Add it to the list of visited files/dirs.
     */
    vp = (ff_visited_T *)alloc((unsigned)(sizeof(ff_visited_T)
						 + STRLEN(ff_expand_buffer)));

    if (vp != NULL)
    {
#ifdef UNIX
	if (!url)
	{
	    vp->ffv_dev_valid = TRUE;
	    vp->ffv_ino = st.st_ino;
	    vp->ffv_dev = st.st_dev;
	    vp->ffv_fname[0] = NUL;
	}
	else
	{
	    vp->ffv_dev_valid = FALSE;
#endif
	    STRCPY(vp->ffv_fname, ff_expand_buffer);
#ifdef UNIX
	}
#endif
#ifdef FEAT_PATH_EXTRA
	if (wc_path != NULL)
	    vp->ffv_wc_path = vim_strsave(wc_path);
	else
	    vp->ffv_wc_path = NULL;
#endif

	vp->ffv_next = *visited_list;
	*visited_list = vp;
    }

    return OK;
}

/*
 * create stack element from given path pieces
 */
    static ff_stack_T *
ff_create_stack_element(fix_part,
#ifdef FEAT_PATH_EXTRA
	wc_part,
#endif
	level, star_star_empty)
    char_u	*fix_part;
#ifdef FEAT_PATH_EXTRA
    char_u	*wc_part;
#endif
    int		level;
    int		star_star_empty;
{
    ff_stack_T	*new;

    new = (ff_stack_T *)alloc((unsigned)sizeof(ff_stack_T));
    if (new == NULL)
	return NULL;

    new->ffs_prev	   = NULL;
    new->ffs_filearray	   = NULL;
    new->ffs_filearray_size = 0;
    new->ffs_filearray_cur  = 0;
    new->ffs_stage	   = 0;
    new->ffs_level	   = level;
    new->ffs_star_star_empty = star_star_empty;;

    /* the following saves NULL pointer checks in vim_findfile */
    if (fix_part == NULL)
	fix_part = (char_u *)"";
    new->ffs_fix_path = vim_strsave(fix_part);

#ifdef FEAT_PATH_EXTRA
    if (wc_part == NULL)
	wc_part  = (char_u *)"";
    new->ffs_wc_path = vim_strsave(wc_part);
#endif

    if (new->ffs_fix_path == NULL
#ifdef FEAT_PATH_EXTRA
	    || new->ffs_wc_path == NULL
#endif
	    )
    {
	ff_free_stack_element(new);
	new = NULL;
    }

    return new;
}

/*
 * Push a dir on the directory stack.
 */
    static void
ff_push(search_ctx, stack_ptr)
    ff_search_ctx_T *search_ctx;
    ff_stack_T	    *stack_ptr;
{
    /* check for NULL pointer, not to return an error to the user, but
     * to prevent a crash */
    if (stack_ptr != NULL)
    {
	stack_ptr->ffs_prev = search_ctx->ffsc_stack_ptr;
	search_ctx->ffsc_stack_ptr = stack_ptr;
    }
}

/*
 * Pop a dir from the directory stack.
 * Returns NULL if stack is empty.
 */
    static ff_stack_T *
ff_pop(search_ctx)
    ff_search_ctx_T *search_ctx;
{
    ff_stack_T  *sptr;

    sptr = search_ctx->ffsc_stack_ptr;
    if (search_ctx->ffsc_stack_ptr != NULL)
	search_ctx->ffsc_stack_ptr = search_ctx->ffsc_stack_ptr->ffs_prev;

    return sptr;
}

/*
 * free the given stack element
 */
    static void
ff_free_stack_element(stack_ptr)
    ff_stack_T  *stack_ptr;
{
    /* vim_free handles possible NULL pointers */
    vim_free(stack_ptr->ffs_fix_path);
#ifdef FEAT_PATH_EXTRA
    vim_free(stack_ptr->ffs_wc_path);
#endif

    if (stack_ptr->ffs_filearray != NULL)
	FreeWild(stack_ptr->ffs_filearray_size, stack_ptr->ffs_filearray);

    vim_free(stack_ptr);
}

/*
 * Clear the search context, but NOT the visited list.
 */
    static void
ff_clear(search_ctx)
    ff_search_ctx_T *search_ctx;
{
    ff_stack_T   *sptr;

    /* clear up stack */
    while ((sptr = ff_pop(search_ctx)) != NULL)
	ff_free_stack_element(sptr);

    vim_free(search_ctx->ffsc_file_to_search);
    vim_free(search_ctx->ffsc_start_dir);
    vim_free(search_ctx->ffsc_fix_path);
#ifdef FEAT_PATH_EXTRA
    vim_free(search_ctx->ffsc_wc_path);
#endif

#ifdef FEAT_PATH_EXTRA
    if (search_ctx->ffsc_stopdirs_v != NULL)
    {
	int  i = 0;

	while (search_ctx->ffsc_stopdirs_v[i] != NULL)
	{
	    vim_free(search_ctx->ffsc_stopdirs_v[i]);
	    i++;
	}
	vim_free(search_ctx->ffsc_stopdirs_v);
    }
    search_ctx->ffsc_stopdirs_v = NULL;
#endif

    /* reset everything */
    search_ctx->ffsc_file_to_search = NULL;
    search_ctx->ffsc_start_dir = NULL;
    search_ctx->ffsc_fix_path = NULL;
#ifdef FEAT_PATH_EXTRA
    search_ctx->ffsc_wc_path = NULL;
    search_ctx->ffsc_level = 0;
#endif
}

#ifdef FEAT_PATH_EXTRA
/*
 * check if the given path is in the stopdirs
 * returns TRUE if yes else FALSE
 */
    static int
ff_path_in_stoplist(path, path_len, stopdirs_v)
    char_u	*path;
    int		path_len;
    char_u	**stopdirs_v;
{
    int		i = 0;

    /* eat up trailing path separators, except the first */
    while (path_len > 1 && vim_ispathsep(path[path_len - 1]))
	path_len--;

    /* if no path consider it as match */
    if (path_len == 0)
	return TRUE;

    for (i = 0; stopdirs_v[i] != NULL; i++)
    {
	if ((int)STRLEN(stopdirs_v[i]) > path_len)
	{
	    /* match for parent directory. So '/home' also matches
	     * '/home/rks'. Check for PATHSEP in stopdirs_v[i], else
	     * '/home/r' would also match '/home/rks'
	     */
	    if (fnamencmp(stopdirs_v[i], path, path_len) == 0
		    && vim_ispathsep(stopdirs_v[i][path_len]))
		return TRUE;
	}
	else
	{
	    if (fnamecmp(stopdirs_v[i], path) == 0)
		return TRUE;
	}
    }
    return FALSE;
}
#endif

#if defined(FEAT_SEARCHPATH) || defined(PROTO)
/*
 * Find the file name "ptr[len]" in the path.  Also finds directory names.
 *
 * On the first call set the parameter 'first' to TRUE to initialize
 * the search.  For repeating calls to FALSE.
 *
 * Repeating calls will return other files called 'ptr[len]' from the path.
 *
 * Only on the first call 'ptr' and 'len' are used.  For repeating calls they
 * don't need valid values.
 *
 * If nothing found on the first call the option FNAME_MESS will issue the
 * message:
 *	    'Can't find file "<file>" in path'
 * On repeating calls:
 *	    'No more file "<file>" found in path'
 *
 * options:
 * FNAME_MESS	    give error message when not found
 *
 * Uses NameBuff[]!
 *
 * Returns an allocated string for the file name.  NULL for error.
 *
 */
    char_u *
find_file_in_path(ptr, len, options, first, rel_fname)
    char_u	*ptr;		/* file name */
    int		len;		/* length of file name */
    int		options;
    int		first;		/* use count'th matching file name */
    char_u	*rel_fname;	/* file name searching relative to */
{
    return find_file_in_path_option(ptr, len, options, first,
	    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,
	    FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);
}

static char_u	*ff_file_to_find = NULL;
static void	*fdip_search_ctx = NULL;

#if defined(EXITFREE)
    static void
free_findfile()
{
    vim_free(ff_file_to_find);
    vim_findfile_cleanup(fdip_search_ctx);
}
#endif

/*
 * Find the directory name "ptr[len]" in the path.
 *
 * options:
 * FNAME_MESS	    give error message when not found
 *
 * Uses NameBuff[]!
 *
 * Returns an allocated string for the file name.  NULL for error.
 */
    char_u *
find_directory_in_path(ptr, len, options, rel_fname)
    char_u	*ptr;		/* file name */
    int		len;		/* length of file name */
    int		options;
    char_u	*rel_fname;	/* file name searching relative to */
{
    return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,
				       FINDFILE_DIR, rel_fname, (char_u *)"");
}

    char_u *
find_file_in_path_option(ptr, len, options, first, path_option, find_what, rel_fname, suffixes)
    char_u	*ptr;		/* file name */
    int		len;		/* length of file name */
    int		options;
    int		first;		/* use count'th matching file name */
    char_u	*path_option;	/* p_path or p_cdpath */
    int		find_what;	/* FINDFILE_FILE, _DIR or _BOTH */
    char_u	*rel_fname;	/* file name we are looking relative to. */
    char_u	*suffixes;	/* list of suffixes, 'suffixesadd' option */
{
    static char_u	*dir;
    static int		did_findfile_init = FALSE;
    char_u		save_char;
    char_u		*file_name = NULL;
    char_u		*buf = NULL;
    int			rel_to_curdir;
#ifdef AMIGA
    struct Process	*proc = (struct Process *)FindTask(0L);
    APTR		save_winptr = proc->pr_WindowPtr;

    /* Avoid a requester here for a volume that doesn't exist. */
    proc->pr_WindowPtr = (APTR)-1L;
#endif

    if (first == TRUE)
    {
	/* copy file name into NameBuff, expanding environment variables */
	save_char = ptr[len];
	ptr[len] = NUL;
	expand_env(ptr, NameBuff, MAXPATHL);
	ptr[len] = save_char;

	vim_free(ff_file_to_find);
	ff_file_to_find = vim_strsave(NameBuff);
	if (ff_file_to_find == NULL)	/* out of memory */
	{
	    file_name = NULL;
	    goto theend;
	}
    }

    rel_to_curdir = (ff_file_to_find[0] == '.'
		    && (ff_file_to_find[1] == NUL
			|| vim_ispathsep(ff_file_to_find[1])
			|| (ff_file_to_find[1] == '.'
			    && (ff_file_to_find[2] == NUL
				|| vim_ispathsep(ff_file_to_find[2])))));
    if (vim_isAbsName(ff_file_to_find)
	    /* "..", "../path", "." and "./path": don't use the path_option */
	    || rel_to_curdir
#if defined(MSWIN) || defined(MSDOS) || defined(OS2)
	    /* handle "\tmp" as absolute path */
	    || vim_ispathsep(ff_file_to_find[0])
	    /* handle "c:name" as absolute path */
	    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')
#endif
#ifdef AMIGA
	    /* handle ":tmp" as absolute path */
	    || ff_file_to_find[0] == ':'
#endif
       )
    {
	/*
	 * Absolute path, no need to use "path_option".
	 * If this is not a first call, return NULL.  We already returned a
	 * filename on the first call.
	 */
	if (first == TRUE)
	{
	    int		l;
	    int		run;

	    if (path_with_url(ff_file_to_find))
	    {
		file_name = vim_strsave(ff_file_to_find);
		goto theend;
	    }

	    /* When FNAME_REL flag given first use the directory of the file.
	     * Otherwise or when this fails use the current directory. */
	    for (run = 1; run <= 2; ++run)
	    {
		l = (int)STRLEN(ff_file_to_find);
		if (run == 1
			&& rel_to_curdir
			&& (options & FNAME_REL)
			&& rel_fname != NULL
			&& STRLEN(rel_fname) + l < MAXPATHL)
		{
		    STRCPY(NameBuff, rel_fname);
		    STRCPY(gettail(NameBuff), ff_file_to_find);
		    l = (int)STRLEN(NameBuff);
		}
		else
		{
		    STRCPY(NameBuff, ff_file_to_find);
		    run = 2;
		}

		/* When the file doesn't exist, try adding parts of
		 * 'suffixesadd'. */
		buf = suffixes;
		for (;;)
		{
		    if (
#ifdef DJGPP
			    /* "C:" by itself will fail for mch_getperm(),
			     * assume it's always valid. */
			    (find_what != FINDFILE_FILE && NameBuff[0] != NUL
				  && NameBuff[1] == ':'
				  && NameBuff[2] == NUL) ||
#endif
			    (mch_getperm(NameBuff) >= 0
			     && (find_what == FINDFILE_BOTH
				 || ((find_what == FINDFILE_DIR)
						    == mch_isdir(NameBuff)))))
		    {
			file_name = vim_strsave(NameBuff);
			goto theend;
		    }
		    if (*buf == NUL)
			break;
		    copy_option_part(&buf, NameBuff + l, MAXPATHL - l, ",");
		}
	    }
	}
    }
    else
    {
	/*
	 * Loop over all paths in the 'path' or 'cdpath' option.
	 * When "first" is set, first setup to the start of the option.
	 * Otherwise continue to find the next match.
	 */
	if (first == TRUE)
	{
	    /* vim_findfile_free_visited can handle a possible NULL pointer */
	    vim_findfile_free_visited(fdip_search_ctx);
	    dir = path_option;
	    did_findfile_init = FALSE;
	}

	for (;;)
	{
	    if (did_findfile_init)
	    {
		file_name = vim_findfile(fdip_search_ctx);
		if (file_name != NULL)
		    break;

		did_findfile_init = FALSE;
	    }
	    else
	    {
		char_u  *r_ptr;

		if (dir == NULL || *dir == NUL)
		{
		    /* We searched all paths of the option, now we can
		     * free the search context. */
		    vim_findfile_cleanup(fdip_search_ctx);
		    fdip_search_ctx = NULL;
		    break;
		}

		if ((buf = alloc((int)(MAXPATHL))) == NULL)
		    break;

		/* copy next path */
		buf[0] = 0;
		copy_option_part(&dir, buf, MAXPATHL, " ,");

#ifdef FEAT_PATH_EXTRA
		/* get the stopdir string */
		r_ptr = vim_findfile_stopdir(buf);
#else
		r_ptr = NULL;
#endif
		fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,
					    r_ptr, 100, FALSE, find_what,
					   fdip_search_ctx, FALSE, rel_fname);
		if (fdip_search_ctx != NULL)
		    did_findfile_init = TRUE;
		vim_free(buf);
	    }
	}
    }
    if (file_name == NULL && (options & FNAME_MESS))
    {
	if (first == TRUE)
	{
	    if (find_what == FINDFILE_DIR)
		EMSG2(_("E344: Can't find directory \"%s\" in cdpath"),
			ff_file_to_find);
	    else
		EMSG2(_("E345: Can't find file \"%s\" in path"),
			ff_file_to_find);
	}
	else
	{
	    if (find_what == FINDFILE_DIR)
		EMSG2(_("E346: No more directory \"%s\" found in cdpath"),
			ff_file_to_find);
	    else
		EMSG2(_("E347: No more file \"%s\" found in path"),
			ff_file_to_find);
	}
    }

theend:
#ifdef AMIGA
    proc->pr_WindowPtr = save_winptr;
#endif
    return file_name;
}

#endif /* FEAT_SEARCHPATH */

/*
 * Change directory to "new_dir".  If FEAT_SEARCHPATH is defined, search
 * 'cdpath' for relative directory names, otherwise just mch_chdir().
 */
    int
vim_chdir(new_dir)
    char_u	*new_dir;
{
#ifndef FEAT_SEARCHPATH
    return mch_chdir((char *)new_dir);
#else
    char_u	*dir_name;
    int		r;

    dir_name = find_directory_in_path(new_dir, (int)STRLEN(new_dir),
						FNAME_MESS, curbuf->b_ffname);
    if (dir_name == NULL)
	return -1;
    r = mch_chdir((char *)dir_name);
    vim_free(dir_name);
    return r;
#endif
}

/*
 * Get user name from machine-specific function.
 * Returns the user name in "buf[len]".
 * Some systems are quite slow in obtaining the user name (Windows NT), thus
 * cache the result.
 * Returns OK or FAIL.
 */
    int
get_user_name(buf, len)
    char_u	*buf;
    int		len;
{
    if (username == NULL)
    {
	if (mch_get_user_name(buf, len) == FAIL)
	    return FAIL;
	username = vim_strsave(buf);
    }
    else
	vim_strncpy(buf, username, len - 1);
    return OK;
}

#ifndef HAVE_QSORT
/*
 * Our own qsort(), for systems that don't have it.
 * It's simple and slow.  From the K&R C book.
 */
    void
qsort(base, elm_count, elm_size, cmp)
    void	*base;
    size_t	elm_count;
    size_t	elm_size;
    int (*cmp) __ARGS((const void *, const void *));
{
    char_u	*buf;
    char_u	*p1;
    char_u	*p2;
    int		i, j;
    int		gap;

    buf = alloc((unsigned)elm_size);
    if (buf == NULL)
	return;

    for (gap = elm_count / 2; gap > 0; gap /= 2)
	for (i = gap; i < elm_count; ++i)
	    for (j = i - gap; j >= 0; j -= gap)
	    {
		/* Compare the elements. */
		p1 = (char_u *)base + j * elm_size;
		p2 = (char_u *)base + (j + gap) * elm_size;
		if ((*cmp)((void *)p1, (void *)p2) <= 0)
		    break;
		/* Exchange the elements. */
		mch_memmove(buf, p1, elm_size);
		mch_memmove(p1, p2, elm_size);
		mch_memmove(p2, buf, elm_size);
	    }

    vim_free(buf);
}
#endif

/*
 * Sort an array of strings.
 */
static int
#ifdef __BORLANDC__
_RTLENTRYF
#endif
sort_compare __ARGS((const void *s1, const void *s2));

    static int
#ifdef __BORLANDC__
_RTLENTRYF
#endif
sort_compare(s1, s2)
    const void	*s1;
    const void	*s2;
{
    return STRCMP(*(char **)s1, *(char **)s2);
}

    void
sort_strings(files, count)
    char_u	**files;
    int		count;
{
    qsort((void *)files, (size_t)count, sizeof(char_u *), sort_compare);
}

#if !defined(NO_EXPANDPATH) || defined(PROTO)
/*
 * Compare path "p[]" to "q[]".
 * If "maxlen" >= 0 compare "p[maxlen]" to "q[maxlen]"
 * Return value like strcmp(p, q), but consider path separators.
 */
    int
pathcmp(p, q, maxlen)
    const char *p, *q;
    int maxlen;
{
    int		i;
    int		c1, c2;
    const char	*s = NULL;

    for (i = 0; maxlen < 0 || i < maxlen; i += MB_PTR2LEN((char_u *)p + i))
    {
	c1 = PTR2CHAR((char_u *)p + i);
	c2 = PTR2CHAR((char_u *)q + i);

	/* End of "p": check if "q" also ends or just has a slash. */
	if (c1 == NUL)
	{
	    if (c2 == NUL)  /* full match */
		return 0;
	    s = q;
	    break;
	}

	/* End of "q": check if "p" just has a slash. */
	if (c2 == NUL)
	{
	    s = p;
	    break;
	}

	if ((p_fic ? MB_TOUPPER(c1) != MB_TOUPPER(c2) : c1 != c2)
#ifdef BACKSLASH_IN_FILENAME
		/* consider '/' and '\\' to be equal */
		&& !((c1 == '/' && c2 == '\\')
		    || (c1 == '\\' && c2 == '/'))
#endif
		)
	{
	    if (vim_ispathsep(c1))
		return -1;
	    if (vim_ispathsep(c2))
		return 1;
	    return p_fic ? MB_TOUPPER(c1) - MB_TOUPPER(c2)
		    : c1 - c2;  /* no match */
	}
    }
    if (s == NULL)	/* "i" ran into "maxlen" */
	return 0;

    c1 = PTR2CHAR((char_u *)s + i);
    c2 = PTR2CHAR((char_u *)s + i + MB_PTR2LEN((char_u *)s + i));
    /* ignore a trailing slash, but not "//" or ":/" */
    if (c2 == NUL
	    && i > 0
	    && !after_pathsep((char_u *)s, (char_u *)s + i)
#ifdef BACKSLASH_IN_FILENAME
	    && (c1 == '/' || c1 == '\\')
#else
	    && c1 == '/'
#endif
       )
	return 0;   /* match with trailing slash */
    if (s == q)
	return -1;	    /* no match */
    return 1;
}
#endif

/*
 * The putenv() implementation below comes from the "screen" program.
 * Included with permission from Juergen Weigert.
 * See pty.c for the copyright notice.
 */

/*
 *  putenv  --	put value into environment
 *
 *  Usage:  i = putenv (string)
 *    int i;
 *    char  *string;
 *
 *  where string is of the form <name>=<value>.
 *  Putenv returns 0 normally, -1 on error (not enough core for malloc).
 *
 *  Putenv may need to add a new name into the environment, or to
 *  associate a value longer than the current value with a particular
 *  name.  So, to make life simpler, putenv() copies your entire
 *  environment into the heap (i.e. malloc()) from the stack
 *  (i.e. where it resides when your process is initiated) the first
 *  time you call it.
 *
 *  (history removed, not very interesting.  See the "screen" sources.)
 */

#if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)

#define EXTRASIZE 5		/* increment to add to env. size */

static int  envsize = -1;	/* current size of environment */
#ifndef MACOS_CLASSIC
extern
#endif
       char **environ;		/* the global which is your env. */

static int  findenv __ARGS((char *name)); /* look for a name in the env. */
static int  newenv __ARGS((void));	/* copy env. from stack to heap */
static int  moreenv __ARGS((void));	/* incr. size of env. */

    int
putenv(string)
    const char *string;
{
    int	    i;
    char    *p;

    if (envsize < 0)
    {				/* first time putenv called */
	if (newenv() < 0)	/* copy env. to heap */
	    return -1;
    }

    i = findenv((char *)string); /* look for name in environment */

    if (i < 0)
    {				/* name must be added */
	for (i = 0; environ[i]; i++);
	if (i >= (envsize - 1))
	{			/* need new slot */
	    if (moreenv() < 0)
		return -1;
	}
	p = (char *)alloc((unsigned)(strlen(string) + 1));
	if (p == NULL)		/* not enough core */
	    return -1;
	environ[i + 1] = 0;	/* new end of env. */
    }
    else
    {				/* name already in env. */
	p = vim_realloc(environ[i], strlen(string) + 1);
	if (p == NULL)
	    return -1;
    }
    sprintf(p, "%s", string);	/* copy into env. */
    environ[i] = p;

    return 0;
}

    static int
findenv(name)
    char *name;
{
    char    *namechar, *envchar;
    int	    i, found;

    found = 0;
    for (i = 0; environ[i] && !found; i++)
    {
	envchar = environ[i];
	namechar = name;
	while (*namechar && *namechar != '=' && (*namechar == *envchar))
	{
	    namechar++;
	    envchar++;
	}
	found = ((*namechar == '\0' || *namechar == '=') && *envchar == '=');
    }
    return found ? i - 1 : -1;
}

    static int
newenv()
{
    char    **env, *elem;
    int	    i, esize;

#ifdef MACOS
    /* for Mac a new, empty environment is created */
    i = 0;
#else
    for (i = 0; environ[i]; i++)
	;
#endif
    esize = i + EXTRASIZE + 1;
    env = (char **)alloc((unsigned)(esize * sizeof (elem)));
    if (env == NULL)
	return -1;

#ifndef MACOS
    for (i = 0; environ[i]; i++)
    {
	elem = (char *)alloc((unsigned)(strlen(environ[i]) + 1));
	if (elem == NULL)
	    return -1;
	env[i] = elem;
	strcpy(elem, environ[i]);
    }
#endif

    env[i] = 0;
    environ = env;
    envsize = esize;
    return 0;
}

    static int
moreenv()
{
    int	    esize;
    char    **env;

    esize = envsize + EXTRASIZE;
    env = (char **)vim_realloc((char *)environ, esize * sizeof (*env));
    if (env == 0)
	return -1;
    environ = env;
    envsize = esize;
    return 0;
}

# ifdef USE_VIMPTY_GETENV
    char_u *
vimpty_getenv(string)
    const char_u *string;
{
    int i;
    char_u *p;

    if (envsize < 0)
	return NULL;

    i = findenv((char *)string);

    if (i < 0)
	return NULL;

    p = vim_strchr((char_u *)environ[i], '=');
    return (p + 1);
}
# endif

#endif /* !defined(HAVE_SETENV) && !defined(HAVE_PUTENV) */

#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)
/*
 * Return 0 for not writable, 1 for writable file, 2 for a dir which we have
 * rights to write into.
 */
    int
filewritable(fname)
    char_u	*fname;
{
    int		retval = 0;
#if defined(UNIX) || defined(VMS)
    int		perm = 0;
#endif

#if defined(UNIX) || defined(VMS)
    perm = mch_getperm(fname);
#endif
#ifndef MACOS_CLASSIC /* TODO: get either mch_writable or mch_access */
    if (
# ifdef WIN3264
	    mch_writable(fname) &&
# else
# if defined(UNIX) || defined(VMS)
	    (perm & 0222) &&
#  endif
# endif
	    mch_access((char *)fname, W_OK) == 0
       )
#endif
    {
	++retval;
	if (mch_isdir(fname))
	    ++retval;
    }
    return retval;
}
#endif

/*
 * Print an error message with one or two "%s" and one or two string arguments.
 * This is not in message.c to avoid a warning for prototypes.
 */
    int
emsg3(s, a1, a2)
    char_u *s, *a1, *a2;
{
    if (emsg_not_now())
	return TRUE;		/* no error messages at the moment */
#ifdef HAVE_STDARG_H
    vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
#else
    vim_snprintf((char *)IObuff, IOSIZE, (char *)s, (long_u)a1, (long_u)a2);
#endif
    return emsg(IObuff);
}

/*
 * Print an error message with one "%ld" and one long int argument.
 * This is not in message.c to avoid a warning for prototypes.
 */
    int
emsgn(s, n)
    char_u	*s;
    long	n;
{
    if (emsg_not_now())
	return TRUE;		/* no error messages at the moment */
    vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
    return emsg(IObuff);
}

#if defined(FEAT_SPELL) || defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)
/*
 * Read 2 bytes from "fd" and turn them into an int, MSB first.
 */
    int
get2c(fd)
    FILE	*fd;
{
    int		n;

    n = getc(fd);
    n = (n << 8) + getc(fd);
    return n;
}

/*
 * Read 3 bytes from "fd" and turn them into an int, MSB first.
 */
    int
get3c(fd)
    FILE	*fd;
{
    int		n;

    n = getc(fd);
    n = (n << 8) + getc(fd);
    n = (n << 8) + getc(fd);
    return n;
}

/*
 * Read 4 bytes from "fd" and turn them into an int, MSB first.
 */
    int
get4c(fd)
    FILE	*fd;
{
    int		n;

    n = getc(fd);
    n = (n << 8) + getc(fd);
    n = (n << 8) + getc(fd);
    n = (n << 8) + getc(fd);
    return n;
}

/*
 * Read 8 bytes from "fd" and turn them into a time_t, MSB first.
 */
    time_t
get8ctime(fd)
    FILE	*fd;
{
    time_t	n = 0;
    int		i;

    for (i = 0; i < 8; ++i)
	n = (n << 8) + getc(fd);
    return n;
}

/*
 * Read a string of length "cnt" from "fd" into allocated memory.
 * Returns NULL when out of memory or unable to read that many bytes.
 */
    char_u *
read_string(fd, cnt)
    FILE	*fd;
    int		cnt;
{
    char_u	*str;
    int		i;
    int		c;

    /* allocate memory */
    str = alloc((unsigned)cnt + 1);
    if (str != NULL)
    {
	/* Read the string.  Quit when running into the EOF. */
	for (i = 0; i < cnt; ++i)
	{
	    c = getc(fd);
	    if (c == EOF)
	    {
		vim_free(str);
		return NULL;
	    }
	    str[i] = c;
	}
	str[i] = NUL;
    }
    return str;
}

/*
 * Write a number to file "fd", MSB first, in "len" bytes.
 */
    int
put_bytes(fd, nr, len)
    FILE    *fd;
    long_u  nr;
    int	    len;
{
    int	    i;

    for (i = len - 1; i >= 0; --i)
	if (putc((int)(nr >> (i * 8)), fd) == EOF)
	    return FAIL;
    return OK;
}

#ifdef _MSC_VER
# if (_MSC_VER <= 1200)
/* This line is required for VC6 without the service pack.  Also see the
 * matching #pragma below. */
 #  pragma optimize("", off)
# endif
#endif

/*
 * Write time_t to file "fd" in 8 bytes.
 */
    void
put_time(fd, the_time)
    FILE	*fd;
    time_t	the_time;
{
    int		c;
    int		i;
    time_t	wtime = the_time;

    /* time_t can be up to 8 bytes in size, more than long_u, thus we
     * can't use put_bytes() here.
     * Another problem is that ">>" may do an arithmetic shift that keeps the
     * sign.  This happens for large values of wtime.  A cast to long_u may
     * truncate if time_t is 8 bytes.  So only use a cast when it is 4 bytes,
     * it's safe to assume that long_u is 4 bytes or more and when using 8
     * bytes the top bit won't be set. */
    for (i = 7; i >= 0; --i)
    {
	if (i + 1 > (int)sizeof(time_t))
	    /* ">>" doesn't work well when shifting more bits than avail */
	    putc(0, fd);
	else
	{
#if defined(SIZEOF_TIME_T) && SIZEOF_TIME_T > 4
	    c = (int)(wtime >> (i * 8));
#else
	    c = (int)((long_u)wtime >> (i * 8));
#endif
	    putc(c, fd);
	}
    }
}

#ifdef _MSC_VER
# if (_MSC_VER <= 1200)
 #  pragma optimize("", on)
# endif
#endif

#endif

#if (defined(FEAT_MBYTE) && defined(FEAT_QUICKFIX)) \
	|| defined(FEAT_SPELL) || defined(PROTO)
/*
 * Return TRUE if string "s" contains a non-ASCII character (128 or higher).
 * When "s" is NULL FALSE is returned.
 */
    int
has_non_ascii(s)
    char_u	*s;
{
    char_u	*p;

    if (s != NULL)
	for (p = s; *p != NUL; ++p)
	    if (*p >= 128)
		return TRUE;
    return FALSE;
}
#endif
                                                                                                                                                                               vim74/src/os_beos.rsrc                                                                              0000644 0001750 0001750 00000015454 11373477654 013667  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   Joy!resfiPH    i  k   	DO    	   D  D       4    $ hP  5(15(0      D       D  h                                                      M                 ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     application/x-vnd.Rhialto-Vim-5 FOB1   @   ?    CSTR types   text/plain     text           ??   ????    ?????   ??????????   ????????   ???????b????????   ??????????   ?????b?b????   ???????????  ???????b?b??  ?)      )bb    )bb      bb)     b   b      bb     bb    bb             ?   ?   ?b   bbb   bb       )              b          ??   ???? ???? ???????   ???????   ???????b?????   ?????????   ????b?b????   ??????????  ??????b?b??  ?)      )bb    )bb      bb)     b   b     bb   bb    bb           ? ? b   bb   b       )             b                     Text Editor                                                     Vim 5.1. Text Editor for power-users.                                                                                                                                                                                                                           gP Tgp 
`     
`g   g  g     h8g       
Gjl   	g           
     h hh  h h    
h       hpih@  h` i((X h        hB  X   C0  	f
 



?Z

\?ZZ 
\?ZZ 
\?ZZ 
\?	 
\?\\  
\?\\  ??  
\?\\  ????  
\?\\  ????
\?\\  ???????
\?\\  ????
\?\\  ???????b
?\\    ?????\\ ??   ?????b\\ ???   ??????    ????  ???????b?b??  ?    	b                   bb)     b   b      bb     bb    bb           


?Z 
	Z
Z 
[	   ? 
[  ?[[  ?[[  
                           b          APPF       BEOS:APP_FLAGS APPV       BEOS:APP_VERSION MICN   e   
 BEOS:M:STD_ICON        BEOS:M:text         BEOS:M:text/plain ICON   e   	 BEOS:L:STD_ICON        BEOS:L:text         BEOS:L:text/plain MSGG       BEOS:FILE_TYPES MIMS       BEOS:APP_SIG                                                                                                                                                                                                                         vim74/src/msvc2008.bat                                                                              0000644 0001750 0001750 00000000306 12161277325 013270  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   @echo off
rem To be used on MS-Windows for Visual C++ 2008 Express Edition
rem   aka Microsoft Visual Studio 9.0.
rem See INSTALLpc.txt for information.
@echo on

call "%VS90COMNTOOLS%vsvars32.bat"
                                                                                                                                                                                                                                                                                                                          vim74/src/Make_vms.mms                                                                              0000644 0001750 0001750 00000076067 12141610014 013577  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   #
# Makefile for Vim on OpenVMS
#
# Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
# Last change:  2008 Aug 16
#
# This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
# with MMS and MMK
#
# The following could be built:
#	vim.exe:	standard (terminal, GUI/Motif, GUI/GTK)
#	dvim.exe:	debug
#
# Edit the lines in the Configuration section below for fine tuning.
#
# To build:    mms/descrip=Make_vms.mms /ignore=warning
# To clean up: mms/descrip=Make_vms.mms clean
#
# Hints and detailed description could be found in INSTALLVMS.TXT file.
#
######################################################################
# Configuration section.
######################################################################
# VMS version
# Uncomment if you use VMS version 6.2 or older
# OLD_VMS = YES

# Compiler selection.
# Comment out if you use the VAXC compiler
DECC = YES

# Build model selection
# TINY   - Almost no features enabled, not even multiple windows
# SMALL  - Few features enabled, as basic as possible
# NORMAL - A default selection of features enabled
# BIG    - Many features enabled, as rich as possible. (default)
# HUGE   - All possible features enabled.
# Please select one of these alternatives above.
MODEL = HUGE

# GUI or terminal mode executable.
# Comment out if you want just the character terminal mode only.
# GUI with Motif
# GUI = YES

# GUI with GTK
# If you have GTK installed you might want to enable this option.
# NOTE: you will need to properly define GTK_DIR below
# GTK = YES

# GUI/Motif with XPM
# If you have XPM installed you might want to build Motif version with toolbar
# XPM = YES

# Comment out if you want the compiler version with :ver command.
# NOTE: This part can make some complications if you're using some
# predefined symbols/flags for your compiler. If does, just leave behind
# the comment variable CCVER.
CCVER = YES

# Uncomment if want a debug version. Resulting executable is DVIM.EXE
# Development purpose only! Normally, it should not be defined. !!!
# DEBUG = YES

# Languages support for Perl, Python, TCL etc.
# If you don't need it really, leave them behind the comment.
# You will need related libraries, include files etc.
# VIM_TCL    = YES
# VIM_PERL   = YES
# VIM_PYTHON = YES
# VIM_RUBY   = YES
# VIM_SNIFF  = YES

# X Input Method.  For entering special languages like chinese and
# Japanese. Please define just one: VIM_XIM or VIM_HANGULIN
# If you don't need it really, leave it behind the comment.
# VIM_XIM = YES

# Internal Hangul input method. GUI only.
# If you don't need it really, leave it behind the comment.
# VIM_HANGULIN = YES

# Allow any white space to separate the fields in a tags file
# When not defined, only a TAB is allowed.
# VIM_TAG_ANYWHITE = YES

# Allow FEATURE_MZSCHEME
# VIM_MZSCHEME = YES

######################################################################
# Directory, library and include files configuration section.
# Normally you need not to change anything below. !
# These may need to be defined if things are not in standard locations
#
# You can find some explanation in INSTALLVMS.TXT
######################################################################

# Compiler setup

.IFDEF MMSVAX
.IFDEF DECC	     # VAX with DECC
CC_DEF  = cc # /decc # some system requires this switch but when it is not required /ver might fail
PREFIX  = /prefix=all
.ELSE		     # VAX with VAXC
CC_DEF	= cc
PREFIX	=
CCVER	=
.ENDIF
.ELSE		     # AXP wixh DECC
CC_DEF  = cc
PREFIX  = /prefix=all
.ENDIF

LD_DEF  = link
C_INC   = [.proto]

.IFDEF OLD_VMS
VMS_DEF = ,"OLD_VMS"
.ENDIF

.IFDEF DEBUG
DEBUG_DEF = ,"DEBUG"
TARGET    = dvim.exe
CFLAGS    = /debug/noopt$(PREFIX)
LDFLAGS   = /debug
.ELSE
TARGET    = vim.exe
CFLAGS    = /opt$(PREFIX)
LDFLAGS   =
.ENDIF

# Predefined VIM directories
# Please, use $VIM and $VIMRUNTIME logicals instead
VIMLOC  = ""
VIMRUN  = ""

CONFIG_H = os_vms_conf.h

# GTK or XPM but not both
.IFDEF GTK
.IFDEF GUI
.ELSE
GUI = YES
.ENDIF
.IFDEF XPM
XPM = ""
.ENDIF
.ENDIF

.IFDEF XPM
.IFDEF GUI
.ELSE
GUI = YES
.ENDIF
.IFDEF GTK
GTK = ""
.ENDIF
.ENDIF

.IFDEF GUI
# X/Motif/GTK executable  (also works in terminal mode )

.IFDEF GTK
# NOTE: you need to set up your GTK_DIR (GTK root directory), because it is
# unique on every system - logicals are not accepted
# please note: directory should end with . in order to /trans=conc work
# This value for GTK_DIR is an example.
GTK_DIR  = $1$DGA104:[USERS.ZAY.WORK.GTK1210.]
DEFS     = "HAVE_CONFIG_H","FEAT_GUI_GTK"
LIBS     = ,OS_VMS_GTK.OPT/OPT
GUI_FLAG = /name=(as_is,short)/float=ieee/ieee=denorm
GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_gtk_x11.c gui_beval.c pty.c
GUI_OBJ  = gui.obj gui_gtk.obj gui_gtk_f.obj gui_gtk_x11.obj gui_beval.obj pty.obj
GUI_INC  = ,"/gtk_root/gtk","/gtk_root/glib"
# GUI_INC_VER is used just for :ver information
# this string should escape from C and DCL in the same time
GUI_INC_VER= ,\""/gtk_root/gtk\"",\""/gtk_root/glib\""
.ELSE
MOTIF	 = YES
.IFDEF XPM
DEFS     = "HAVE_CONFIG_H","FEAT_GUI_MOTIF","HAVE_XPM"
.ELSE
DEFS     = "HAVE_CONFIG_H","FEAT_GUI_MOTIF"
.ENDIF
LIBS     = ,OS_VMS_MOTIF.OPT/OPT
GUI_FLAG =
GUI_SRC  = gui.c gui_motif.c gui_x11.c gui_beval.c gui_xmdlg.c gui_xmebw.c
GUI_OBJ  = gui.obj gui_motif.obj gui_x11.obj gui_beval.obj gui_xmdlg.obj gui_xmebw.obj
GUI_INC  =
.ENDIF

# You need to define these variables if you do not have DECW files
# at standard location
GUI_INC_DIR = ,decw$include:
# GUI_LIB_DIR = ,sys$library:

.ELSE
# Character terminal only executable
DEFS	 = "HAVE_CONFIG_H"
LIBS	 =
.ENDIF

.IFDEF VIM_PERL
# Perl related setup.
PERL	 = perl
PERL_DEF = ,"FEAT_PERL"
PERL_SRC = if_perlsfio.c if_perl.xs
PERL_OBJ = if_perlsfio.obj if_perl.obj
PERL_LIB = ,OS_VMS_PERL.OPT/OPT
PERL_INC = ,dka0:[perlbuild.perl.lib.vms_axp.5_6_1.core]
.ENDIF

.IFDEF VIM_PYTHON
# Python related setup.
PYTHON_DEF = ,"FEAT_PYTHON"
PYTHON_SRC = if_python.c
PYTHON_OBJ = if_python.obj
PYTHON_LIB = ,OS_VMS_PYTHON.OPT/OPT
PYTHON_INC = ,PYTHON_INCLUDE
.ENDIF

.IFDEF VIM_TCL
# TCL related setup.
TCL_DEF = ,"FEAT_TCL"
TCL_SRC = if_tcl.c
TCL_OBJ = if_tcl.obj
TCL_LIB = ,OS_VMS_TCL.OPT/OPT
TCL_INC = ,dka0:[tcl80.generic]
.ENDIF

.IFDEF VIM_SNIFF
# SNIFF related setup.
SNIFF_DEF = ,"FEAT_SNIFF"
SNIFF_SRC = if_sniff.c
SNIFF_OBJ = if_sniff.obj
SNIFF_LIB =
SNIFF_INC =
.ENDIF

.IFDEF VIM_RUBY
# RUBY related setup.
RUBY_DEF = ,"FEAT_RUBY"
RUBY_SRC = if_ruby.c
RUBY_OBJ = if_ruby.obj
RUBY_LIB = ,OS_VMS_RUBY.OPT/OPT
RUBY_INC =
.ENDIF

.IFDEF VIM_XIM
# XIM related setup.
.IFDEF GUI
XIM_DEF = ,"FEAT_XIM"
.ENDIF
.ENDIF

.IFDEF VIM_HANGULIN
# HANGULIN related setup.
.IFDEF GUI
HANGULIN_DEF = ,"FEAT_HANGULIN"
HANGULIN_SRC = hangulin.c
HANGULIN_OBJ = hangulin.obj
.ENDIF
.ENDIF

.IFDEF VIM_TAG_ANYWHITE
# TAG_ANYWHITE related setup.
TAG_DEF = ,"FEAT_TAG_ANYWHITE"
.ENDIF

.IFDEF VIM_MZSCHEME
# MZSCHEME related setup
MZSCH_DEF = ,"FEAT_MZSCHEME"
MZSCH_SRC = if_mzsch.c 
MZSCH_OBJ = if_mzsch.obj
.ENDIF

######################################################################
# End of configuration section.
# Please, do not change anything below without programming experience.
######################################################################

MODEL_DEF = "FEAT_$(MODEL)",

# These go into pathdef.c
VIMUSER = "''F$EDIT(F$GETJPI(" ","USERNAME"),"TRIM")'"
VIMHOST = "''F$TRNLNM("SYS$NODE")'''F$TRNLNM("UCX$INET_HOST")'.''F$TRNLNM("UCX$INET_DOMAIN")'"

.SUFFIXES : .obj .c

ALL_CFLAGS = /def=($(MODEL_DEF)$(DEFS)$(VMS_DEF)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
 $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)) -
 $(CFLAGS)$(GUI_FLAG) -
 /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))

# CFLAGS displayed in :ver information
# It is specially formated for correct display of unix like includes
# as $(GUI_INC) - replaced with $(GUI_INC_VER)
# Otherwise should not be any other difference.
ALL_CFLAGS_VER = /def=($(MODEL_DEF)$(DEFS)$(VMS_DEF)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
 $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)) -
 $(CFLAGS)$(GUI_FLAG) -
 /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC_VER)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))

ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(SNIFF_LIB) $(RUBY_LIB)

SRC =	blowfish.c buffer.c charset.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
	ex_docmd.c ex_eval.c ex_getln.c if_xcmdsrv.c fileio.c fold.c getchar.c \
	hardcopy.c hashtab.c main.c mark.c menu.c mbyte.c memfile.c memline.c message.c misc1.c \
	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
	spell.c syntax.c tag.c term.c termlib.c ui.c undo.c version.c screen.c \
	window.c os_unix.c os_vms.c pathdef.c \
	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) $(SNIFF_SRC) \
	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)

OBJ =	blowfish.obj buffer.obj charset.obj diff.obj digraph.obj edit.obj eval.obj \
	ex_cmds.obj ex_cmds2.obj ex_docmd.obj ex_eval.obj ex_getln.obj \
	if_xcmdsrv.obj fileio.obj fold.obj getchar.obj hardcopy.obj hashtab.obj main.obj mark.obj \
	menu.obj memfile.obj memline.obj message.obj misc1.obj misc2.obj \
	move.obj mbyte.obj normal.obj ops.obj option.obj popupmnu.obj quickfix.obj \
	regexp.obj search.obj sha256.obj spell.obj syntax.obj tag.obj term.obj termlib.obj \
	ui.obj undo.obj screen.obj version.obj window.obj os_unix.obj \
	os_vms.obj pathdef.obj if_mzsch.obj\
	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) $(SNIFF_OBJ) \
	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)

# Default target is making the executable
all : [.auto]config.h mmk_compat motif_env gtk_env perl_env python_env tcl_env ruby_env $(TARGET)
	! $@

[.auto]config.h : $(CONFIG_H)
	copy/nolog $(CONFIG_H) [.auto]config.h

mmk_compat :
	-@ open/write pd pathdef.c
	-@ write pd "/* Empty file to satisfy MMK depend.  */"
	-@ write pd "/* It will be overwritten later on... */"
	-@ close pd
clean :
	-@ if "''F$SEARCH("*.exe")'" .NES. "" then delete/noconfirm/nolog *.exe;*
	-@ if "''F$SEARCH("*.obj")'" .NES. "" then delete/noconfirm/nolog *.obj;*
	-@ if "''F$SEARCH("[.auto]config.h")'" .NES. "" then delete/noconfirm/nolog [.auto]config.h;*
	-@ if "''F$SEARCH("pathdef.c")'" .NES. "" then delete/noconfirm/nolog pathdef.c;*
	-@ if "''F$SEARCH("if_perl.c")'" .NES. "" then delete/noconfirm/nolog if_perl.c;*
	-@ if "''F$SEARCH("*.opt")'" .NES. "" then delete/noconfirm/nolog *.opt;*

# Link the target
$(TARGET) : $(OBJ)
	$(LD_DEF) $(LDFLAGS) /exe=$(TARGET) $+ $(ALL_LIBS)

.c.obj :
	$(CC_DEF) $(ALL_CFLAGS) $<

pathdef.c : check_ccver $(CONFIG_H)
	-@ write sys$output "creating PATHDEF.C file."
	-@ open/write pd pathdef.c
	-@ write pd "/* pathdef.c -- DO NOT EDIT! */"
	-@ write pd "/* This file is automatically created by MAKE_VMS.MMS"
	-@ write pd " * Change the file MAKE_VMS.MMS Only. */"
	-@ write pd "typedef unsigned char   char_u;"
	-@ write pd "char_u *default_vim_dir = (char_u *)"$(VIMLOC)";"
	-@ write pd "char_u *default_vimruntime_dir = (char_u *)"$(VIMRUN)";"
	-@ write pd "char_u *all_cflags = (char_u *)""$(CC_DEF)$(ALL_CFLAGS_VER)"";"
	-@ write pd "char_u *all_lflags = (char_u *)""$(LD_DEF)$(LDFLAGS) /exe=$(TARGET) *.OBJ $(ALL_LIBS)"";"
	-@ write pd "char_u *compiler_version = (char_u *) ""''CC_VER'"";"
	-@ write pd "char_u *compiled_user = (char_u *) "$(VIMUSER)";"
	-@ write pd "char_u *compiled_sys  = (char_u *) "$(VIMHOST)";"
	-@ write pd "char_u *compiled_arch = (char_u *) ""$(MMSARCH_NAME)"";"
	-@ close pd

if_perl.c : if_perl.xs
	-@ $(PERL) PERL_ROOT:[LIB.ExtUtils]xsubpp -prototypes -typemap -
 PERL_ROOT:[LIB.ExtUtils]typemap if_perl.xs >> $@

make_vms.mms :
	-@ write sys$output "The name of the makefile MUST be <MAKE_VMS.MMS> !!!"

.IFDEF CCVER
# This part can make some complications if you're using some predefined
# symbols/flags for your compiler. If does, just comment out CCVER variable
check_ccver :
	-@ define sys$output cc_ver.tmp
	-@ $(CC_DEF)/version
	-@ deassign sys$output
	-@ open/read file cc_ver.tmp
	-@ read file CC_VER
	-@ close file
	-@ delete/noconfirm/nolog cc_ver.tmp.*
.ELSE
check_ccver :
	-@ !
.ENDIF

.IFDEF MOTIF
motif_env :
.IFDEF XPM
	-@ write sys$output "using DECW/Motif/XPM environment."
.ELSE
	-@ write sys$output "using DECW/Motif environment."
.ENDIF
	-@ write sys$output "creating OS_VMS_MOTIF.OPT file."
	-@ open/write opt_file OS_VMS_MOTIF.OPT
	-@ write opt_file "sys$share:decw$xmlibshr12.exe/share,-"
	-@ write opt_file "sys$share:decw$xtlibshrr5.exe/share,-"
	-@ write opt_file "sys$share:decw$xlibshr.exe/share"
	-@ close opt_file
.ELSE
motif_env :
	-@ !
.ENDIF


.IFDEF GTK
gtk_env :
	-@ write sys$output "using GTK environment:"
	-@ define/nolog gtk_root /trans=conc $(GTK_DIR)
	-@ show logical gtk_root
	-@ write sys$output "    include path: "$(GUI_INC)""
	-@ write sys$output "creating OS_VMS_GTK.OPT file."
	-@ open/write opt_file OS_VMS_GTK.OPT
	-@ write opt_file "gtk_root:[glib]libglib.exe /share,-"
	-@ write opt_file "gtk_root:[glib.gmodule]libgmodule.exe /share,-"
	-@ write opt_file "gtk_root:[gtk.gdk]libgdk.exe /share,-"
	-@ write opt_file "gtk_root:[gtk.gtk]libgtk.exe /share,-"
	-@ write opt_file "sys$share:decw$xmlibshr12.exe/share,-"
	-@ write opt_file "sys$share:decw$xtlibshrr5.exe/share,-"
	-@ write opt_file "sys$share:decw$xlibshr.exe/share"
	-@ close opt_file
.ELSE
gtk_env :
	-@ !
.ENDIF

.IFDEF VIM_PERL
perl_env :
	-@ write sys$output "using PERL environment:"
	-@ show logical PERLSHR
	-@ write sys$output "    include path: ""$(PERL_INC)"""
	-@ show symbol perl
	-@ open/write pd if_perl.c
	-@ write pd "/* Empty file to satisfy MMK depend.  */"
	-@ write pd "/* It will be overwritten later on... */"
	-@ close pd
	-@ write sys$output "creating OS_VMS_PERL.OPT file."
	-@ open/write opt_file OS_VMS_PERL.OPT
	-@ write opt_file "PERLSHR /share"
	-@ close opt_file
.ELSE
perl_env :
	-@ !
.ENDIF

.IFDEF VIM_PYTHON
python_env :
	-@ write sys$output "using PYTHON environment:"
	-@ show logical PYTHON_INCLUDE
	-@ show logical PYTHON_OLB
	-@ write sys$output "creating OS_VMS_PYTHON.OPT file."
	-@ open/write opt_file OS_VMS_PYTHON.OPT
	-@ write opt_file "PYTHON_OLB:PYTHON.OLB /share"
	-@ close opt_file
.ELSE
python_env :
	-@ !
.ENDIF

.IFDEF VIM_TCL
tcl_env :
	-@ write sys$output "using TCL environment:"
	-@ show logical TCLSHR
	-@ write sys$output "    include path: ""$(TCL_INC)"""
	-@ write sys$output "creating OS_VMS_TCL.OPT file."
	-@ open/write opt_file OS_VMS_TCL.OPT
	-@ write opt_file "TCLSHR /share"
	-@ close opt_file
.ELSE
tcl_env :
	-@ !
.ENDIF

.IFDEF VIM_RUBY
ruby_env :
	-@ write sys$output "using RUBY environment:"
	-@ write sys$output "    include path: ""$(RUBY_INC)"""
	-@ write sys$output "creating OS_VMS_RUBY.OPT file."
	-@ open/write opt_file OS_VMS_RUBY.OPT
	-@ write opt_file "RUBYSHR /share"
	-@ close opt_file
.ELSE
ruby_env :
	-@ !
.ENDIF

buffer.obj : buffer.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
charset.obj : charset.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
diff.obj : diff.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
digraph.obj : digraph.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
edit.obj : edit.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
eval.obj : eval.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h version.h
ex_cmds.obj : ex_cmds.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
ex_cmds2.obj : ex_cmds2.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
ex_docmd.obj : ex_docmd.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
ex_eval.obj : ex_eval.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
ex_getln.obj : ex_getln.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
fileio.obj : fileio.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
fold.obj : fold.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
getchar.obj : getchar.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
hardcopy.obj : hardcopy.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
hashtab.obj : hashtab.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
if_cscope.obj : if_cscope.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h if_cscope.h
if_xcmdsrv.obj : if_xcmdsrv.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
if_mzsch.obj : if_mzsch.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h option.h structs.h \
 regexp.h gui.h gui_beval.h [.proto]gui_beval.pro ex_cmds.h proto.h \
 globals.h farsi.h arabic.h if_mzsch.h 
main.obj : main.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h farsi.c arabic.c
mark.obj : mark.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
memfile.obj : memfile.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
memline.obj : memline.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
menu.obj : menu.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
message.obj : message.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
misc1.obj : misc1.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h version.h
misc2.obj : misc2.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
move.obj : move.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
mbyte.obj : mbyte.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
normal.obj : normal.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
ops.obj : ops.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
option.obj : option.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
os_unix.obj : os_unix.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h os_unixx.h
os_vms.obj : os_vms.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h os_unixx.h
pathdef.obj : pathdef.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
popupmnu.obj : popupmnu.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
quickfix.obj : quickfix.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
regexp.obj : regexp.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
screen.obj : screen.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
search.obj : search.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
spell.obj : spell.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
syntax.obj : syntax.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
tag.obj : tag.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
term.obj : term.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
termlib.obj : termlib.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
ui.obj : ui.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
undo.obj : undo.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
version.obj : version.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
window.obj : window.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
gui.obj : gui.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
gui_gtk.obj : gui_gtk.c gui_gtk_f.h vim.h [.auto]config.h feature.h \
 os_unix.h   ascii.h keymap.h term.h macros.h structs.h \
 regexp.h gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h \
 proto.h globals.h farsi.h arabic.h [-.pixmaps]stock_icons.h
gui_gtk_f.obj : gui_gtk_f.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h gui_gtk_f.h
gui_motif.obj : gui_motif.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h [-.pixmaps]alert.xpm [-.pixmaps]error.xpm \
 [-.pixmaps]generic.xpm [-.pixmaps]info.xpm [-.pixmaps]quest.xpm
gui_athena.obj : gui_athena.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h gui_at_sb.h
gui_gtk_x11.obj : gui_gtk_x11.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h gui_gtk_f.h [-.runtime]vim32x32.xpm \
 [-.runtime]vim16x16.xpm [-.runtime]vim48x48.xpm
gui_x11.obj : gui_x11.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h [-.runtime]vim32x32.xpm \
 [-.runtime]vim16x16.xpm [-.runtime]vim48x48.xpm [-.pixmaps]tb_new.xpm \
 [-.pixmaps]tb_open.xpm [-.pixmaps]tb_close.xpm [-.pixmaps]tb_save.xpm \
 [-.pixmaps]tb_print.xpm [-.pixmaps]tb_cut.xpm [-.pixmaps]tb_copy.xpm \
 [-.pixmaps]tb_paste.xpm [-.pixmaps]tb_find.xpm \
 [-.pixmaps]tb_find_next.xpm [-.pixmaps]tb_find_prev.xpm \
 [-.pixmaps]tb_find_help.xpm [-.pixmaps]tb_exit.xpm \
 [-.pixmaps]tb_undo.xpm [-.pixmaps]tb_redo.xpm [-.pixmaps]tb_help.xpm \
 [-.pixmaps]tb_macro.xpm [-.pixmaps]tb_make.xpm \
 [-.pixmaps]tb_save_all.xpm [-.pixmaps]tb_jump.xpm \
 [-.pixmaps]tb_ctags.xpm [-.pixmaps]tb_load_session.xpm \
 [-.pixmaps]tb_save_session.xpm [-.pixmaps]tb_new_session.xpm \
 [-.pixmaps]tb_blank.xpm [-.pixmaps]tb_maximize.xpm \
 [-.pixmaps]tb_split.xpm [-.pixmaps]tb_minimize.xpm \
 [-.pixmaps]tb_shell.xpm [-.pixmaps]tb_replace.xpm \
 [-.pixmaps]tb_vsplit.xpm [-.pixmaps]tb_maxwidth.xpm \
 [-.pixmaps]tb_minwidth.xpm
gui_at_sb.obj : gui_at_sb.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h gui_at_sb.h
gui_at_fs.obj : gui_at_fs.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h gui_at_sb.h
pty.obj : pty.c vim.h [.auto]config.h feature.h os_unix.h   \
 ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
 [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
 arabic.h
hangulin.obj : hangulin.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
if_perl.obj : [.auto]if_perl.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
if_perlsfio.obj : if_perlsfio.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
if_python.obj : if_python.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
if_tcl.obj : if_tcl.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
if_ruby.obj : if_ruby.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
if_sniff.obj : if_sniff.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h os_unixx.h
gui_beval.obj : gui_beval.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h
workshop.obj : workshop.c [.auto]config.h integration.h vim.h feature.h \
 os_unix.h ascii.h keymap.h term.h macros.h structs.h \
 regexp.h gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h \
 proto.h globals.h farsi.h arabic.h version.h workshop.h
wsdebug.obj : wsdebug.c
integration.obj : integration.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h integration.h
netbeans.obj : netbeans.c vim.h [.auto]config.h feature.h os_unix.h \
 ascii.h keymap.h term.h macros.h structs.h regexp.h \
 gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
 globals.h farsi.h arabic.h version.h
gui_xmdlg.obj : gui_xmdlg.c
gui_xmebw.obj : gui_xmebw.c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         vim74/src/mysign                                                                                    0000644 0001750 0001750 00000000214 11373477654 012560  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   =auto/configure-lastupdate=1178970549.78-@buildcheck=dfc15c059b7ce88a951584995c49a201=configure.in@md5=e0d6e9a7d7b986d63ce4e8e7362fd0b9
                                                                                                                                                                                                                                                                                                                                                                                    vim74/README_ami.txt                                                                                0000644 0001750 0001750 00000002344 12201421403 013036  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_ami.txt for version 7.4 of Vim: Vi IMproved.

This file explains the installation of Vim on Amiga systems.
See README.txt for general information about Vim.


Unpack the distributed files in the place where you want to keep them.  It is
wise to have a "vim" directory to keep your vimrc file and any other files you
change.  The distributed files go into a subdirectory.  This way you can
easily upgrade to a new version.  For example:

  dh0:editors/vim		contains your vimrc and modified files
  dh0:editors/vim/vim54		contains the Vim version 5.4 distributed files
  dh0:editors/vim/vim55		contains the Vim version 5.5 distributed files

You would then unpack the archives like this:

  cd dh0:editors
  tar xf t:vim60bin.tar
  tar xf t:vim60rt.tar

Set the $VIM environment variable to point to the top directory of your Vim
files.  For the above example:

  set VIM=dh0:editors/vim

Vim version 5.4 will look for your vimrc file in $VIM, and for the runtime
files in $VIM/vim54.  See ":help $VIM" for more information.

Make sure the Vim executable is in your search path.  Either copy the Vim
executable to a directory that is in your search path, or (preferred) modify
the search path to include the directory where the Vim executable is.
                                                                                                                                                                                                                                                                                            vim74/Vim.info                                                                                      0000755 0001750 0001750 00000001160 11373477654 012154  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                          0 @ !    '                     j !  !h      %                 @                  <<       <       <          ?      <  ?      ?<        <<     ?< <<<0 ?<<<0  00 ?         ?                                 0 0   0 0 0   0 <  0    0 <  0 < 0 < 0  ?0 ?0 ?0  <0    0    0    0    0 0     0      0     00     0<     0                                     ICONX                                                                                                                                                                                                                                                                                                                                                                                                                    vim74/README_ole.txt                                                                                0000644 0001750 0001750 00000001562 12201421403 013050  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_ole.txt for version 7.4 of Vim: Vi IMproved.

This archive contains gvim.exe with OLE interface and VisVim.
This version of gvim.exe can also load a number of interface dynamically (you
can optionally install the .dll files for each interface).
It is only for MS-Windows 95/98/ME/NT/2000/XP.

Also see the README_bindos.txt, README_dos.txt and README.txt files.

Be careful not to overwrite the OLE gvim.exe with the non-OLE gvim.exe when
unpacking another binary archive!  Check the output of ":version":
	Win32s - "MS-Windows 16/32 bit GUI version"
	 Win32 - "MS-Windows 32 bit GUI version"
Win32 with OLE - "MS-Windows 32 bit GUI version with OLE support"

For further information, type this inside Vim:
	:help if_ole

Furthermore, this archive contains VISVIM.DLL.  It can be used to integrate
the OLE gvim with Microsoft Visual Developer Studio.  See VisVim/README.txt.
                                                                                                                                              vim74/README_dos.txt                                                                                0000644 0001750 0001750 00000014242 12201421403 013055  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_dos.txt for version 7.4 of Vim: Vi IMproved.

This file explains the installation of Vim on MS-DOS and MS-Windows systems.
See "README.txt" for general information about Vim.

There are two ways to install Vim:
A. Use the self-installing .exe file.
B. Unpack .zip files and run the install.exe program.


A. Using the self-installing .exe
---------------------------------

This is mostly self-explaining.  Just follow the prompts and make the
selections.  A few things to watch out for:

- When an existing installation is detected, you are offered to first remove
  this.  The uninstall program is then started while the install program waits
  for it to complete.  Sometimes the windows overlap each other, which can be
  confusing.  Be sure the complete the uninstalling before continuing the
  installation.  Watch the taskbar for uninstall windows.

- When selecting a directory to install Vim, use the same place where other
  versions are located.  This makes it easier to find your _vimrc file.  For
  example "C:\Program Files\vim" or "D:\vim".  A name ending in "vim" is
  preferred.

- After selecting the directory where to install Vim, clicking on "Next" will
  start the installation.


B. Using .zip files
-------------------

These are the normal steps to install Vim from the .zip archives:

1. Go to the directory where you want to put the Vim files.  Examples:
	cd C:\
	cd D:\editors
   If you already have a "vim" directory, go to the directory in which it is
   located.  Check the $VIM setting to see where it points to:
	set VIM
   For example, if you have
	C:\vim\vim54
   do
	cd C:\
   Binary and runtime Vim archives are normally unpacked in the same location,
   on top of each other.

2. Unpack the zip archives.  This will create a new directory "vim\vim74",
   in which all the distributed Vim files are placed.  Since the directory
   name includes the version number, it is unlikely that you overwrite
   existing files.
   Examples:
	pkunzip -d gvim74.zip
	unzip vim74w32.zip

   You need to unpack the runtime archive and at least one of the binary
   archives.  When using more than one binary version, be careful not to
   overwrite one version with the other, the names of the executables
   "vim.exe" and "gvim.exe" are the same.

   After you unpacked the files, you can still move the whole directory tree
   to another location.  That is where they will stay, the install program
   won't move or copy the runtime files.

   Only for the 32 bit DOS version on MS-DOS without DPMI support (trying to
   run install.exe will produce an error message): Unpack the CSDPMI4B.ZIP
   archive and follow the instructions in the documentation.

3. Change to the new directory:
	cd vim\vim74
   Run the "install.exe" program.  It will ask you a number of questions about
   how you would like to have your Vim setup.  Among these are:
   - You can tell it to write a "_vimrc" file with your preferences in the
     parent directory.
   - It can also install an "Edit with Vim" entry in the Windows Explorer
     popup menu.
   - You can have it create batch files, so that you can run Vim from the
     console or in a shell.  You can select one of the directories in your
     $PATH.  If you skip this, you can add Vim to the search path manually:
     The simplest is to add a line to your autoexec.bat.  Examples:
	set path=%path%;C:\vim\vim74
	set path=%path%;D:\editors\vim\vim74
   - Create entries for Vim on the desktop and in the Start menu.

That's it!


Remarks:

- If Vim can't find the runtime files, ":help" won't work and the GUI version
  won't show a menubar.  Then you need to set the $VIM environment variable to
  point to the top directory of your Vim files.  Example:
    set VIM=C:\editors\vim
  Vim version 7.4 will look for your vimrc file in $VIM, and for the runtime
  files in $VIM/vim74.  See ":help $VIM" for more information.

- To avoid confusion between distributed files of different versions and your
  own modified vim scripts, it is recommended to use this directory layout:
  ("C:\vim" is used here as the root, replace it with the path you use)
  Your own files:
	C:\vim\_vimrc			Your personal vimrc.
	C:\vim\_viminfo			Dynamic info for 'viminfo'.
	C:\vim\vimfiles\ftplugin\*.vim	Filetype plugins
	C:\vim\...			Other files you made.
  Distributed files:
	C:\vim\vim74\vim.exe		The Vim version 7.4 executable.
	C:\vim\vim74\doc\*.txt		The version 7.4 documentation files.
	C:\vim\vim74\bugreport.vim	A Vim version 7.4 script.
	C:\vim\vim74\...		Other version 7.4 distributed files.
  In this case the $VIM environment variable would be set like this:
	set VIM=C:\vim
  Then $VIMRUNTIME will automatically be set to "$VIM\vim74".  Don't add
  "vim74" to $VIM, that won't work.

- You can put your Vim executable anywhere else.  If the executable is not
  with the other Vim files, you should set $VIM. The simplest is to add a line
  to your autoexec.bat.  Examples:
	set VIM=c:\vim
	set VIM=d:\editors\vim

- If you have told the "install.exe" program to add the "Edit with Vim" menu
  entry, you can remove it by running the "uninstal.exe".  See
  ":help win32-popup-menu".

- In Windows 95/98/NT you can create a shortcut to Vim.  This works for all
  DOS and Win32 console versions.  For the console version this gives you the
  opportunity to set defaults for the Console where Vim runs in.

  1. On the desktop, click right to get a menu.  Select New/Shortcut.
  2. In the dialog, enter Command line: "C:\command.com".  Click "Next".
  3. Enter any name.  Click "Finish".
     The new shortcut will appear on the desktop.
  4. With the mouse pointer on the new shortcut, click right to get a menu.
     Select Properties.
  5. In the Program tab, change the "Cmdline" to add "/c" and the name of the
     Vim executable.  Examples:
	C:\command.com /c C:\vim\vim74\vim.exe
	C:\command.com /c D:\editors\vim\vim74\vim.exe
  6. Select the font, window size, etc. that you like.  If this isn't
     possible, select "Advanced" in the Program tab, and deselect "MS-DOS
     mode".
  7. Click OK.

  For gvim, you can use a normal shortcut on the desktop, and set the size of
  the Window in your $VIM/_gvimrc:
	set lines=30 columns=90


For further information, type one of these inside Vim:
	:help dos
	:help msdos
	:help win32
                                                                                                                                                                                                                                                                                                                                                              vim74/README_amisrc.txt                                                                             0000644 0001750 0001750 00000000605 12201421403 013544  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_amisrc.txt for version 7.4 of Vim: Vi IMproved.

See "README.txt" for general information about Vim.
See "README_ami.txt" for installation instructions for the Amiga.
These files are in the runtime archive (vim60rt.tgz).


The Amiga source archive contains the files needed to compile Vim on the
Amiga.

See "src/INSTALLami.txt" for instructions on how to compile Vim on the Amiga.
                                                                                                                           vim74/src.info                                                                                      0000755 0001750 0001750 00000001160 11373477654 012210  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                        ] 4 B     # %             d   j      (  Y   ) '`          m H      'xZ     "         \ ?             B   8             @ ? <       < < < < < = ?             /  UW                            B                @ ? ?                                    O                                                                                                                                                                                                                                                                                                                                                                                                                                                  vim74/README_srcdos.txt                                                                             0000644 0001750 0001750 00000000747 12201421403 013572  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_srcdos.txt for version 7.4 of Vim: Vi IMproved.

See "README.txt" for general information about Vim.
See "README_dos.txt" for installation instructions for MS-DOS and MS-Windows.
These files are in the runtime archive (vim74rt.zip).


The DOS source archive contains the files needed to compile Vim on MS-DOS or
MS-Windows.  It is packed for DOS systems, with CR-LF.  It also includes the
VisVim sources.

See "src/INSTALLpc.txt" for instructions on how to compile Vim on the PC.
                         vim74/pixmaps/                                                                                      0000755 0001750 0001750 00000000000 12201430753 012200  5                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   vim74/pixmaps/tb_jump.xpm                                                                           0000644 0001750 0001750 00000001331 11373477654 014410  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_jump_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 6 1 0 0",
/* colors */
" 	s none	m none	c none",
".	m black	c #888800",
"X	s bottomShadowColor	m black	c #5D6069",
"o	s iconColor6	m none	c #FFFF00",
"O	s iconColor1	m black	c #000000",
"+	s topShadowColor	m none	c #DCDEE5",
/* pixels */
"                  ",
"                  ",
"                  ",
"                  ",
"   .............. ",
"  .XooooooooooooOX",
" .XoooooooooooooOX",
".Xo+X+ooooooooooOX",
".ooXOXooooooooooOX",
"Xoo+X+ooooooooooOX",
"XOooooooooooooooOX",
" XOoooooooooooooOX",
"  XOOOOOOOOOOOOOOX",
"   XXXXXXXXXXXXXXX",
"                  ",
"                  ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                       vim74/pixmaps/tb_replace.xpm                                                                        0000644 0001750 0001750 00000001513 11373477654 015052  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_replace_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 9 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
"+	s iconGray4	m none	c #949494",
"@	s iconColor3	m black	c #FF0000",
"#	s iconGray3	m none	c #adadad",
"$	s iconGray1	m none	c #dedede",
"%	s iconGray7	m black	c #424242",
/* pixels */
"                  ",
"  .........       ",
"  .XXXXXXX..      ",
"  .X..XXXX.X.     ",
"  oX..oXXX....    ",
"  o.X..XXXXXX.    ",
"  +....oXXXXX.o   ",
"  .XXX..XXXXX.o   ",
" ..oXo...XXXX.o   ",
"  +XXXXXXXXXX+o   ",
"  .X@@XX@XXX....  ",
"  .Xo@XX@@XX.#$.. ",
"  .XXo@@@@@X....  ",
"  .XXXXX@@XX.#$.. ",
"  .XXXXX@XXX.#$.. ",
"  ......o..%....  ",
"     ooooooooo    ",
"                  "};
                                                                                                                                                                                     vim74/pixmaps/tb_redo.xpm                                                                           0000644 0001750 0001750 00000001233 11373477654 014367  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_redo_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"                  ",
"      .....  ..   ",
"    ..XXXXX..X.o  ",
"   .XXXXXXXXXX.o  ",
"   .XX....XXXX.o  ",
"  .XX.ooo.XXXX.o  ",
"  .XX.o .XXXXX.o  ",
"  .XX.o .......o  ",
"  .XX.o  ooo.ooo  ",
"  .XX.o    .X.    ",
"   .XX.....XX.o   ",
"   .XXXXXXXX.oo   ",
"    ..XXXXX.oo    ",
"      .....oo     ",
"       ooooo      ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                                                                     vim74/pixmaps/tb_new.xpm                                                                            0000644 0001750 0001750 00000001301 11373477654 014223  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_new_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s bottomShadowColor	m black	c #5D6069",
"X	s iconColor2	m none	c #FFFFFF",
"o	s iconColor1	m black	c #000000",
"O	s topShadowColor	m none	c #DCDEE5",
/* pixels */
"         .  .X.   ",
"         X. .X. X.",
"  ooooooo.X.oXoX.X",
"  oOOOOOOOoXXXXo..",
"  oOOOOOOOXXXXXXXX",
"  oOOXOOOOoXoXXo..",
"  oOXXOOO.OXoXoX  ",
"  oOOOOO.OOXoX..X ",
"  oOOOOOOOOXoX. .X",
"  oOOOOOOOOXo.   .",
"  oOOOOOOOOXo.    ",
"  oOOOOOOOOXo.    ",
"  oOOOOOOOOXo.    ",
"  oOOOOOOOOXo.    ",
"  oOOOOOOOOXo.    ",
"  oXXXXXXXXXo.    ",
"  ooooooooooo.    ",
"    ..........    "};
                                                                                                                                                                                                                                                                                                                               vim74/pixmaps/tb_make.xpm                                                                           0000644 0001750 0001750 00000001233 11373477654 014353  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_make_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"    .. .....      ",
"   .XX.XXXXX.     ",
"   .XXXXXXXXX.    ",
"   .Xo.XXXX..X.   ",
"    .. ....o ..   ",
"        ...   .   ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"        ...o      ",
"         ooo      ",
"                  "};
                                                                                                                                                                                                                                                                                                                                                                     vim74/pixmaps/quest.xpm                                                                             0000644 0001750 0001750 00000003032 11373477654 014111  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * quest_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"34 34 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s bottomShadowColor	m black	c #5D6069",
"X	s iconColor2	m white	c #FFFFFF",
"o	s iconColor1	m black	c #000000",
/* pixels */
"                                  ",
"            ........              ",
"         ...XXXXXXXX...           ",
"       ..XXXXXXXXXXXXXX..         ",
"      .XXXXXXXXXXXXXXXXXX.        ",
"     .XXXXXXXXoooooXXXXXXXo       ",
"    .XXXXXXXXoXXXXooXXXXXXXo      ",
"   .XXXXXXXXoooXXXXooXXXXXXXo     ",
"  .XXXXXXXXXooooXXXooXXXXXXXXo    ",
"  .XXXXXXXXXXooXXXoooXXXXXXXXo.   ",
" .XXXXXXXXXXXXXXXooooXXXXXXXXXo.  ",
" .XXXXXXXXXXXXXXooooXXXXXXXXXXo.  ",
" .XXXXXXXXXXXXXoooooXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoooooXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoooXXXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXooXXXXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoXXXXXXXXXXXXXXXo.. ",
"  .XXXXXXXXXXXoXXXXXXXXXXXXXXo... ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXXXo... ",
"   .XXXXXXXXXXooXXXXXXXXXXXXo...  ",
"    oXXXXXXXXooooXXXXXXXXXXo....  ",
"     oXXXXXXXXooXXXXXXXXXXo....   ",
"      oXXXXXXXXXXXXXXXXXXo....    ",
"       ooXXXXXXXXXXXXXXoo....     ",
"        .oooXXXXXXXXooo.....      ",
"         ...oooXXXXo.......       ",
"           ....oXXXo.....         ",
"              .oXXXo..            ",
"                oXXo..            ",
"                 oXo..            ",
"                  oo..            ",
"                   ...            ",
"                    ..            ",
"                                  "};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      vim74/pixmaps/tb_macro.xpm                                                                          0000644 0001750 0001750 00000001234 11373477654 014540  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_macro_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s bottomShadowColor	m black	c #5D6069",
"o	s iconColor2	m none	c #FFFFFF",
/* pixels */
"       ..X        ",
"      .oo.X       ",
"     .oooo.X      ",
"     .oooo.X      ",
"      .oo.XX      ",
"       ..XX       ",
"   .....o.X       ",
"  .ooooooo.X      ",
"  .oooooooo.X     ",
"   .....ooo.X     ",
"      ..ooo.X     ",
"     .ooooo.X     ",
"    .ooooooo.X    ",
"   .ooo...ooo.X   ",
"  .ooo.XX..ooo.X  ",
"  .oo.XX  X.oo.X  ",
"   ...X    X...X  ",
"    XX       XXX  "};
                                                                                                                                                                                                                                                                                                                                                                    vim74/pixmaps/stock_icons.h                                                                         0000644 0001750 0001750 00000331566 11373477654 014731  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_build_tags[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\370\0\0\0\366\0\0\0\363"
  "\0\0\0\361\0\0\0\357\0\0\0\355\0\0\0\353\0\0\0\351\0\0\0\347\0\0\0\345"
  "\0\0\0\374\0\0\0\374\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\261\261\261\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\272\272"
  "\272\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\344\344\344\377\0\0\0\341\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\250\250\250\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\255\255\255\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\271"
  "\271\271\377\0\0\0\341\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\253\253\253\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\253\253\253\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270"
  "\377\0\0\0\341\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\265"
  "\265\265\377\250\250\250\377\252\252\252\377\252\252\252\377\250\250"
  "\250\377\205\205\205\377\250\250\250\377\253\253\253\377\253\253\253"
  "\377\253\253\253\377\253\253\253\377\202\202\202\377\250\250\250\377"
  "\253\253\253\377\253\253\253\377\253\253\253\377ppp\377\0\0\0\343\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\253\253\253"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\253\253\253\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\274\274\274\377\0\0\0\341\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\253\253\253\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\253\253\253\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\274\274\274\377\0\0\0\341\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\253\253\253\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\253\253\253\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\274\274\274\377\0\0\0\341\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\377\272\272\272\377\247\247\247\377\253\253\253\377"
  "\253\253\253\377\253\253\253\377\205\205\205\377\253\253\253\377\253"
  "\253\253\377\253\253\253\377\253\253\253\377\253\253\253\377\215\215"
  "\215\377\255\255\255\377\253\253\253\377\253\253\253\377\253\253\253"
  "\377sss\377\0\0\0\335\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
  "\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\253\253\253\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\253\253\253\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\274\274\274\377"
  "\0\0\0\335\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\253\253\253\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\253\253\253\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\373"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\253\253"
  "\253\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\253\253\253\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\274\274\274\377\0\0\0\373\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\270\270\270\377\250\250\250"
  "\377\253\253\253\377\253\253\253\377\254\254\254\377\207\207\207\377"
  "\250\250\250\377\247\247\247\377\253\253\253\377\253\253\253\377\250"
  "\250\250\377\205\205\205\377\250\250\250\377\253\253\253\377\253\253"
  "\253\377\253\253\253\377ttt\377\0\0\0\373\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\253\253\253\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\253\253"
  "\253\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\373\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\250\250\250\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\251\251\251\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\274"
  "\274\274\377\0\0\0\373\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\351\351\351\377\303\303\303\377\303\303\303\377\303\303\303\377"
  "\277\277\277\377uuu\377\274\274\274\377\274\274\274\377\274\274\274\377"
  "\274\274\274\377\274\274\274\377~~~\377\270\270\270\377\274\274\274\377"
  "\274\274\274\377\273\273\273\377\243\243\243\377\0\0\0\373\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\376\0\0\0\373\0\0\0\373\0\0\0\373"
  "\0\0\0\373\0\0\0\373\0\0\0\373\0\0\0\373\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\373\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_find_help[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0g\0\0\0\257\0\0\0\247\0\0\0K\0\0\0\0\205\203\177\25mli"
  "pEDB\266\35\35\34\344\4\4\4\373\4\4\4\373\33\33\33\345=<:\270][Yucb`"
  "\32\0\0\0\4\0\0\0\15\0\0\0S\0\0\0[\0\0\0\27\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0S\0\0\0\373\0\0\0\223\0\0\0\243\0\0\0\353MLK\227\4\4\4\373//-\377"
  "\301\277\273\377\354\352\347\377\365\363\360\377\362\360\354\377\341"
  "\337\334\377\257\255\252\377''&\377\2\2\2\373\77>>\227\0\0\0\335\0\0"
  "\0\340\0\0\0\357\0\0\0\347\0\0\0\27\0\0\0\0\0\0\0\0\0\0\0\243\0\0\0\213"
  "\0\0\0\0\207\205\201+60-\317\30\30\30\377\373\370\365\377\376\374\370"
  "\377\372\370\365\377\365\364\361\377\362\361\355\377\362\360\354\377"
  "\361\357\353\377\361\356\353\377\352\351\346\377\332\330\324\377\0\0"
  "\0\377\20\16\16\346CC\77<\0\0\0\22\0\0\0\303\0\0\0\203\0\0\0\0\0\0\0"
  "\0\0\0\0s\0\0\0\233\206\202~+\37\20\16\344\257:\36\377\373\253\223\377"
  "\372\351\343\377\360\357\353\377\354\352\347\377\351\350\345\377\352"
  "\350\346\377\354\352\350\377\355\353\351\377\355\353\351\377\355\353"
  "\350\377\352\317\306\377\3254\12\377u\31\4\377\20\10\6\347;;7;\0\0\0"
  "l\0\0\0\317\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\2274\26\15\314\257<\40\377\374"
  "\314\276\377\367\277\256\377\346uT\377\337\335\333\377\333\331\326\377"
  "\330\327\323\377\333\332\326\377\343\342\336\377\352\351\346\377\354"
  "\353\350\377\355\353\350\377\345W-\377\343:\13\377\3244\12\377i\25\4"
  "\377\20\5\4\324\0\0\0\225\0\0\0\301\0\0\0\1\0\0\0\0\0\0\0\0X,\"\214\17"
  "\17\17\377\375\324\310\377\367\277\257\377\350uT\377\325Q+\377\306\202"
  "p\377\276\275\272\377\245\243\240\377\234\232\225\377\271\267\262\377"
  "\327\326\322\377\347\345\342\377\347\232\205\377\346F\30\377\344<\13"
  "\377\342:\13\377\3110\11\377\0\0\0\377\1\0\0\352\0\0\0=\0\0\0\4\0\0\0"
  "\0\216\177z\27\4\1\0\373\372\261\234\377\372\314\276\377GG\77\377\12"
  "\12\11\377\12\12\11\377KKC\377\0\0\0\377\0\0\0\377\4\4\4\377\0\0\0\377"
  "\24\24\22\377\205yt\377\3327\13\377\354|[\377\351[2\377\344<\13\377\336"
  "8\13\377\235#\6\377\0\0\0\374\4\2\2""1\0\0\0\13\0\0\0\2mljpbba\377\355"
  "\342\337\37744.\377\235\235\215\377\317\317\271\377\304\304\257\377\215"
  "\215\177\377**&\377\0\0\0b\0\0\0""8\0\0\0""1\0\0\0U\0\0\0\377b\24\4\377"
  "\342R+\377\362\246\220\377\347N!\377\342;\13\377\311\221\201\377\2\2"
  "\2\377\0\0\0\210\0\0\0\24\0\0\0\5ECB\267\345\344\342\377FF\77\377\234"
  "\234\214\377\342\342\320\377\355\355\347\377\300\300\254\377\262\262"
  "\237\377\202\202t\377LLD\377\0\0\0\35\0\0\0\25\0\0\0\24\"\40\40&\0\0"
  "\0\377\236-\22\377\357\215q\377\360\233\203\377\352\335\327\377\333\332"
  "\326\377''$\377\0\0\0\304\0\0\0\36\0\0\0\11\35\35\34\344\360\356\354"
  "\377\11\11\10\377\325\325\277\377\373\373\372\377\303\303\256\377\265"
  "\265\242\377\246\246\225\377\234\234\217\377\10\10\7\377\0\0\0\11\0\0"
  "\0\4\226\225\224\13\0\0\0\11YYVB\77\15\2\377\360\271\251\377\366\365"
  "\364\377\350\347\344\377\332\330\325\377XVR\377\0\0\0\351\0\0\0%\0\0"
  "\0\15\4\4\4\373\365\363\360\377\11\11\11\377\312\312\265\377\335\335"
  "\320\377\267\267\244\377\252\252\230\377\233\233\213\377\256\256\243"
  "\377\12\12\11\377\0\0\0\2\0\0\0\0\350\347\345\24\0\0\0\2\31\30\30\12"
  "\12\12\10\377\366\364\362\377\364\363\361\377\344\343\340\377\323\322"
  "\316\377cb]\377\0\0\0\374\0\0\0+\0\0\0\20\4\4\4\373\362\360\354\377G"
  "G@\377\222\222\203\377\272\272\247\377\255\255\233\377\237\237\216\377"
  "\254\254\241\377\317\317\313\377LLE\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0""0/.\5\12\12\12\377\372\370\366\377\357\355\352\377\335\334\330\377"
  "\306\304\302\377>>9\377\0\0\0\374\0\0\0-\0\0\0\21\33\33\31\345\341\337"
  "\334\377\331\327\324\37744/\377\207\207y\377\240\240\220\377\256\256"
  "\242\377\303\303\276\377\1\1\1\377\1\1\1\377\261\260\257\77\0\0\0\0\0"
  "\0\0\0\0\0\0\0\211\207\2064kjg\377\374\372\370\377\354\352\350\377\326"
  "\324\322\377\274\272\267\377\0\0\0\377\0\0\0\352\0\0\0-\0\0\0\21<<:\271"
  "\257\255\252\377\361\356\353\377\351\350\345\377KKC\377\12\12\11\377"
  "\12\12\11\377AAA\377srq\377\1\1\1\377\1\1\1\377\244\243\241\315\337\336"
  "\333\10\316\314\312*(((\377\316\233\217\377\372\372\367\377\346\346\342"
  "\377\315\314\312\377\260\260\254\377\0\0\0\377\0\0\0\306\0\0\0+\0\0\0"
  "\20][Yu''&\377\352\351\346\377\355\353\351\377\355\343\337\377\347\204"
  "h\377\337]:\377c\31\11\377\237\237\235\377\1\1\1\377\1\1\1\377\1\1\1"
  "\377\241\237\235a)))\377\272\177q\377\367\306\267\377\361\246\221\377"
  "\334\322\314\377\310\306\303\377~|x\377\0\0\0\377\0\0\0\216\0\0\0%\0"
  "\0\0\15a`^\33\2\2\2\373\332\330\324\377\350\255\234\377\351a9\377\353"
  "tR\377\357\216r\377\352\200c\377\236.\23\377\77\30\21\377\0\0\0\377\1"
  "\1\1\377\1\1\1\377\276\236\224\377\371\323\310\377\363\255\231\377\336"
  "S+\377\3104\11\377\264\202t\377\0\0\0\377\0\0\0\375\0\0\0D\0\0\0\36\0"
  "\0\0\11\0\0\0\4""854\236\0\0\0\377\3264\12\377\344=\17\377\350X.\377"
  "\355yW\377\364\266\244\377\364\260\235\377\360\345\340\377\364\363\357"
  "\377\1\1\1\377\1\1\1\377\1\1\1\377\354\225|\377\343O%\377\3237\12\377"
  "\277/\11\377&\10\0\377\0\0\0\377\0\0\0\354\0\0\0-\0\0\0\24\0\0\0\5LK"
  "J\3\0\0\0\220\31\17\13\332u\31\4\377\3255\12\377\342:\13\377\344=\14"
  "\377\347L\37\377\357\273\253\377\365\364\363\377\357\355\352\377\365"
  "\363\361\377\1\1\1\377\1\1\1\377\336C\26\377\3237\12\377\3042\14\377"
  "Y\22\2\377\0\0\0\377\0\0\0\333\0\0\0\377\0\0\0;\0\0\0\13\0\0\0\2\0\0"
  "\0\7\0\0\0\260JJG7\16\5\4\347i\25\4\377\3100\11\377\3368\13\377\340S"
  "+\377\347\346\343\377\347\346\342\377\343\342\336\377\335\334\331\377"
  "\327\326\323\377\317\316\312\377\274[>\377\256)\7\3774\26\15\377\0\0"
  "\0\377\0\0\0\352\0\0\0b\0\0\0\374\0\0\0A\0\0\0\4\0\0\0\0\0\0\0\13\0\0"
  "\0\217\0\0\0\12;;7;\17\7\5\325\0\0\0\377\233\"\5\377\301\250\237\377"
  "\321\320\314\377\320\316\313\377\307\306\303\377\273\272\267\377\265"
  "\264\261\377\247\246\242\377rd^\377\0\0\0\377\0\0\0\377\0\0\0\331\0\0"
  "\0Y\0\0\0l\0\0\0\370\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0_\0\0\0\230"
  "\0\0\0\242\0\0\0\253\13\11\10\230\0\0\0\374\1\1\0\377\"\"!\377QPK\377"
  "]\\W\377;;7\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\375\0\0\0\323\0\0"
  "\0E\0\0\0H\0\0\0\310\0\0\0\246\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\37\0\0\0-\0\0\0\12\0\0\0\21\2\2\2""1\0\0\0\215\0\0\0\305\0\0"
  "\0\351\0\0\0\374\0\0\0\374\0\0\0\353\0\0\0\307\0\0\0\226\0\0\0K\0\0\0"
  "\307\0\0\0\377\0\0\0\377\0\0\0\311\0\0\0%\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\4\0\0\0\13\0\0\0\24\0\0\0"
  "\35\0\0\0%\0\0\0+\0\0\0-\0\0\0-\0\0\0+\0\0\0%\0\0\0\36\0\0\0\27\0\0\0"
  "0\0\0\0\33\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\4\0\0\0\11\0\0\0\15\0\0"
  "\0\20\0\0\0\21\0\0\0\21\0\0\0\20\0\0\0\15\0\0\0\11\0\0\0\5\0\0\0\2\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_save_all[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0U\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0Y\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\303\327\364\377\251\315\345\377uuz\377"
  "\357\305\273\377\361\310\276\377\360\306\274\377\356\274\262\377\356"
  "\276\265\377\356\301\270\377\355\277\266\377\351\267\255\377\351\270"
  "\257\377\351\267\255\377\351\270\257\377\351\271\261\377\345\277\272"
  "\377srw\377\263\315\343\377\241\276\326\377\0\0\0\377\0\0\0\0\0\0\0\4"
  "\0\0\0\1\0\0\0\377\273\326\350\377\212\252\305\377`_h\377\340\215~\377"
  "\340\202n\377\340\200n\377\334zh\377\334\201q\377\332xh\377\324\201s"
  "\377\324}n\377\316re\377\317rd\377\316ug\377\304g[\377\303eX\377bai\377"
  "\207\243\267\377Vq\207\377\0\0\0\377\0\0\0\0\0\0\0\15\0\0\0\4\0\0\0\377"
  "\272\325\351\377\210\247\303\377EDJ\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0_\0\0\0\377\266\323\347\377\207\253\301\377"
  "\0\0\0\377\303\327\364\377\251\315\345\377uuz\377\357\305\273\377\361"
  "\310\276\377\360\306\274\377\356\274\262\377\356\276\265\377\356\301"
  "\270\377\355\277\266\377\351\267\255\377\351\270\257\377\351\267\255"
  "\377\351\270\257\377\351\271\261\377\345\277\272\377srw\377\263\315\343"
  "\377\241\276\326\377\0\0\0\377\0\0\0\377\271\323\347\377\205\244\277"
  "\377\0\0\0\377\273\326\350\377\212\252\305\377`_h\377\340\215~\377\340"
  "\202n\377\340\200n\377\334zh\377\334\201q\377\332xh\377\324\201s\377"
  "\324}n\377\316re\377\317rd\377\316ug\377\304g[\377\303eX\377bai\377\207"
  "\243\267\377Vq\207\377\0\0\0\377\0\0\0\377\271\323\346\377\204\243\277"
  "\377\0\0\0\377\272\325\351\377\210\247\303\377hfp\377\310\201{\377\313"
  "|t\377\313zs\377\313{s\377\314|r\377\313}s\377\277kd\377\314zp\377\301"
  "jb\377\314|s\377\302e[\377\303dY\377\272lj\377hfp\377\201\236\266\377"
  "Tp\206\377\0\0\0\377\0\0\0\377\267\322\347\377\202\240\273\377\0\0\0"
  "\377\266\323\347\377\207\253\301\377sss\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377sss\377\203\240\270\377R"
  "l\200\377\0\0\0\377\0\0\0\377\265\312\345\377\177\242\271\377\0\0\0\377"
  "\271\323\347\377\205\244\277\377sss\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377sss\377\203\240\270\377Oi|\377"
  "\0\0\0\377\0\0\0\377\256\314\345\377}\240\266\377\0\0\0\377\271\323\346"
  "\377\204\243\277\377sss\377\316\316\316\377\315\315\315\377\315\315\315"
  "\377\315\315\315\377\315\315\315\377\315\315\315\377\315\315\315\377"
  "\315\315\315\377\315\315\315\377\315\315\315\377\315\315\315\377\315"
  "\315\315\377\277\277\277\377sss\377\210\244\273\377Hbv\377\0\0\0\377"
  "\0\0\0\377\260\321\344\377\203\241\266\377\0\0\0\377\267\322\347\377"
  "\202\240\273\377ccc\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377sss\377\210\244\273\377F^p\377\0\0\0\377\0\0"
  "\0\377\252\316\343\377{\233\262\377\0\0\0\377\265\312\345\377\177\242"
  "\271\377sss\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377sss\377\207\243\272\377E\\m\377\0\0\0\377\0\0\0\377\251"
  "\311\342\377t\224\257\377\0\0\0\377\256\314\345\377}\240\266\377sss\377"
  "\316\316\316\377\315\315\315\377\315\315\315\377\315\315\315\377\315"
  "\315\315\377\315\315\315\377\315\315\315\377\315\315\315\377\315\315"
  "\315\377\315\315\315\377\315\315\315\377\315\315\315\377\305\305\305"
  "\377sss\377\207\243\272\377T`i\377\0\0\0\377\0\0\0\377\253\304\342\377"
  "r\224\255\377\0\0\0\377\260\321\344\377\203\241\266\377s[[\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377sss\377"
  "\203\240\270\377Q\\d\377\0\0\0\377\0\0\0\377\252\311\342\377p\221\252"
  "\377\0\0\0\377\252\316\343\377{\233\262\377z\216\232\377zzz\377sss\377"
  "sss\377sss\377sss\377sss\377kor\377ooo\377sss\377sss\377sss\377sss\377"
  "iii\377ow~\377\206\242\271\377:Q]\377\0\0\0\377\0\0\0\377\252\311\341"
  "\377l\216\246\377\0\0\0\377\251\311\342\377t\224\257\377\201\236\266"
  "\377\203\240\270\377\206\242\271\377\202\237\267\377\177\235\266\377"
  "~\234\265\377\202\237\267\377y\230\262\377\206\242\271\377\205\241\270"
  "\377\205\241\270\377\207\243\272\377\202\237\267\377\214\247\275\377"
  "\203\240\270\377\212\245\273\3776JY\377\0\0\0\377\0\0\0\377\250\310\341"
  "\377k\215\246\377\0\0\0\377\253\304\342\377r\224\255\377o\220\254\377"
  "q\222\256\377AJN\377BJQ\377R[c\377boy\377_lv\377\\iq\377Zfo\377Xck\377"
  "Wcj\377R[c\377;S`\3779BK\377x\227\263\377\244\271\313\3776HS\377\0\0"
  "\0\377\0\0\0\377\244\304\336\377i\213\243\377\0\0\0\377\252\311\342\377"
  "p\221\252\377o\217\247\377JSY\377\227\223\214\377\337\335\332\377\343"
  "\341\336\377\353\352\350\377\353\352\350\377\352\351\347\377\337\335"
  "\332\377\317\316\311\377\311\306\300\377\233\226\216\377Vah\377Kez\377"
  "Ts\214\377\252\306\335\3774FN\377\0\0\0\377\0\0\0\377w\211\231\377n\211"
  "\236\377\0\0\0\377\252\311\341\377l\216\246\377l\214\244\377@GM\377\332"
  "\330\323\377\347\346\342\377ge^\377ROG\377ROG\377\331\327\324\377\307"
  "\305\277\377\300\274\265\377\270\263\253\377\317\316\311\377CLT\377M"
  "i\177\377Oo\204\377\263\312\334\3771>I\377\0\0\0\377\0\0\0""5\14\15\17"
  "\377N^j\377\0\0\0\377\250\310\341\377k\215\246\377r\217\244\377@GM\377"
  "\342\341\335\377\360\357\354\377ge^\377ROG\377ROG\377\315\312\306\377"
  "\302\277\271\377\300\274\265\377\312\306\300\377\334\332\327\377KU]\377"
  "Ni\177\377Oo\204\377\272\314\334\3771>I\377\0\0\0\377\0\0\0\4\0\0\0""9"
  "\0\0\0\377\0\0\0\377\244\304\336\377i\213\243\377p\212\241\3778>C\377"
  "\340\336\332\377\353\352\350\377QNF\377OLD\377OLD\377\307\304\276\377"
  "\300\274\265\377\313\310\302\377\341\340\334\377\351\350\346\377GQX\377"
  "Nhy\377Ml\200\377\243\303\333\3778\77C\377\0\0\0\377\0\0\0\1\0\0\0\4"
  "\0\0\0\16\0\0\0\377w\211\231\377n\211\236\377e\205\234\37738<\377\327"
  "\324\320\377\326\324\320\377NJC\377MIB\377MIB\377\300\274\265\377\321"
  "\316\311\377\346\345\342\377\355\354\352\377\346\345\342\377EOU\377H"
  "as\377Mfx\377\241\301\332\3777<@\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0""5\14\15\17\377N^j\377[n|\377O[b\377\244\240\231\377\300\274"
  "\265\377\270\263\253\377\314\311\303\377\314\311\303\377\327\325\321"
  "\377\344\342\340\377\352\351\347\377\335\333\327\377\270\265\260\377"
  ">GM\377Jav\377J`p\377\233\303\330\3776<A\377\0\0\0\377\0\0\0\0\0\0\0"
  "\0\0\0\0\1\0\0\0\10\0\0\0\77\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377(2>\377\0\0\0\377\0"
  "\0\0^"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_session_load[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\37\0\0\0\306"
  "\0\0\0\342\0\0\0\356\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0.\0"
  "\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\310\265\270"
  "\245\377\344\347\322\377\344\347\322\377\344\347\322\377\344\347\322"
  "\377\344\347\322\377\207\212v\37734+\377\22\22\22\6\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0./%O\13\13\13\345\342\345\317\377\317\324\257\377\317"
  "\324\257\377\317\324\257\377\316\323\256\377\316\323\256\377\262\266"
  "\226\377--%\377\5\5\4A\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"#\34\241"
  "\235\237\220\377\342\345\317\377\306\312\246\377\304\311\245\377\306"
  "\313\247\377\307\314\250\377\311\316\251\377\311\316\251\377UXG\377\31"
  "\32\25\242**\25\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\40\32\356\324\326\302"
  "\377\276\302\240\377\263\270\226\377\260\265\225\377\263\267\227\377"
  "\266\273\231\377\273\300\236\377\274\301\237\377\201\205l\377>\77""2"
  "\345\0\0\0\302\0\0\0\324\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0Q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#$\35\373\332"
  "\335\310\377\257\264\224\377\252\257\217\377\243\247\211\377\246\252"
  "\213\377\252\257\217\377\251\255\216\377\247\253\215\377\244\250\212"
  "\377\241\245\210\377\252\255\226\377\263\265\245\377\270\273\252\377"
  "\272\274\253\377\301\303\262\377\307\312\267\377\312\315\273\377\272"
  "\275\250\377\0\0\0\377\34\34\34\3\0\0\0\0\0\0\0\0\0\0\0\0\14\14\11\377"
  "\335\337\313\377\226\233~\377\235\242\206\377\225\230|\377\226\231~\377"
  "\232\235\201\377\231\235\200\377\226\231~\377\235\241\204\377\245\252"
  "\213\377\244\251\212\377\243\250\211\377\242\245\210\377\243\247\211"
  "\377\242\245\207\377\237\243\206\377\233\236\203\377\211\215t\377\0\0"
  "\0\377//'\14\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\377\330\333\311\377\204\206"
  "n\377}\201i\377\25\26\22\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\327\0\0\0\301\0\0\0W\0"
  "\0\0\5\0\0\0\377\327\332\311\377y}g\377=\77""4\377\340\340\331\377\353"
  "\355\335\377\350\353\331\377\350\353\331\377\350\353\331\377\350\353"
  "\331\377\350\353\331\377\350\353\331\377\350\353\331\377\350\353\331"
  "\377\350\353\331\377\350\353\331\377\350\353\331\377\347\352\330\377"
  "\343\346\324\377\336\341\320\377\332\334\314\377\332\334\321\377+,(\377"
  ",,#\23\0\0\0\377\327\332\306\377os^\377\15\15\15\377\364\364\354\377"
  "\317\324\257\377\317\324\257\377\317\324\257\377\317\324\257\377\317"
  "\324\257\377\317\324\257\377\317\324\257\377\317\324\257\377\317\324"
  "\257\377\316\323\256\377\1\1\1\377\1\1\1\377\1\1\1\377\306\313\250\377"
  "\302\306\244\377\273\300\236\377\253\260\221\377#%\36\37722'5\0\0\0\377"
  "\327\332\306\377IK=\377\334\334\324\377\352\354\335\377\315\322\255\377"
  "\316\323\256\377\316\323\256\377\315\322\255\377\316\323\256\377\315"
  "\322\255\377\260\265\225\377\12\12\10\377\12\12\10\377\244\250\212\377"
  "\5\5\4\377\272\271\266\377\5\5\4\377\233\236\203\377\11\11\10\377\11"
  "\11\7\377oq]\377\10\10\6\27712(J\0\0\0\377\325\330\304\377\26\26\26\377"
  "\362\362\352\377\312\317\253\377\312\317\252\377\312\317\253\377\312"
  "\317\252\377\311\316\252\377\312\317\252\377\311\316\252\377\12\12\10"
  "\377\207\210\203\377rrp\377\12\12\10\377HFA\377\237\235\226\377HFA\377"
  "\11\11\7\377\210\207\201\377#$\36\377\4\4\3\377\15\15\12\24123)>\0\0"
  "\0\377\266\270\247\377ttp\377\354\354\342\377\303\310\245\377\302\307"
  "\244\377\302\307\244\377\302\306\244\377\300\305\242\377\302\306\244"
  "\377\277\304\241\377\11\11\10\377\310\307\302\377\266\265\257\377\237"
  "\235\226\377\237\235\226\377\237\235\226\377\220\216\206\377\227\225"
  "\216\377\200}t\377HFA\377\0\0\0\376\34\34\26e33&'\0\0\0\377\246\251\230"
  "\377\334\334\324\377\270\274\233\377\270\274\233\377\265\271\231\377"
  "\263\267\227\377\263\267\227\377\260\265\225\377\260\265\225\377\257"
  "\263\224\377\214\217v\377\10\11\7\377\237\235\226\377\237\235\226\377"
  "YXT\377`^W\377\211\210\203\377\200}t\377vtk\377\3\3\3\376\5\5\4\3073"
  "3'200&\24\0\0\0\377\236\237\221\377\345\346\332\377\255\261\222\377\251"
  "\255\217\377\246\252\214\377\245\251\214\377\243\247\212\377\243\247"
  "\212\377\241\245\210\377\1\1\1\377\1\1\1\377HFA\377\237\235\226\377`"
  "^W\377CB\77\377('$\377640\377\237\235\226\377mkc\377HFA\377\1\1\1\357"
  "\0\0\0\356,,!\10\0\0\0\377\343\345\331\377\300\303\257\377\224\230|\377"
  "\217\223y\377\213\217u\377\212\216t\377\210\214s\377\210\214s\377\205"
  "\211p\377\1\1\0\377\214\213\211\377\266\265\257\377\237\235\226\377Y"
  "XT\377!\40\36\377\12\11\10\377\30\30\26\377\346\346\344\377\200}t\377"
  "ec\\\377`^W\377\0\0\0\354\34\34\34\3""34)[\0\0\0\377\0\0\0\377\0\0\0"
  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377HFA\377\237\235\226\377\211\210\203\377640\377\26\26"
  "\24\377\214\213\211\377\337\336\334\377ec\\\377HFA\377\0\0\0\354\0\0"
  "\0\352\0\0\0\1""34(J34)T34)Y34(Z45)Z45)Z45)Z45)Z45)Z45)Z45)Z\36\37\30"
  "{\1\1\0\367\260\257\251\377\200}t\377\266\265\257\377\346\346\344\377"
  "\325\324\321\377\223\221\213\377ec\\\377\0\0\0\364\12\12\7A\34\34\34"
  "\3\0\0\0\0""22(%24(834)B23(C34)D34)D34)D34)D34)D34)D34)D\0\0\0\365\266"
  "\265\257\377\253\251\243\377\237\235\226\377\200}t\377\200}t\377vtk\377"
  "vtk\377]\\U\377HFA\377\0\0\0\362\0\0\0\1\0\0\0\0""33\36\11""00&\24""1"
  "1&\31""00$\31""33(\32""33(\32""33(\32""33(\32""33(\32""33(\32""33(\32"
  "\0\0\0\363\1\1\1\313YXT\377\0\0\0\366HFA\377vtk\377HFA\377\0\0\0\363"
  "IIC\377\0\0\0\307\0\0\0\362\0\0\0\0\0\0\0\0\0\0\0\1**\0\2\37\37\0\3\37"
  "\37\0\3""88\34\3""88\34\3""88\34\3""88\34\3""88\34\3""88\34\3""88\34"
  "\3\4\4\2&\0\0\0\362\0\0\0\362\2\2\1""5\0\0\0\343BA<\377\0\0\0\343\1\1"
  "\0""5\0\0\0\362\0\0\0\362\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\351\0\0\0\353\0\0\0\353\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_session_new[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0Y\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\202"
  "\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\377\323\323\323\377\366\366\366\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\371\371\371\377\332\332"
  "\332\377XXX\377\0\0\0\301\0\0\0\6\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\366\366\366\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\307\307\307\377\321\321\321\377\326\326\326\377\0\0\0\377\0"
  "\0\0\10\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\376\376\376\377\377"
  "\377\377\377\376\376\376\377\375\375\375\377\300\300\300\377\341\341"
  "\341\377\360\360\360\377\233\233\233\377\0\0\0\377\0\0\0\11\0\0\0\1\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\376\376"
  "\376\377\375\375\375\377\374\374\373\377\375\375\375\377\374\374\373"
  "\377\373\373\373\377\257\257\256\377\351\351\351\377\377\377\377\377"
  "\337\337\337\377\217\217\217\377\0\0\0\377\0\0\0\11\0\0\0\1\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\376\376\376\377\375\375\375\377\374\374\373\377\373\373"
  "\373\377\372\372\371\377\373\373\373\377\372\372\371\377\371\371\370"
  "\377\244\244\243\377\360\360\360\377\377\377\377\377\364\364\364\377"
  "\317\317\317\377\242\242\242\377\0\0\0\264\0\0\0\10\0\0\0\1\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\376\376\376\377\375\375\375"
  "\377\374\374\373\377\373\373\373\377\372\372\371\377\371\371\370\377"
  "\370\370\367\377\371\371\370\377\370\370\367\377\370\367\366\377\236"
  "\236\236\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
  "\377\0\0\0\201\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377"
  "\377\374\374\373\377\373\373\373\377\372\372\371\377\371\371\370\377"
  "\370\370\367\377\370\367\366\377\367\366\365\377\370\367\366\377\367"
  "\366\365\377\366\366\364\377\364\363\362\377\336\335\334\377\323\322"
  "\320\377\267\267\265\377\237\236\235\377poo\377ebZ\377\0\0\0\377\0\0"
  "\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\372\372\371\377"
  "\371\371\370\377\370\370\367\377\370\367\366\377\367\366\365\377\366"
  "\366\364\377\365\364\363\377\366\366\364\377\365\364\363\377\364\363"
  "\362\377\362\362\360\377\344\344\342\377\332\331\327\377\330\330\326"
  "\377\315\314\312\377\257\256\254\377\210\204{\377\0\0\0\377\0\0\0\35"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\370\370\367\377\370"
  "\367\366\377\367\366\365\377\366\366\364\377\365\364\363\377\364\363"
  "\362\377\363\363\361\377\364\363\362\377\363\363\361\377\362\362\360"
  "\377\357\357\355\377\356\355\353\377\355\354\352\377\351\350\346\377"
  "\325\324\323\377\304\303\302\377\217\212\201\377\0\0\0\377\0\0\0\40\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\366\365\364\377\1\1"
  "\1\377\1\1\1\377\1\1\1\377\363\363\361\377\362\362\360\377\361\361\357"
  "\377\362\362\360\377\361\361\357\377\361\360\356\377\356\355\353\377"
  "\354\353\351\377\352\351\347\377\345\344\342\377\344\343\340\377\322"
  "\321\316\377\215\210~\377\0\0\0\377\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0#\0"
  "\0\0\377\15\15\15\377\303\302\301\377\6\6\6\377\335\334\332\377\6\6\6"
  "\377\277\277\275\377\14\14\14\377\14\14\14\377\317\317\315\377\360\357"
  "\355\377\357\356\354\377\354\353\351\377\350\347\345\377\345\344\341"
  "\377\344\343\340\377\342\341\336\377\341\337\334\377\227\222\210\377"
  "\0\0\0\377\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\362\352\352\352\377\262\262"
  "\260\377\14\14\14\377HFA\377\237\235\226\377HFA\377\14\14\14\377\210"
  "\207\201\377665\377\14\14\14\377\360\357\355\377\357\356\354\377\354"
  "\353\351\377\350\347\345\377\345\344\341\377\344\343\340\377\342\341"
  "\336\377\341\337\334\377\244\236\223\377\0\0\0\377\0\0\0\40\0\0\0\0\0"
  "\0\0\0\0\0\0\362\235\234\230\377\221\220\212\377\237\235\226\377\237"
  "\235\226\377\237\235\226\377\220\216\206\377\227\225\216\377\200}t\377"
  "HFA\377\14\14\13\377\355\354\352\377\354\353\351\377\350\347\344\377"
  "\347\346\343\377\343\342\337\377\342\340\335\377\341\340\334\377\340"
  "\337\333\377\241\234\220\377\0\0\0\377\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0"
  "3\0\0\0\377\237\235\226\377\237\235\226\377YXT\377`^W\377\211\210\203"
  "\377\200}t\377vtk\377\13\13\13\377\274\273\271\377\351\350\345\377\351"
  "\350\345\377\345\344\341\377\346\344\341\377\343\342\336\377\337\336"
  "\332\377\336\335\331\377\335\334\330\377\241\233\220\377\0\0\0\377\0"
  "\0\0\40\0\0\0\0\0\0\0\375\0\0\0\375HFA\377\237\235\226\377`^W\377CB\77"
  "\377('$\377640\377\237\235\226\377mkc\377HFA\377\31\31\31\377\22\22\21"
  "\377\347\345\342\377\344\343\337\377\343\342\336\377\340\337\333\377"
  "\336\335\331\377\335\334\330\377\334\333\327\377\241\233\220\377\0\0"
  "\0\377\0\0\0\40\0\0\0\0\0\0\0\375\356\356\355\377\266\265\257\377\237"
  "\235\226\377YXT\377!\40\36\377\12\11\10\377\30\30\26\377\346\346\344"
  "\377\200}t\377ec\\\377`^W\377\21\21\21\377\344\343\337\377\342\341\335"
  "\377\340\337\333\377\336\335\331\377\334\333\327\377\333\331\325\377"
  "\331\327\323\377\237\231\215\377\0\0\0\377\0\0\0\40\0\0\0\0\0\0\0\375"
  "\0\0\0\370HFA\377\237\235\226\377\211\210\203\377640\377\26\26\24\377"
  "\214\213\211\377\337\336\334\377ec\\\377HFA\377\23\23\23\377\23\23\23"
  "\377\341\340\334\377\341\340\334\377\336\335\331\377\335\333\327\377"
  "\334\332\326\377\331\327\323\377\330\326\322\377\236\230\215\377\0\0"
  "\0\377\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0""3\0\0\0\377\260\257\251\377\200"
  "}t\377\266\265\257\377\346\346\344\377\325\324\321\377\223\221\213\377"
  "ec\\\377\13\13\13\377\263\262\257\377\341\340\334\377\337\336\332\377"
  "\340\336\332\377\335\333\327\377\334\332\326\377\331\327\323\377\330"
  "\326\321\377\327\325\321\377\235\227\213\377\0\0\0\377\0\0\0\40\0\0\0"
  "\0\0\0\0\0\0\0\0\362\266\265\257\377\253\251\243\377\237\235\226\377"
  "\200}t\377\200}t\377vtk\377vtk\377]\\U\377HFA\377\13\13\13\377\340\336"
  "\332\377\336\334\330\377\336\334\330\377\334\332\326\377\334\332\326"
  "\377\330\326\322\377\327\326\321\377\325\323\316\377\233\225\212\377"
  "\0\0\0\377\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\362\0\0\0\377YXT\377\6\6\5"
  "\377HFA\377vtk\377HFA\377\10\10\7\377IIC\377$#\40\377\10\7\7\377\242"
  "\234\220\377\241\233\217\377\241\233\220\377\237\231\215\377\237\231"
  "\215\377\235\227\214\377\235\227\214\377\233\226\212\377gcY\377\0\0\0"
  "\377\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\367\0\0\0\377\0\0\0\377\0"
  "\0\0\377BA<\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0q\0\0\0\30\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0"
  "\0\0\17\0\0\0\35\0\0\0\354\0\0\0\356\0\0\0\356\0\0\0\40\0\0\0\40\0\0"
  "\0\40\0\0\0\40\0\0\0\40\0\0\0\40\0\0\0\40\0\0\0\40\0\0\0\40\0\0\0\40"
  "\0\0\0\40\0\0\0\40\0\0\0\40\0\0\0\30\0\0\0\10\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_session_save[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\375"
  "\0\0\0\375\0\0\0\375\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\362\0\0\0\362\0\0\0""3\0\0\0\370\272"
  "\271\266\377\0\0\0\370\0\0\0""3\0\0\0\362\0\0\0\362\0\0\0#\0\0\0\0\0"
  "\0\0\0\0\0\0U\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377mmm\377rrp\377"
  "\0\0\0\377HFA\377\237\235\226\377HFA\377\0\0\0\377\210\207\201\377\0"
  "\0\0\331\0\0\0\362\0\0\0\1\0\0\0\0\0\0\0\377\303\327\364\377\251\315"
  "\345\377uuz\377\357\305\273\377\361\310\276\377\360\306\274\377\356\274"
  "\262\377\356\276\265\377\356\301\270\377\355\277\266\377\13\11\10\377"
  "\310\307\302\377\266\265\257\377\237\235\226\377\237\235\226\377\237"
  "\235\226\377\220\216\206\377\227\225\216\377\200}t\377HFA\377\0\0\0\363"
  "\0\0\0\4\0\0\0\0\0\0\0\377\273\326\350\377\212\252\305\377`_h\377\340"
  "\215~\377\340\202n\377\340\200n\377\334zh\377\334\201q\377\332xh\377"
  "\324\201s\377\251dX\377\12\5\5\377\237\235\226\377\237\235\226\377YX"
  "T\377`^W\377\211\210\203\377\200}t\377vtk\377\0\0\0\377\0\0\0F\0\0\0"
  "\11\0\0\0\0\0\0\0\377\272\325\351\377\210\247\303\377hfp\377\310\201"
  "{\377\313|t\377\313zs\377\313{s\377\314|r\377\313}s\377\1\0\0\377\1\0"
  "\0\377HFA\377\237\235\226\377`^W\377CB\77\377('$\377640\377\237\235\226"
  "\377mkc\377HFA\377\0\0\0\346\0\0\0\354\0\0\0\0\0\0\0\377\266\323\347"
  "\377\207\253\301\377sss\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\2\2\2\377\214\213"
  "\211\377\266\265\257\377\237\235\226\377YXT\377!\40\36\377\12\11\10\377"
  "\30\30\26\377\346\346\344\377\200}t\377ec\\\377`^W\377\0\0\0\354\0\0"
  "\0\0\0\0\0\377\271\323\347\377\205\244\277\377sss\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\2\2\2\377\7\7\7\377HFA\377\237\235\226\377\211\210\203\377"
  "640\377\26\26\24\377\214\213\211\377\337\336\334\377ec\\\377HFA\377\0"
  "\0\0\354\0\0\0\352\0\0\0\0\0\0\0\377\271\323\346\377\204\243\277\377"
  "sss\377\316\316\316\377\315\315\315\377\315\315\315\377\315\315\315\377"
  "\315\315\315\377\315\315\315\377\315\315\315\377\244\244\244\377\12\12"
  "\12\377\260\257\251\377\200}t\377\266\265\257\377\346\346\344\377\325"
  "\324\321\377\223\221\213\377ec\\\377\0\0\0\377\0\0\0K\0\0\0\13\0\0\0"
  "\0\0\0\0\377\267\322\347\377\202\240\273\377ccc\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\15\15\15\377\266\265\257\377\253\251\243\377"
  "\237\235\226\377\200}t\377\200}t\377vtk\377vtk\377]\\U\377HFA\377\0\0"
  "\0\364\0\0\0\13\0\0\0\0\0\0\0\377\265\312\345\377\177\242\271\377sss"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\15\15\15\377:::\377"
  "YXT\377\12\12\12\377HFA\377vtk\377HFA\377\6\10\11\377IIC\377\0\0\0\377"
  "\0\0\0\364\0\0\0\13\0\0\0\0\0\0\0\377\256\314\345\377}\240\266\377ss"
  "s\377\316\316\316\377\315\315\315\377\315\315\315\377\315\315\315\377"
  "\315\315\315\377\315\315\315\377\315\315\315\377\260\260\260\377\12\12"
  "\12\377\12\12\12\377\244\244\244\377\26\26\26\377BA<\377\14\14\14\377"
  "l\202\224\377\4\4\5\377\0\0\0\377\0\0\0=\0\0\0\13\0\0\0\0\0\0\0\377\260"
  "\321\344\377\203\241\266\377s[[\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\26\26\26\377\24\24\24\377\11\11\11\377\203\240\270\377Q\\d\377\0"
  "\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0\377\252\316\343\377{\233\262"
  "\377z\216\232\377zzz\377sss\377sss\377sss\377sss\377sss\377kor\377oo"
  "o\377sss\377sss\377sss\377sss\377iii\377ow~\377\206\242\271\377:Q]\377"
  "\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0\377\251\311\342\377t\224\257"
  "\377\201\236\266\377\203\240\270\377\206\242\271\377\202\237\267\377"
  "\177\235\266\377~\234\265\377\202\237\267\377y\230\262\377\206\242\271"
  "\377\205\241\270\377\205\241\270\377\207\243\272\377\202\237\267\377"
  "\214\247\275\377\203\240\270\377\212\245\273\3776JY\377\0\0\0\377\0\0"
  "\0\36\0\0\0\13\0\0\0\0\0\0\0\377\253\304\342\377r\224\255\377o\220\254"
  "\377q\222\256\377AJN\377BJQ\377R[c\377boy\377_lv\377\\iq\377Zfo\377X"
  "ck\377Wcj\377R[c\377;S`\3779BK\377x\227\263\377\244\271\313\3776HS\377"
  "\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0\377\252\311\342\377p\221\252"
  "\377o\217\247\377JSY\377\227\223\214\377\337\335\332\377\343\341\336"
  "\377\353\352\350\377\353\352\350\377\352\351\347\377\337\335\332\377"
  "\317\316\311\377\311\306\300\377\233\226\216\377Vah\377Kez\377Ts\214"
  "\377\252\306\335\3774FN\377\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0"
  "\377\252\311\341\377l\216\246\377l\214\244\377@GM\377\332\330\323\377"
  "\347\346\342\377ge^\377ROG\377ROG\377\331\327\324\377\307\305\277\377"
  "\300\274\265\377\270\263\253\377\317\316\311\377CLT\377Mi\177\377Oo\204"
  "\377\263\312\334\3771>I\377\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0"
  "\377\250\310\341\377k\215\246\377r\217\244\377@GM\377\342\341\335\377"
  "\360\357\354\377ge^\377ROG\377ROG\377\315\312\306\377\302\277\271\377"
  "\300\274\265\377\312\306\300\377\334\332\327\377KU]\377Ni\177\377Oo\204"
  "\377\272\314\334\3771>I\377\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0"
  "\377\244\304\336\377i\213\243\377p\212\241\3778>C\377\340\336\332\377"
  "\353\352\350\377QNF\377OLD\377OLD\377\307\304\276\377\300\274\265\377"
  "\313\310\302\377\341\340\334\377\351\350\346\377GQX\377Nhy\377Ml\200"
  "\377\243\303\333\3778\77C\377\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0"
  "\0\377w\211\231\377n\211\236\377e\205\234\37738<\377\327\324\320\377"
  "\326\324\320\377NJC\377MIB\377MIB\377\300\274\265\377\321\316\311\377"
  "\346\345\342\377\355\354\352\377\346\345\342\377EOU\377Has\377Mfx\377"
  "\241\301\332\3777<@\377\0\0\0\377\0\0\0\36\0\0\0\13\0\0\0\0\0\0\0""5"
  "\14\15\17\377N^j\377[n|\377O[b\377\244\240\231\377\300\274\265\377\270"
  "\263\253\377\314\311\303\377\314\311\303\377\327\325\321\377\344\342"
  "\340\377\352\351\347\377\335\333\327\377\270\265\260\377>GM\377Jav\377"
  "J`p\377\233\303\330\3776<A\377\0\0\0\377\0\0\0\35\0\0\0\13\0\0\0\0\0"
  "\0\0\4\0\0\0""9\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377(2>\377\0\0\0\377\0\0\0]\0\0\0"
  "\30\0\0\0\11\0\0\0\0\0\0\0\1\0\0\0\4\0\0\0\16\0\0\0\30\0\0\0\35\0\0\0"
  "\35\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0"
  "\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\35\0\0\0\30"
  "\0\0\0\15\0\0\0\4"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_shell[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (9216) */
  "\0\0$\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (192) */
  "\0\0\0\300"
  /* width (48) */
  "\0\0\0""0"
  /* height (48) */
  "\0\0\0""0"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\1\0\0\0\2\0\0\0\4\0\0\0\7\0\0\0\11\0\0\0\12\0\0\0\13\0\0\0"
  "\13\0\0\0\13\0\0\0\13\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0"
  "\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14"
  "\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0"
  "\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\13\0"
  "\0\0\13\0\0\0\13\0\0\0\12\0\0\0\11\0\0\0\7\0\0\0\4\0\0\0\2\0\0\0\1\0"
  "\0\0\0\0\0\0\0\0\0\0\2\0\0\0""7\2\2\2\377\1\1\1\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0K\0\0\0\14\0\0\0\7\0\0\0\2\0\0\0\1\0\0\0\0\0\0\0\4\0"
  "\0\0\377\340\336\334\332\352\351\346\377\357\356\354\377\360\357\355"
  "\377\361\360\356\377\362\361\357\377\360\360\355\377\361\360\355\377"
  "\362\362\357\377\362\362\357\377\362\362\357\377\362\362\357\377\362"
  "\362\357\377\362\362\357\377\362\362\357\377\361\361\356\377\356\356"
  "\353\377\355\354\350\377\354\353\350\377\353\352\347\377\352\351\346"
  "\377\351\350\344\377\350\347\344\377\346\345\341\377\346\344\340\377"
  "\341\337\333\377\331\327\323\377\326\324\316\377\323\320\313\377\320"
  "\315\307\377\314\311\304\377\311\306\301\377\306\303\276\377\302\300"
  "\273\377\277\275\270\377\272\270\261\377\270\265\256\377\266\262\254"
  "\377\260\254\246\377\215\211\202\340\0\0\0\377\0\0\0\32\0\0\0\16\0\0"
  "\0\6\0\0\0\2\0\0\0\0\0\0\0\7\0\0\0\377\357\356\355\377\325\322\312\377"
  "\327\324\314\377\331\326\316\377\332\327\317\377\333\330\321\377\334"
  "\332\322\377\335\333\323\377\336\333\324\377\336\334\324\377\336\334"
  "\324\377\336\333\323\377\336\334\324\377\336\334\324\377\336\333\324"
  "\377\336\333\323\377\335\332\323\377\334\332\322\377\333\330\321\377"
  "\332\326\316\377\331\325\315\377\327\323\313\377\324\321\311\377\322"
  "\316\306\377\320\314\304\377\316\312\302\377\312\306\276\377\307\303"
  "\273\377\303\277\266\377\300\273\263\377\273\267\257\377\267\263\253"
  "\377\264\257\247\377\260\254\243\377\255\250\240\377\246\243\231\377"
  "\244\237\227\377\241\234\224\377\236\231\220\377\202~w\377\0\0\0\377"
  "\0\0\0)\0\0\0\26\0\0\0\12\0\0\0\3\0\0\0\0\0\0\0\11\0\0\0\377\357\356"
  "\354\377\326\324\313\377\330\326\315\377\332\327\317\377\333\330\320"
  "\377\335\332\322\377\336\333\323\377\336\334\324\377\337\335\325\377"
  "\337\335\326\377\337\335\326\377\337\335\326\377\340\335\326\377\337"
  "\335\325\377\337\333\324\377\336\332\323\377\334\331\322\377\333\330"
  "\320\377\332\327\320\377\331\326\316\377\327\323\314\377\325\321\311"
  "\377\323\317\310\377\321\315\305\377\316\313\303\377\315\310\300\377"
  "\311\305\275\377\305\302\272\377\301\275\265\377\276\271\261\377\272"
  "\266\255\377\266\262\252\377\262\256\245\377\256\252\241\377\251\245"
  "\234\377\245\241\230\377\241\234\224\377\236\232\222\377\233\227\216"
  "\377{xq\377\0\0\0\377\0\0\0""7\0\0\0\37\0\0\0\15\0\0\0\5\0\0\0\0\0\0"
  "\0\12\0\0\0\377\360\357\355\377\327\324\315\377\331\326\316\377\310\306"
  "\276\377\270\266\257\377\272\267\260\377\273\270\261\377\274\271\262"
  "\377\274\271\263\377\274\271\263\377\274\271\262\377\273\270\262\377"
  "\273\270\261\377\273\267\261\377\271\266\260\377\271\265\256\377\267"
  "\264\255\377\266\263\254\377\265\262\252\377\263\260\250\377\261\257"
  "\247\377\257\254\244\377\256\252\243\377\254\250\241\377\251\246\237"
  "\377\247\243\234\377\244\240\230\377\241\235\225\377\235\231\221\377"
  "\230\225\216\377\224\221\212\377\221\216\206\377\216\213\202\377\212"
  "\207\200\377\206\202{\377\206\202{\377\237\232\221\377\233\230\216\377"
  "\230\224\213\377yvn\377\0\0\0\377\0\0\0A\0\0\0%\0\0\0\20\0\0\0\5\0\0"
  "\0\0\0\0\0\14\0\0\0\377\360\360\355\377\331\326\316\377\332\327\317\377"
  "\267\265\255\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\254\250"
  "\236\377\230\225\213\377\225\221\210\377wtl\377\0\0\0\377\0\0\0G\0\0"
  "\0(\0\0\0\22\0\0\0\6\0\0\0\0\0\0\0\14\0\0\0\377\361\360\356\377\331\326"
  "\316\377\332\327\317\377\267\264\255\377\0\0\0\377>C>\377BGB\377EIE\377"
  "HMH\377JNJ\377LRL\377PTP\377QUQ\377RXR\377RXR\377SYS\377SXS\377SWS\377"
  "QWQ\377QWQ\377NTN\377MRM\377LQL\377KQK\377JNJ\377HKH\377EIE\377DHD\377"
  "\77D\77\377<A<\3777;7\377262\377/2/\377(+(\377$($\377\0\0\0\377\264\257"
  "\245\377\226\221\210\377\222\215\204\377tqi\377\0\0\0\377\0\0\0I\0\0"
  "\0*\0\0\0\23\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\360\360\355\377\327\324"
  "\315\377\331\325\316\377\265\262\253\377\0\0\0\377595\377\235\236\235"
  "\377\236\240\236\377\237\241\237\377\241\243\241\377\242\244\242\377"
  "\243\245\243\377\241\243\241\377\231\234\231\377\222\225\222\377\213"
  "\216\213\377\202\204\202\377y}y\377ptp\377ili\377^c^\377TYT\377KOK\377"
  "AFA\377@D@\377\77C\77\377=A=\377;>;\3776;6\377383\377/2/\377+/+\377$"
  "($\377!%!\377\35\40\35\377\0\0\0\377\261\254\242\377\222\215\204\377"
  "\216\212\201\377qng\377\0\0\0\377\0\0\0K\0\0\0+\0\0\0\24\0\0\0\7\0\0"
  "\0\0\0\0\0\14\0\0\0\377\355\354\351\377\325\321\312\377\327\323\314\377"
  "\263\260\251\377\0\0\0\377BHB\377\244\246\244\377\246\251\246\377\247"
  "\252\247\377\252\255\252\377\254\256\254\377\245\250\245\377\240\244"
  "\240\377\231\235\231\377\223\227\223\377\214\220\214\377\205\212\205"
  "\377|\201|\377u{u\377lpl\377did\377[_[\377X]X\377U[U\377SZS\377QUQ\377"
  "QUQ\377LQL\377JPJ\377CHC\377>C>\3777<7\377020\377+/+\377&)&\377\0\0\0"
  "\377\257\251\240\377\216\211\200\377\212\206~\377okd\377\0\0\0\377\0"
  "\0\0K\0\0\0+\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\354\353\351"
  "\377\323\317\307\377\323\321\311\377\261\256\246\377\0\0\0\377;>;\377"
  "\237\242\237\377\242\244\242\377\243\245\243\377\240\242\240\377\231"
  "\234\231\377\223\227\223\377\216\220\216\377\207\213\207\377\202\206"
  "\202\377z}z\377rvr\377ini\377afa\377Y_Y\377RVR\377QUQ\377NRN\377LRL\377"
  "KPK\377INI\377FKF\377DHD\377AFA\377:>:\3776;6\377040\377*.*\377%'%\377"
  "\37\"\37\377\0\0\0\377\254\247\234\377\212\205}\377\206\202z\377kha\377"
  "\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377"
  "\354\352\350\377\320\314\304\377\321\315\305\377\256\253\244\377\0\0"
  "\0\377JMJ\377\250\252\250\377\247\252\247\377\242\244\242\377\235\240"
  "\235\377\232\234\232\377\224\230\224\377\221\226\221\377\216\222\216"
  "\377\210\215\210\377\203\207\203\377{\200{\377sys\377mrm\377jpj\377i"
  "ni\377ele\377eje\377chc\377^d^\377\\c\\\377[`[\377W]W\377RYR\377KNK\377"
  "EKE\377=C=\3779<9\377/4/\377(*(\377\0\0\0\377\251\244\231\377\206\202"
  "y\377\203\177v\377hd]\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0"
  "\0\0\0\0\0\0\14\0\0\0\377\352\351\346\377\315\311\300\377\316\312\302"
  "\377\254\251\241\377\0\0\0\377@D@\377\232\234\232\377\224\227\224\377"
  "\217\222\217\377\212\215\212\377\206\212\206\377\201\205\201\377~\202"
  "~\377y~y\377uzu\377nsn\377gmg\377djd\377chc\377`e`\377^d^\377\\b\\\377"
  "Z_Z\377W]W\377VZV\377RXR\377PVP\377MRM\377GLG\377CGC\377:\77:\3775:5"
  "\377-2-\377(+(\377!%!\377\0\0\0\377\246\241\226\377\202~u\377\177|s\377"
  "eb[\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0"
  "\0\377\350\347\345\377\311\305\275\377\312\307\277\377\251\245\236\377"
  "\0\0\0\377QTQ\377\226\231\226\377\222\225\222\377\215\222\215\377\213"
  "\217\213\377\210\215\210\377\206\213\206\377\205\213\205\377\202\211"
  "\202\377\202\211\202\377\200\206\200\377}\204}\377z\201z\377y\200y\377"
  "x~x\377v|v\377tzt\377pup\377msm\377jqj\377hmh\377djd\377`f`\377Y_Y\377"
  "TYT\377INI\377CJC\377:>:\377262\377).)\377\0\0\0\377\243\236\223\377"
  "~zq\377{xo\377b_W\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0"
  "\0\0\0\0\14\0\0\0\377\346\344\342\377\304\300\267\377\307\303\273\377"
  "\245\241\232\377\0\0\0\377EJE\377\201\205\201\377}\200}\377z~z\377uz"
  "u\377rwr\377pup\377ntn\377ntn\377pvp\377pvp\377qwq\377qwq\377ntn\377"
  "kqk\377ipi\377ioi\377dkd\377aga\377^c^\377[a[\377X^X\377TYT\377MSM\377"
  "FJF\377@D@\3777<7\377/4/\377*-*\377\"&\"\377\0\0\0\377\240\232\217\377"
  "yvm\377xtk\377_\\U\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0"
  "\0\0\0\0\14\0\0\0\377\336\335\331\377\300\275\264\377\303\277\267\377"
  "\241\235\225\377\0\0\0\377WZW\377\201\205\201\377|\202|\377|\201|\377"
  "{\200{\377z\177z\377x~x\377|\203|\377\202\210\202\377\205\213\205\377"
  "\207\215\207\377\210\216\210\377\206\214\206\377\205\214\205\377\204"
  "\212\204\377\201\206\201\377|\203|\377y\200y\377w|w\377rxr\377ovo\377"
  "lql\377djd\377`f`\377W\\W\377NUN\377EIE\377>C>\377474\377+/+\377\0\0"
  "\0\377\234\226\213\377uri\377spg\377\\YQ\377\0\0\0\377\0\0\0K\0\0\0,"
  "\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\334\332\326\377\275\272"
  "\260\377\277\272\261\377\235\231\221\377\0\0\0\377GMG\377jnj\377fif\377"
  "cgc\377bfb\377bhb\377gmg\377lrl\377rxr\377u{u\377w}w\377x~x\377w~w\377"
  "w}w\377u|u\377sxs\377qvq\377lrl\377ioi\377eke\377bgb\377^d^\377X]X\377"
  "SWS\377IPI\377CHC\377:>:\377373\377+-+\377\"&\"\377\0\0\0\377\232\224"
  "\211\377rne\377plc\377YUN\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0"
  "\7\0\0\0\0\0\0\0\14\0\0\0\377\330\327\323\377\270\264\253\377\272\266"
  "\255\377\231\225\215\377\0\0\0\377W\\W\377ioi\377flf\377fmf\377nsn\377"
  "sys\377z\201z\377\200\206\200\377\204\212\204\377\211\217\211\377\213"
  "\221\213\377\214\223\214\377\214\222\214\377\213\221\213\377\211\220"
  "\211\377\207\215\207\377\204\212\204\377\201\207\201\377}\205}\377y\200"
  "y\377v{v\377qwq\377jqj\377bhb\377[`[\377PTP\377HNH\377;\77;\377272\377"
  "+/+\377\0\0\0\377\227\221\205\377nja\377mg_\377VRK\377\0\0\0\377\0\0"
  "\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\326\325\321\377"
  "\264\260\247\377\265\261\250\377\224\221\211\377\0\0\0\377HMH\377OTO"
  "\377QWQ\377W\\W\377^d^\377bhb\377ioi\377ouo\377sys\377v}v\377y\177y\377"
  "{\202{\377{\201{\377z\200z\377y\200y\377w~w\377szs\377qwq\377ntn\377"
  "jqj\377flf\377`e`\377Z`Z\377SYS\377KQK\377BGB\377;\77;\377161\377*,*"
  "\377#%#\377\0\0\0\377\223\216\203\377jf]\377ie\\\377SPI\377\0\0\0\377"
  "\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\323\322\317"
  "\377\260\253\242\377\261\255\243\377\221\216\205\377\0\0\0\377X^X\377"
  "[b[\377bfb\377fmf\377lrl\377rxr\377z\200z\377\200\205\200\377\205\213"
  "\205\377\207\216\207\377\212\221\212\377\214\222\214\377\215\222\215"
  "\377\213\222\213\377\212\221\212\377\210\217\210\377\207\214\207\377"
  "\203\212\203\377\200\207\200\377|\204|\377w|w\377qwq\377lpl\377cic\377"
  "Z_Z\377PUP\377GLG\377=B=\377171\377,/,\377\0\0\0\377\221\213\200\377"
  "gcZ\377ebY\377PNF\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0"
  "\0\0\0\0\14\0\0\0\377\321\317\313\377\253\246\235\377\255\250\236\377"
  "\215\211\201\377\0\0\0\377HMH\377KOK\377\331\333\331\377\241\243\241"
  "\377bgb\377`f`\377flf\377kqk\377pwp\377tzt\377w}w\377w~w\377y\177y\377"
  "x~x\377w}w\377u{u\377sys\377pwp\377nsn\377joj\377did\377_e_\377Y_Y\377"
  "RWR\377HOH\377AEA\3779>9\377373\377)-)\377#'#\377\0\0\0\377\216\211|"
  "\377d`W\377b^U\377NKD\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0"
  "\0\0\0\0\0\0\14\0\0\0\377\315\313\307\377\246\241\230\377\250\243\231"
  "\377\210\205}\377\0\0\0\377TZT\377Y^Y\377\377\377\377\377\377\377\377"
  "\377\360\361\360\377\277\301\277\377\206\213\206\377z\201z\377~\205~"
  "\377\203\211\203\377\204\213\204\377\206\215\206\377\207\216\207\377"
  "\207\215\207\377\205\214\205\377\205\214\205\377\203\211\203\377\201"
  "\207\201\377}\204}\377x\200x\377szs\377msm\377gog\377_f_\377X]X\377M"
  "TM\377DJD\377<A<\377272\377+/+\377\0\0\0\377\214\207z\377a]T\377_[R\377"
  "KHA\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0"
  "\0\377\312\311\304\377\240\233\222\377\242\236\224\377\204\200x\377\0"
  "\0\0\377DID\377IOI\377mpm\377\247\252\247\377\327\331\327\377\374\374"
  "\374\377\373\373\373\377\314\316\314\377\226\233\226\377lrl\377ouo\377"
  "pup\377pwp\377pwp\377pvp\377ouo\377nsn\377jqj\377fmf\377cic\377_c_\377"
  "X_X\377TZT\377MSM\377EJE\377=A=\3776;6\377040\377(+(\377\"%\"\377\0\0"
  "\0\377\212\204x\377^ZQ\377[XO\377HF\77\377\0\0\0\377\0\0\0K\0\0\0,\0"
  "\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\305\303\276\377\233\226\215"
  "\377\234\231\216\377\200|s\377\0\0\0\377QWQ\377UZU\377Z^Z\377]d]\377"
  "bhb\377{\201{\377\312\314\312\377\377\377\377\377\377\377\377\377w}w"
  "\377y~y\377y\201y\377{\202{\377z\202z\377z\202z\377y\200y\377x}x\377"
  "szs\377qwq\377mtm\377ipi\377did\377\\b\\\377X\\X\377PUP\377EKE\377\77"
  "D\77\377:=:\377151\377*.*\377\0\0\0\377\207\202u\377[WN\377YUL\377FC"
  "<\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0"
  "\377\274\270\262\377\226\222\210\377\230\224\212\377{xo\377\0\0\0\377"
  "BFB\377DJD\377dgd\377\223\226\223\377\272\275\272\377\367\367\367\377"
  "\373\373\373\377\304\306\304\377\177\204\177\377`e`\377aha\377bhb\377"
  "chc\377bhb\377bhb\377afa\377_d_\377[a[\377Y]Y\377TYT\377RWR\377MQM\377"
  "HNH\377BHB\377>C>\3777;7\377262\377+/+\377$'$\377\40\"\40\377\0\0\0\377"
  "\205\177r\377WTK\377URI\377DA:\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0"
  "\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\267\263\256\377\222\216\204\377\223"
  "\216\204\377vsj\377\0\0\0\377LSL\377PTP\377\377\377\377\377\377\377\377"
  "\377\351\351\351\377\244\250\244\377pvp\377eje\377fnf\377hoh\377jqj\377"
  "jpj\377ipi\377jpj\377hnh\377glg\377flf\377did\377_e_\377]c]\377Y^Y\377"
  "S[S\377MRM\377HLH\377CJC\377=B=\3777>7\377262\377.0.\377&*&\377\0\0\0"
  "\377\203}o\377TQH\377ROF\377B>7\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24"
  "\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\261\256\251\377\215\210\177\377\216"
  "\211\177\377sof\377\0\0\0\377:@:\377>C>\377\320\321\320\377\200\204\200"
  "\377KOK\377JOJ\377LQL\377NSN\377PTP\377QVQ\377RWR\377\322\324\322\377"
  "\365\365\365\377\372\373\372\377\372\372\372\377\372\372\372\377\307"
  "\311\307\377w{w\377FLF\377BHB\377@D@\377>B>\3779>9\377595\377272\377"
  "-2-\377).)\377&)&\377\"%\"\377\34\40\34\377\0\0\0\377\201|n\377QMD\377"
  "OLC\377\77<5\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0"
  "\0\14\0\0\0\377\253\250\242\377\207\203y\377\211\205z\377okc\377\0\0"
  "\0\377CIC\377EKE\377JPJ\377JPJ\377LSL\377PUP\377TYT\377T[T\377X]X\377"
  "X^X\377W]W\377X^X\377X]X\377U\\U\377RXR\377QWQ\377NSN\377MRM\377JPJ\377"
  "HKH\377BJB\377AEA\377=A=\3779=9\3776<6\377/5/\377.1.\377+.+\377&,&\377"
  "!$!\377\0\0\0\377\177yl\377MJA\377LI@\377=:3\377\0\0\0\377\0\0\0K\0\0"
  "\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\251\246\240\377\202~"
  "u\377\204\177u\377jf^\377\0\0\0\377585\3774:4\3776<6\3778=8\3779>9\377"
  "=A=\377>C>\377\77C\77\377>B>\377@D@\377@E@\377@C@\377>C>\377<A<\377="
  "B=\377:\77:\3779=9\3775:5\377393\377373\377030\377,0,\377*-*\377)+)\377"
  "'+'\377$'$\377\40$\40\377\35\"\35\377\33\36\33\377\30\34\30\377\0\0\0"
  "\377}xh\377KH\77\377KH>\377<:2\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0"
  "\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\244\241\232\377}yo\377\177{p\377fc"
  "Z\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377|wg\377KH>\377KH>\377"
  "<:2\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0"
  "\0\377\237\234\226\377ytj\377zuk\377\224\217\203\377\256\251\233\377"
  "\260\251\234\377\257\253\235\377\261\253\235\377\261\253\235\377\261"
  "\253\236\377\260\253\235\377\257\251\233\377\256\250\232\377\255\250"
  "\231\377\253\245\230\377\252\243\225\377\250\242\224\377\247\240\222"
  "\377\245\236\220\377\242\234\216\377\237\231\212\377\235\227\210\377"
  "\233\226\206\377\231\223\204\377\230\222\203\377\225\217\200\377\223"
  "\214}\377\221\211{\377\216\211w\377\215\206u\377\214\206t\377\212\204"
  "r\377\210\202q\377\207\201o\377\206\200n\377\205\177m\377vqa\377KH>\377"
  "KH>\377<:2\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0"
  "\14\0\0\0\377\235\232\224\377tpe\377uqg\377uqg\377uqf\377vrg\377vrh\377"
  "uqg\377upf\377upf\377tpe\377sod\377rnc\377pla\377mi_\377mh^\377jf\\\377"
  "hdY\377faW\377c_U\377a]S\377_ZQ\377]ZO\377[XM\377YVK\377XTI\377WSH\377"
  "URG\377TPE\377RND\377PMC\377PLB\377NKA\377MJ@\377MI\77\377LI\77\377K"
  "H>\377KH>\377KH>\377<92\377\0\0\0\377\0\0\0K\0\0\0,\0\0\0\24\0\0\0\7"
  "\0\0\0\0\0\0\0\14\0\0\0\377\225\223\214\377oka\377qmc\377qmc\377qlb\377"
  "rmc\377rnc\377rmb\377rlb\377qlb\377pka\377ok`\377nj_\377kg\\\377jeZ\377"
  "idY\377fbW\377c`U\377b^T\377`\\R\377^ZO\377\\XM\377ZWL\377YUJ\377WSI"
  "\377VSH\377URG\377TPE\377SOD\377QNC\377PLB\377OKA\377]YP\377okc\377n"
  "kc\377ROF\377KH>\377KH>\377KH>\377=;3\377\0\0\0\377\0\0\0K\0\0\0,\0\0"
  "\0\24\0\0\0\7\0\0\0\0\0\0\0\14\0\0\0\377\217\214\205\375kg]\377lh^\377"
  "mi_\377mh^\377mi_\377mi^\377mi^\377ni_\377lh]\377kg\\\377jf[\377ieZ\377"
  "gcX\377eaV\377d`U\377a]S\377`\\Q\377^ZO\377]YN\377\\XL\377ZVJ\377YUJ"
  "\377XTI\377VSH\377UQG\377TPE\377SOE\377QNC\377PMC\377OLB\377OK@\377w"
  "tl\377MI\77\377LI\77\377A>6\377KH>\377KH>\377KH>\377<:2\377\0\0\0\377"
  "\0\0\0J\0\0\0+\0\0\0\24\0\0\0\7\0\0\0\0\0\0\0\13\0\0\0\377\215\213\202"
  "\374heZ\377if[\377jf\\\377kf\\\377jf\\\377jf\\\377kf\\\377jf\\\377if"
  "[\377idZ\377hcZ\377gbX\377eaV\377c_U\377b^T\377`\\Q\377^ZO\377]XN\377"
  "\\XN\377ZVL\377YUJ\377WTI\377WSH\377URG\377TPF\377SOE\377RND\377PMC\377"
  "OLB\377OK@\377NJ@\377MI\77\377@<4\377>;3\377KH>\377KH>\377KH>\377KH>"
  "\377EB:\376\0\0\0\377\0\0\0G\0\0\0)\0\0\0\23\0\0\0\7\0\0\0\0\0\0\0\12"
  "\0\0\0\377omf\343NLC\377PMF\377QNF\377QNF\377QNF\377QME\377QNF\377QN"
  "F\377QME\377QME\377PLD\377OLC\377NJB\377LIA\377KI@\377JG>\377HE=\377"
  "GC<\377GC<\377EA:\377C@8\377B\77""8\377B>7\377A>7\377@=5\377\77<4\377"
  ">;3\377=:2\377<92\377<91\377;81\377:80\377:70\377:70\377970\377970\377"
  "970\377:80\377\77<4\364\0\0\0\377\0\0\0A\0\0\0%\0\0\0\21\0\0\0\6\0\0"
  "\0\0\0\0\0\11\0\0\0Y\0\0\0\377\0\0\0\377\0\0\0\377utr\366srl\377xvp\377"
  "xwq\377}{v\377\201\177z\377\205\203\177\377\211\207\202\377\213\210\204"
  "\377\217\216\212\377\221\217\213\377\222\220\214\377\220\216\213\377"
  "\217\216\211\377\214\212\207\377\213\210\204\377\210\206\202\377\207"
  "\204\201\377\203\201}\377\201\177z\377\177}x\377}{w\377yws\377wup\377"
  "srl\377poi\377nlg\377ljf\377lid\377ljd\377lke\377mjd\377nkd\377GD>\372"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\206\0\0\0""7\0\0\0\36\0\0\0\15\0"
  "\0\0\5\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0!\0\0\0""9\0\0\0\377fec\356LIC\374"
  "LIB\377OMF\377USL\377YWQ\377^\\V\377db\\\377iga\377nkg\377qok\377qoj"
  "\377omg\377nke\377jhc\377igb\377ge`\377eb]\377da\\\377`^X\377\\[T\377"
  "YXQ\377VTM\377RPI\377MKD\377IG@\377FD<\377FC<\377DB:\377CA8\377DA8\377"
  "D@8\377C@7\377.+%\362\0\0\0\377\0\0\0i\0\0\0U\0\0\0\77\0\0\0(\0\0\0\25"
  "\0\0\0\11\0\0\0\3\0\0\0\0\0\0\0\4\0\0\0\12\0\0\0\25\0\0\0&\0\0\0n\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\214"
  "\0\0\0O\0\0\0<\0\0\0)\0\0\0\31\0\0\0\15\0\0\0\5\0\0\0\2\0\0\0\0\0\0\0"
  "\2\0\0\0\5\0\0\0\14\0\0\0\25\0\0\0#\0\0\0""2\0\0\0B\0\0\0N\0\0\0V\0\0"
  "\0Z\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0]\0"
  "\0\0]\0\0\0]\0\0\0]\0\0\0]\0\0\0]\0\0\0]\0\0\0]\0\0\0]\0\0\0]\0\0\0]"
  "\0\0\0]\0\0\0]\0\0\0]\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0\\\0\0\0["
  "\0\0\0W\0\0\0O\0\0\0C\0\0\0""4\0\0\0$\0\0\0\27\0\0\0\15\0\0\0\6\0\0\0"
  "\2\0\0\0\1\0\0\0\0\0\0\0\1\0\0\0\2\0\0\0\5\0\0\0\12\0\0\0\22\0\0\0\34"
  "\0\0\0&\0\0\0/\0\0\0""5\0\0\0""9\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0"
  "\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:"
  "\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0:\0\0\0"
  ":\0\0\0:\0\0\0""9\0\0\0""5\0\0\0""0\0\0\0(\0\0\0\35\0\0\0\23\0\0\0\12"
  "\0\0\0\5\0\0\0\2\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0"
  "\0\4\0\0\0\7\0\0\0\14\0\0\0\22\0\0\0\27\0\0\0\32\0\0\0\34\0\0\0\35\0"
  "\0\0\35\0\0\0\35\0\0\0\35\0\0\0\35\0\0\0\35\0\0\0\35\0\0\0\36\0\0\0\36"
  "\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0"
  "\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\36\0\0\0\35\0\0\0\35\0\0\0\35\0"
  "\0\0\35\0\0\0\35\0\0\0\35\0\0\0\33\0\0\0\27\0\0\0\22\0\0\0\15\0\0\0\10"
  "\0\0\0\4\0\0\0\2\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\1\0\0\0\2\0\0\0\4\0\0\0\7\0\0\0\11\0\0\0\12\0\0\0\13\0\0\0"
  "\13\0\0\0\13\0\0\0\13\0\0\0\13\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0"
  "\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14"
  "\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0\14\0\0\0"
  "\13\0\0\0\13\0\0\0\13\0\0\0\13\0\0\0\12\0\0\0\11\0\0\0\7\0\0\0\4\0\0"
  "\0\2\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\2\0\0\0\2\0\0\0\2\0\0"
  "\0\2\0\0\0\2\0\0\0\2\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3"
  "\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0"
  "\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\2\0\0\0\2"
  "\0\0\0\2\0\0\0\2\0\0\0\2\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1"
  "\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0"
  "\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_window_maximize[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\351"
  "\351\351\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\0\0\0\377\377\266Z\377"
  "\0\0\0\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270"
  "\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354"
  "\354\377\354\354\354\377\0\0\0\377\377p8\377\377\302a\377\377\265Y\377"
  "\0\0\0\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\0\0\0"
  "\377\377\\.\377\377\275^\377\377\306b\377\377\310c\377\377\277_\377\0"
  "\0\0\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\377\377\377\377\377\354\354\354\377\0\0\0\377\244@\40\377\244"
  "@\40\377\377\310c\377\226\\-\377\223W+\377\0\0\0\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\0\0\0\377\377\306"
  "c\377\0\0\0\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270"
  "\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377"
  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\223"
  "W+\0\377\277_\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270"
  "\270\270\377\0\0\0\377\0\0\0\0\377\\.\0\244@\40\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\226\\-\0\377\310c\0\377\265Y\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\377p8\0\377\275^\0\244@\40"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\377\306c\0\377\310c\0\377\306b\0\377\302a"
  "\0\377\266Z\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377"
  "\377\302a\0\377\306b\0\377\310c\0\377\306c\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\244@\40\0\377\275^\0\377p8\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\377\265Y\0\377\310c\0\226\\-\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\244@\40\0\377\\.\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
  "\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\0\0\0\0\377\277_\0\223W+\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\0\0\0\377\377\306"
  "c\377\0\0\0\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270"
  "\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\0\0\0\377\223W+\377\226\\-\377\377\310c\377\244@\40\377"
  "\244@\40\377\0\0\0\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\0\0\0\377"
  "\377\277_\377\377\310c\377\377\306b\377\377\275^\377\377\\.\377\0\0\0"
  "\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\0\0\0\377\377"
  "\265Y\377\377\302a\377\377p8\377\0\0\0\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\0\0\0\377\377"
  "\266Z\377\0\0\0\377\354\354\354\377\354\354\354\377\354\354\354\377\270"
  "\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\344\344\344\377"
  "\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377\0\0"
  "\0\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377"
  "\205\205\205\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_window_maximize_width[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\377\306c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\223W+\0\226"
  "\\-\0\377\310c\0\244@\40\0\244@\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\277_\0\377\310"
  "c\0\377\306b\0\377\275^\0\377\\.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\265Y\0"
  "\377\302a\0\377p8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\266Z\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\344\344\344\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\354\354\354\377\354\354\354\377\0\0\0\377\0\0\0"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\0\0"
  "\0\377\0\0\0\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\0\0\0\377\377\\.\377\244@\40\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\223W+\377\377\277_\377\0\0\0\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\377\377\377\377\0\0\0\377\377p8\377\377\275^\377\244"
  "@\40\377\0\0\0\377\0\0\0\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\0\0\0\377\0\0\0\377\226\\-\377\377\310c\377"
  "\377\265Y\377\0\0\0\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\377\0\0\0\377\377\266Z\377\377\302a\377\377\306b\377"
  "\377\310c\377\377\306c\377\0\0\0\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\0\0\0\377\377\306c\377\377\310c\377"
  "\377\306b\377\377\302a\377\377\266Z\377\0\0\0\377\0\0\0\377\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\0\0\0\377\377\265Y\377"
  "\377\310c\377\226\\-\377\0\0\0\377\0\0\0\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\0\0\0\377\0\0\0\377\244@\40"
  "\377\377\275^\377\377p8\377\0\0\0\377\270\270\270\377\0\0\0\377\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377"
  "\0\0\0\377\377\277_\377\223W+\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\244@\40\377\377\\.\377\0\0\0\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\354\354\354\377\354\354\354\377\0\0\0\377\0\0\0"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\0\0"
  "\0\377\0\0\0\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\351\351\351\377\270"
  "\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270"
  "\270\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270"
  "\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377"
  "\270\270\270\377\270\270\270\377\270\270\270\377\205\205\205\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
  "p8\0\377\302a\0\377\265Y\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\\.\0\377\275^"
  "\0\377\306b\0\377\310c\0\377\277_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\244@\40\0\244@\40"
  "\0\377\310c\0\226\\-\0\223W+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\306"
  "c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_window_minimize[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\377\377\306c\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\223W+\377\226\\-\377\377\310c\377\244@\40\377\244@\40\377\0\0\0"
  "\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\377\377\277_\377\377\310c\377\377\306b\377\377\275^\377\377"
  "\\.\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\265Y\377\377\302a\377\377p8\377"
  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\266Z\377\0\0\0\377\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\344\344\344\377\0\0\0\377"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270"
  "\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
  "\351\351\351\377\270\270\270\377\270\270\270\377\270\270\270\377\270"
  "\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270"
  "\270\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270"
  "\377\270\270\270\377\270\270\270\377\270\270\270\377\205\205\205\377"
  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
  "\266Z\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377p8\377\377\302"
  "a\377\377\265Y\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\\.\377\377\275^\377"
  "\377\306b\377\377\310c\377\377\277_\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\244@\40\377"
  "\244@\40\377\377\310c\377\226\\-\377\223W+\377\0\0\0\377\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\377\377\306c\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_window_minimize_width[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\351\351\351\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270"
  "\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
  "\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\223W+\377\377"
  "\277_\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\\.\377\244@\40\377\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\226\\"
  "-\377\377\310c\377\377\265Y\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0"
  "\0\0\377\377p8\377\377\275^\377\244@\40\377\0\0\0\377\0\0\0\377\0\0\0"
  "\377\377\306c\377\377\310c\377\377\306b\377\377\302a\377\377\266Z\377"
  "\0\0\0\377\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270"
  "\270\270\377\0\0\0\377\0\0\0\377\377\266Z\377\377\302a\377\377\306b\377"
  "\377\310c\377\377\306c\377\0\0\0\377\0\0\0\377\0\0\0\377\244@\40\377"
  "\377\275^\377\377p8\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\377"
  "\377\265Y\377\377\310c\377\226\\-\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0"
  "\0\0\244@\40\377\377\\.\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0"
  "\0\0\0\0\0\0\0\0\377\377\277_\377\223W+\377\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270"
  "\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\344\344\344\377\270\270\270\377\270\270\270\377\270\270\270\377"
  "\270\270\270\377\270\270\270\377\270\270\270\377\205\205\205\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_window_split[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\377\377\377\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\377\377\377\0\344\344\344\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\344\344\344\377\0\0\0\377\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
  "\377\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270"
  "\377\0\0\0\377\0\0\0\0\344\344\344\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\270\270\270\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377"
  "\0\0\0\377\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\377\377\377\377\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\270\270\270\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0"
  "\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0"
  "\0\377\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\377\377\377\377\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\270\270\270\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0"
  "\377\351\351\351\377\270\270\270\377\270\270\270\377\270\270\270\377"
  "\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377\270"
  "\270\270\377\270\270\270\377\270\270\270\377\205\205\205\377\0\0\0\377"
  "\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\351\351\351\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\205\205\205\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\344\344\344\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0"
  "\0\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\344\344\344\377\0\0\0\377"
  "\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\377\377\377\0\0\0\0\377\377\377\377\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\377\377"
  "\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0"
  "\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\377\377\377\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\270"
  "\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377"
  "\377\377\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270"
  "\270\377\0\0\0\377\0\0\0\0\270\270\270\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\351\351\351\0\0\0\0\377\377\377\377\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\205\205\205"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\377\351\351\351\377\270\270\270\377\270\270\270\377\270\270\270"
  "\377\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377"
  "\270\270\270\377\270\270\270\377\270\270\270\377\205\205\205\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


/* GdkPixbuf RGBA C-Source image dump */

static const guint8 stock_vim_window_split_vertical[] =
{ ""
  /* Pixbuf magic (0x47646b50) */
  "GdkP"
  /* length: header (24) + pixel_data (2304) */
  "\0\0\11\30"
  /* pixdata_type (0x1010002) */
  "\1\1\0\2"
  /* rowstride (96) */
  "\0\0\0`"
  /* width (24) */
  "\0\0\0\30"
  /* height (24) */
  "\0\0\0\30"
  /* pixel_data: */
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\0\377\377\377"
  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
  "\0\377\377\377\0\351\351\351\0\0\0\0\0\377\377\377\0\377\377\377\0\377"
  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\351"
  "\351\351\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\351\351"
  "\351\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377"
  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
  "\377\377\377\351\351\351\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0"
  "\0\377\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0"
  "\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270"
  "\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\377"
  "\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270"
  "\270\270\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377"
  "\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
  "\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0"
  "\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\270\270"
  "\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354"
  "\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0"
  "\377\377\377\377\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0"
  "\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377"
  "\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377"
  "\377\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\354\354\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354\354"
  "\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\377\377\377\377\377\354"
  "\354\354\377\354\354\354\377\354\354\354\377\354\354\354\377\354\354"
  "\354\377\354\354\354\377\270\270\270\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\377\344\344\344\377\270\270\270\377\270\270\270\377\270"
  "\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377\205\205"
  "\205\377\0\0\0\377\0\0\0\0\0\0\0\377\344\344\344\377\270\270\270\377"
  "\270\270\270\377\270\270\270\377\270\270\270\377\270\270\270\377\270"
  "\270\270\377\205\205\205\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
  "\0\0\0\0\0\0\0\0\0\0\0\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\344\344\344\0\0\0\0\0\344\344\344\0\270\270\270\0\270"
  "\270\270\0\270\270\270\0\270\270\270\0\270\270\270\0\270\270\270\0\205"
  "\205\205\0\0\0\0\0\344\344\344\0\270\270\270\0\270\270\270\0\270\270"
  "\270\0\270\270\270\0\270\270\270\0\270\270\270\0\205\205\205\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};


                                                                                                                                          vim74/pixmaps/tb_ctags.xpm                                                                          0000644 0001750 0001750 00000001375 11373477654 014546  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_ctags_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
"O	m black	c #888800",
"+	s topShadowColor	m none	c #DCDEE5",
"@	s iconColor6	m none	c #FFFF00",
/* pixels */
"     .. .....     ",
"    .XX.XXXXX.    ",
"    .XXXXXXXXX.   ",
"    .XX.XXXX..X.  ",
"     .. ....o ..  ",
"   OO++O+...+O+.+ ",
"  Oo@@@@@...o@@@.o",
" Oo@@@@@@...o@@@.o",
"Oo@+o+@@@...o@@@.o",
"O@@o.o@@@...o@@@.o",
"o@@+o+@@@...o@@@.o",
"o.@@@@@@@...o@@@.o",
" o.@@@@@@...o@@@.o",
"  o.........o....o",
"   oooooo...oooooo",
"         ...o     ",
"         ...o     ",
"          ooo     "};
                                                                                                                                                                                                                                                                   vim74/pixmaps/tb_open.xpm                                                                           0000644 0001750 0001750 00000001402 11373477654 014375  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_open_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s bottomShadowColor	m black	c #5D6069",
"o	s iconColor2	m none	c #FFFFFF",
"O	s iconGray1	m none	c #dedede",
"+	s iconGray5	m black	c #737373",
"@	s iconGray3	m none	c #adadad",
/* pixels */
"                  ",
"    .........X    ",
"    .oooooo.o.X   ",
"    .oooooo.oo.X  ",
"    .oooooo....X  ",
"  ...ooooooooo... ",
"  .O.OOOOOOOOo.+. ",
".............O.+.X",
".oooooooooooo..+.X",
" .o@@@@@@@@@@+.+.X",
" .o@@@@@@@@@@@.+.X",
"  .o@@@@@@@@@@+..X",
"  .o@@@@@@@@@@@..X",
"   .o+++++++++++.X",
"   ..............X",
"     XXXXXXXXXXXXX",
"                  ",
"                  "};
                                                                                                                                                                                                                                                              vim74/pixmaps/tb_help.xpm                                                                           0000644 0001750 0001750 00000001170 11373477654 014366  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_help_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 3 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"                  ",
"      .....X      ",
"     ..  X..X     ",
"    ..X   ...     ",
"    ..X   ...     ",
"    X..  X..X     ",
"         ..X      ",
"        ..        ",
"       ..X        ",
"       ..X        ",
"                  ",
"       ..X        ",
"       ..X        ",
"       ..X        ",
"        XX        ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                                                                                                        vim74/pixmaps/tb_save.xpm                                                                           0000644 0001750 0001750 00000001275 11373477654 014402  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_save_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconGray2	m none	c #bdbdbd",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
" ..............   ",
" .X.oooooooo.o.   ",
" .X.oooooooo...O  ",
" .X.oooooooo.X.O  ",
" .X.oooooooo.X.O  ",
" .X.oooooooo.X.O  ",
" .X.oooooooo.X.O  ",
" .XX........XX.O  ",
" .XXXXXXXXXXXX.O  ",
" .XX.........X.O  ",
" .XX......oo.X.O  ",
" .XX......oo.X.O  ",
" .XX......oo.X.O  ",
"  .............O  ",
"   OOOOOOOOOOOOO  ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                                   vim74/pixmaps/tb_find_next.xpm                                                                      0000644 0001750 0001750 00000001375 11373477654 015423  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_find_next_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s iconGray2	m none	c #bdbdbd",
"O	m black	c #880000",
"+	s bottomShadowColor	m black	c #5D6069",
"@	s iconColor3	m black	c #FF0000",
/* pixels */
"                  ",
"  .........       ",
"  .XXXXXXX..      ",
"  .XXXXXXX.o.     ",
"  .XOXXXXX....    ",
"  +XOOXXXXXXX.    ",
"OOOOO@OXXX....    ",
"O@@@@@@OX.oooo.   ",
"O@@@@@@@OoXXooo.  ",
"O@@@@@@O.oXoooo.  ",
"OOOOO@OX.oooooo.  ",
"  +XOOXX.oooXoo.  ",
"  .XOXXXX.oooo.+  ",
"  .XXXXXXX....+.. ",
"  .XXXXXXXXXX.+...",
"  ............+ ..",
"     ++++++++++   ",
"                  "};
                                                                                                                                                                                                                                                                   vim74/pixmaps/tb_close.xpm                                                                          0000644 0001750 0001750 00000001376 11373477654 014553  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_close_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	c #880000	m black",
"X	s iconColor1	m black	c #000000",
"o	s iconColor3	m black	c #FF0000",
"O	s topShadowColor	m none	c #DCDEE5",
"+	s iconColor2	m none	c #FFFFFF",
"@	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"  ..XXXXXXXXX.    ",
" .oo.OOOOOOO.o.   ",
"  .oo.O+OOO.oo.   ",
"   .oo.OOO.oo.@   ",
"   X.oo.O.oo.X@   ",
"   XO.oo.oo.+X@   ",
"   XOO.ooo.O+X@   ",
"   XOO.ooo.O+X@   ",
"   XO.oo.oo.+X@   ",
"   X.oo.O.oo.X@   ",
"   .oo.OOO.oo.@   ",
"  .oo.OOOOO.oo.   ",
" .oo.OOOOOOO.oo.  ",
"  ..+++++++++.o.  ",
"   XXXXXXXXXXX.   ",
"      @@@@@@@@@   ",
"                  "};
                                                                                                                                                                                                                                                                  vim74/pixmaps/tb_find_prev.xpm                                                                      0000644 0001750 0001750 00000001375 11373477654 015421  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_find_prev_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s iconGray2	m none	c #bdbdbd",
"O	s bottomShadowColor	m black	c #5D6069",
"+	m black	c #880000",
"@	s iconColor3	m black	c #FF0000",
/* pixels */
"                  ",
"  .........       ",
"  .XXXXXXX..      ",
"  .XXXXXXX.o.     ",
"  OX+XXXXX....    ",
"  o++XXXXXXXX.    ",
"  +@+++++X....    ",
" +@@@@@@+.oooo.   ",
"+@@@@@@@.oXXooo.  ",
" +@@@@@@.oXoooo.  ",
"  +@++++.oooooo.  ",
"  o++XXX.oooXoo.  ",
"  OX+XXXX.oooo.O  ",
"  .XXXXXXX....O.. ",
"  .XXXXXXXXXX.O...",
"  ............O ..",
"     OOOOOOOOOO   ",
"                  "};
                                                                                                                                                                                                                                                                   vim74/pixmaps/tb_print.xpm                                                                          0000644 0001750 0001750 00000001360 11373477654 014573  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_print_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s iconGray2	m none	c #bdbdbd",
"O	s iconGray5	m black	c #737373",
"+	s bottomShadowColor	m black	c #5D6069",
"@	c #FF1144",
/* pixels */
"   .......        ",
"   .XXXXX..       ",
"   .XXXXX.X.      ",
"   .XXXXX....     ",
"   .XXXXXXXX.     ",
"   .XXXXXXXX.     ",
"  ..XXXXXXXX..    ",
"   .XXXXXXXX.O    ",
"................  ",
".XXXXXXXXXXXXXO.  ",
".X@@ooooooooooO.O ",
".XooooooooooooO.O ",
".XooooooooooooO.O ",
"................O ",
" .OOOOOOOOOOOO.OO ",
" ..............O  ",
"   OOOOOOOOOOOOO  ",
"                  "};
                                                                                                                                                                                                                                                                                vim74/pixmaps/error.xpm                                                                             0000644 0001750 0001750 00000003032 11373477654 014101  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * error_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"34 34 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor3	m black	c #FF0000",
"X	s bottomShadowColor	m black	c #5D6069",
"o	s iconColor2	m white	c #FFFFFF",
/* pixels */
"                                  ",
"            ........              ",
"          ............            ",
"        ................          ",
"       ..................         ",
"      ....................X       ",
"     ......................X      ",
"    ........................X     ",
"   .......o..........o.......X    ",
"   ......ooo........ooo......X    ",
"  ......ooooo......ooooo......X   ",
"  .......ooooo....ooooo.......X   ",
" .........ooooo..ooooo.........X  ",
" ..........oooooooooo..........X  ",
" ...........oooooooo...........XX ",
" ............oooooo............XX ",
" ............oooooo............XX ",
" ...........oooooooo...........XX ",
" ..........oooooooooo..........XX ",
" .........ooooo..ooooo.........XX ",
"  .......ooooo....ooooo.......XX  ",
"  ......ooooo......ooooo......XX  ",
"   ......ooo........ooo......XXX  ",
"   .......o..........o.......XX   ",
"    ........................XXX   ",
"     ......................XXX    ",
"     X....................XXX     ",
"      X..................XXX      ",
"       X................XXX       ",
"        XX............XXXX        ",
"          XX........XXXXX         ",
"            XXXXXXXXXXX           ",
"              XXXXXXX             ",
"                                  "};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      vim74/pixmaps/tb_find_help.xpm                                                                      0000644 0001750 0001750 00000001302 11373477654 015363  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_find_help_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s bottomShadowColor	m black	c #5D6069",
"o	s iconGray2	m none	c #bdbdbd",
"O	s iconColor2	m none	c #FFFFFF",
/* pixels */
"                  ",
"                  ",
"    .....X        ",
"   ..  X..X       ",
"  ..X   ...       ",
"  ..X   ....      ",
"  X..  .oOOo.     ",
"      .oooOoo.    ",
"      .OOOOoO.    ",
"     ..oOOooo.    ",
"     ...oOOo.X    ",
"        ....X..   ",
"     ..X     ...  ",
"     ..X      ..  ",
"     ..X          ",
"      XX          ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                              vim74/pixmaps/tb_exit.xpm                                                                           0000644 0001750 0001750 00000001511 11373477654 014406  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_exit_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 9 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
"O	s iconColor3	m black	c #FF0000",
"+	s iconGray3	m none	c #adadad",
"@	s iconGray4	m none	c #949494",
"#	s iconGray5	m black	c #737373",
"$	s iconGray6	m black	c #636363",
/* pixels */
"                  ",
"                  ",
"        ........  ",
"        .XXXXXX.o ",
"        .XXXXXX.o ",
"      ...XXXXXX.o ",
"      .O.XXXXXX.o ",
" ......OO.XX..X.o ",
" .OOOOOOOO.X..X.o ",
" .OOOOOOOO.XXXX.o ",
" ......OO.XXXXX.o ",
"      .O.XXXXX+.o ",
"      ...XXXX++.o ",
"        .XX++@#.o ",
"        .X+@##$.o ",
"        ........o ",
"          ooooooo ",
"                  "};
                                                                                                                                                                                       vim74/pixmaps/tb_copy.xpm                                                                           0000644 0001750 0001750 00000001233 11373477654 014410  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_copy_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"                  ",
" ..........       ",
" .XXXXXXXX.o      ",
" .X.............  ",
" .XXXX.XXXXXXXX.  ",
" .X....X......X.o ",
" .XXXX.XXXXXXXX.o ",
" .X....X......X.o ",
" .XXXX.XXXXXXXX.o ",
" .X..X.X......X.o ",
" .XXXX.XXXXXXXX.o ",
" ......X..XXXXX.o ",
"  oooo.XXXXXXXX.o ",
"      ..........o ",
"        ooooooooo ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                                                                     vim74/pixmaps/tb_save_session.xpm                                                                   0000644 0001750 0001750 00000001505 11373477654 016141  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_save_session_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 9 1 0 0",
/* colors */
" 	s none	m none	c none",
".	m black	c #880000",
"X	s iconColor3	m black	c #FF0000",
"o	s iconColor1	m black	c #000000",
"O	s iconColor2	m none	c #FFFFFF",
"+	s iconGray2	m none	c #bdbdbd",
"@	s iconGray5	m black	c #737373",
"#	s iconGray4	m none	c #949494",
"$	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"       ....       ",
"       .XX.       ",
"       .XX.       ",
"       .XX.       ",
"     ...XX...     ",
"      .XXXX.      ",
"       .XX.       ",
"        ..        ",
"   ooooooooooooo  ",
"  oOOOOOOOOOO++@o ",
" oOOOOOOOOOOOO#@o ",
" oO+++++++++XX#@o ",
" oO+++++++++++#@o ",
" oOoooooooooo+#@o$",
" oOOOOOOOOOOO+#@o$",
" o+###########@o$ ",
"  ooooooooooooo$  ",
"    $$$$$$$$$$$   "};
                                                                                                                                                                                           vim74/pixmaps/tb_paste.xpm                                                                          0000644 0001750 0001750 00000001403 11373477654 014551  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_paste_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 7 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconGray5	m black	c #737373",
"o	s iconGray2	m none	c #bdbdbd",
"O	s bottomShadowColor	m black	c #5D6069",
"+	s iconGray4	m none	c #949494",
"@	s iconColor2	m none	c #FFFFFF",
/* pixels */
"                  ",
"     ....         ",
"     XXXX         ",
"  ...oooo...O     ",
" .o+......++.O    ",
" .o+++++++++.O    ",
" .o+++..........  ",
" .o+++.@@@@@@@@.  ",
" .o+++.@......@.O ",
" .o+++.@@@@@@@@.O ",
" .o+++.@@@@@@@@.O ",
" .o+++.@......@.O ",
" .o+++.@@@@@@@@.O ",
"  .....@..@@@@@.O ",
"   OOO.@@@@@@@@.O ",
"      ..........O ",
"        OOOOOOOOO ",
"                  "};
                                                                                                                                                                                                                                                             vim74/pixmaps/tb_maximize.xpm                                                                       0000644 0001750 0001750 00000001306 11373477654 015262  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_maximize_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s topShadowColor	m none	c #DCDEE5",
"X	s iconColor1	m black	c #000000",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"  .XXXXXXXXXXX    ",
"  .X....X...oX    ",
"  .X..oXXX..oXO   ",
"  .X.oXXXXX.oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .X..XXXXX.oXO   ",
"  .X...XXX..oXO   ",
"  .XooooXooooXO   ",
"  .XXXXXXXXXXXO   ",
"     OOOOOOOOOO   ",
"                  "};
                                                                                                                                                                                                                                                                                                                          vim74/pixmaps/tb_new_session.xpm                                                                    0000644 0001750 0001750 00000001455 11373477654 016000  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_new_session_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 8 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s bottomShadowColor	m black	c #5D6069",
"X	s iconColor2	m none	c #FFFFFF",
"o	s iconColor1	m black	c #000000",
"O	s iconGray2	m none	c #bdbdbd",
"+	s iconGray5	m black	c #737373",
"@	s iconGray4	m none	c #949494",
"#	s iconColor3	m black	c #FF0000",
/* pixels */
"    .  .X.  .     ",
"     . oXo .      ",
"    ..oXXXo..     ",
"    XXXXXXXXX     ",
"    ..oXXXo..     ",
"     . oXo .      ",
"    .  .X.  .     ",
"        .         ",
"   ooooooooooooo  ",
"  oXXXXXXXXXXOO+o ",
" oXXXXXXXXXXXX@+o ",
" oXOOOOOOOOO##@+o ",
" oXOOOOOOOOOOO@+o ",
" oXooooooooooO@+o.",
" oXXXXXXXXXXXO@+o.",
" oO@@@@@@@@@@@+o. ",
"  ooooooooooooo.  ",
"    ...........   "};
                                                                                                                                                                                                                   vim74/pixmaps/tb_minimize.xpm                                                                       0000644 0001750 0001750 00000001306 11373477654 015260  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_minimize_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s topShadowColor	m none	c #DCDEE5",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"      .....       ",
"       ...        ",
"        .         ",
"                  ",
" X.............   ",
" X.XXXXXXXXXXo.   ",
" X.XXoXXXXXXXo.O  ",
" X.XXXXXXXXXXo.O  ",
" X.XXXXXXXXXoo.O  ",
" X.ooooooooooo.O  ",
" X.............O  ",
"    OOOOOOOOOOOO  ",
"                  ",
"        .         ",
"       ...        ",
"      .....       ",
"                  "};
                                                                                                                                                                                                                                                                                                                          vim74/pixmaps/tb_shell.xpm                                                                          0000644 0001750 0001750 00000001341 11373477654 014545  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_shell_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 6 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconGray6	m black	c #636363",
"o	s iconGray2	m none	c #bdbdbd",
"O	s iconColor2	m none	c #FFFFFF",
"+	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"     ... ...      ",
"    .XoXXXoX.     ",
"   .oOoX.XoOo.    ",
"   .XoOoXoOoX.    ",
"  .Xoooo.ooooX.   ",
" .Xo.XOoXoOX.oX.  ",
" .oooXOo.oOXooo.  ",
" .oOo.XOXOX.oOo.+ ",
" .XoOo.o.o.oOoX.+ ",
"  .XooXoooXoOX.+  ",
"   .XoooOoooX.+   ",
"    .ooOOOoo.+    ",
"    ..XoooX..+    ",
"   .XoooooooX.+   ",
"   ...........+   ",
"     ++++++++++   ",
"                  "};
                                                                                                                                                                                                                                                                                               vim74/pixmaps/tb_find.xpm                                                                           0000644 0001750 0001750 00000001275 11373477654 014364  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_find_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"O	s iconGray2	m none	c #bdbdbd",
"+	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
" .........        ",
" .XXXXXXX..       ",
" .XXXXXXX.O.      ",
" .XXXXXXX....     ",
" .XXXXXXXXXX.     ",
" .XXXXXXX....     ",
" .XXXXXX.OOOO.    ",
" .XXXXX.OXXOOO.   ",
" .XXXXX.OXOOOO.   ",
" .XXXXX.OOOOOO.   ",
" .XXXXX.OOOXOO.   ",
" .XXXXXX.OOOO.+   ",
" .XXXXXXX....+..  ",
" .XXXXXXXXXX.+... ",
" ............+ .. ",
"    ++++++++++    ",
"                  "};
                                                                                                                                                                                                                                                                                                                                   vim74/pixmaps/tb_blank.xpm                                                                          0000644 0001750 0001750 00000001240 11373477654 014523  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_blank_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 4 1 0 0",
/* colors */
" 	s iconColor1	m black	c #000000",
".	s none	m none	c none",
"X	s topShadowColor	m none	c #DCDEE5",
"o	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                 .",
" XXXXXXXXXXXXXXX .",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
" X.............. o",
"                 o",
"..oooooooooooooooo"};
                                                                                                                                                                                                                                                                                                                                                                vim74/pixmaps/tb_vsplit.xpm                                                                         0000644 0001750 0001750 00000001304 11373477654 014756  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_vsplit_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s topShadowColor	m none	c #DCDEE5",
"X	s iconColor1	m black	c #000000",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
" .XXXXXXXXXXXXXX  ",
" .X....oXO....oX  ",
" .X..o.oXO..o.oXO ",
" .X.oo.oXO.oo.oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .X....oXO....oXO ",
" .XoooooXooooooXO ",
" .XXXXXXXXXXXXXXO ",
"    OOOOOOOOOOOOO ",
"                  "};
                                                                                                                                                                                                                                                                                                                            vim74/pixmaps/tb_undo.xpm                                                                           0000644 0001750 0001750 00000001233 11373477654 014403  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_undo_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor2	m none	c #FFFFFF",
"o	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"                  ",
"  ..  .....       ",
"  .X..XXXXX..     ",
"  .XXXXXXXXXX.    ",
"  .XXXX....XX.o   ",
"  .XXXX.ooo.XX.   ",
"  .XXXXX.  .XX.o  ",
"  .......o .XX.o  ",
"   o.ooooo .XX.o  ",
"   .X.     .XX.o  ",
"   .XX.....XX.oo  ",
"    .XXXXXXXX.o   ",
"     .XXXXX..oo   ",
"      .....ooo    ",
"       ooooo      ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                                                                     vim74/pixmaps/generic.xpm                                                                           0000644 0001750 0001750 00000003034 11373477654 014366  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * generic_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"34 34 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s bottomShadowColor	m black	c #5D6069",
"X	s iconColor2	m white	c #FFFFFF",
"o	s iconColor1	m black	c #000000",
/* pixels */
"                                  ",
"            ........              ",
"         ...XXXXXXXX...           ",
"       ..XXXXXXXXXXXXXX..         ",
"      .XXXXXXXXXXXXXXXXXX.        ",
"     .XXXXXXXXXXXXXXXXXXXXo       ",
"    .XXXXXXXXXXXXXXXXXXXXXXo      ",
"   .XXXXXXXXXXXXXXXXXXXXXXXXo     ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXXXo    ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXXXo.   ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.  ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.  ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.. ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXXXo... ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXXXo... ",
"   .XXXXXXXXXXXXXXXXXXXXXXXXo...  ",
"    oXXXXXXXXXXXXXXXXXXXXXXo....  ",
"     oXXXXXXXXXXXXXXXXXXXXo....   ",
"      oXXXXXXXXXXXXXXXXXXo....    ",
"       ooXXXXXXXXXXXXXXoo....     ",
"        .oooXXXXXXXXooo.....      ",
"         ...oooXXXXo.......       ",
"           ....oXXXo.....         ",
"              .oXXXo..            ",
"                oXXo..            ",
"                 oXo..            ",
"                  oo..            ",
"                   ...            ",
"                    ..            ",
"                                  "};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    vim74/pixmaps/tb_split.xpm                                                                          0000644 0001750 0001750 00000001303 11373477654 014567  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_split_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s topShadowColor	m none	c #DCDEE5",
"X	s iconColor1	m black	c #000000",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"  .XXXXXXXXXXX    ",
"  .X........oX    ",
"  .X..o.....oXO   ",
"  .X.oo.....oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .XoooooooooXO   ",
"  .XXXXXXXXXXXO   ",
"  .XOOOOOOOOoXO   ",
"  .X..o.....oXO   ",
"  .X.oo.....oXO   ",
"  .X........oXO   ",
"  .X........oXO   ",
"  .XoooooooooXO   ",
"  .XXXXXXXXXXXO   ",
"     OOOOOOOOOO   ",
"                  "};
                                                                                                                                                                                                                                                                                                                             vim74/pixmaps/alert.xpm                                                                             0000644 0001750 0001750 00000003032 11373477654 014057  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * alert_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"34 34 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s iconColor6	m white	c #FFFF00",
"o	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                                  ",
"              ...                 ",
"             .XXX.                ",
"            .XXXXX.o              ",
"            .XXXXX.oo             ",
"           .XXXXXXX.oo            ",
"           .XXXXXXX.oo            ",
"          .XXXXXXXXX.oo           ",
"          .XXXXXXXXX.oo           ",
"         .XXXXXXXXXXX.oo          ",
"         .XXXX...XXXX.oo          ",
"        .XXXX.....XXXX.oo         ",
"        .XXXX.....XXXX.oo         ",
"       .XXXXX.....XXXXX.oo        ",
"       .XXXXX.....XXXXX.oo        ",
"      .XXXXXX.....XXXXXX.oo       ",
"      .XXXXXX.....XXXXXX.oo       ",
"     .XXXXXXXX...XXXXXXXX.oo      ",
"     .XXXXXXXX...XXXXXXXX.oo      ",
"    .XXXXXXXXX...XXXXXXXXX.oo     ",
"    .XXXXXXXXXX.XXXXXXXXXX.oo     ",
"   .XXXXXXXXXXX.XXXXXXXXXXX.oo    ",
"   .XXXXXXXXXXXXXXXXXXXXXXX.oo    ",
"  .XXXXXXXXXXXX..XXXXXXXXXXX.oo   ",
"  .XXXXXXXXXXX....XXXXXXXXXX.oo   ",
" .XXXXXXXXXXXX....XXXXXXXXXXX.oo  ",
" .XXXXXXXXXXXXX..XXXXXXXXXXXX.oo  ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXX.ooo ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXX.ooo ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXX.oooo ",
"   .........................ooooo ",
"     ooooooooooooooooooooooooooo  ",
"      ooooooooooooooooooooooooo   ",
"                                  "};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      vim74/pixmaps/tb_load_session.xpm                                                                   0000644 0001750 0001750 00000001505 11373477654 016122  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_load_session_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 9 1 0 0",
/* colors */
" 	s none	m none	c none",
".	m black	c #880000",
"X	s iconColor3	m black	c #FF0000",
"o	s iconColor1	m black	c #000000",
"O	s iconColor2	m none	c #FFFFFF",
"+	s iconGray2	m none	c #bdbdbd",
"@	s iconGray5	m black	c #737373",
"#	s iconGray4	m none	c #949494",
"$	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"        ..        ",
"       .XX.       ",
"      .XXXX.      ",
"     ...XX...     ",
"       .XX.       ",
"       .XX.       ",
"       .XX.       ",
"       ....       ",
"   ooooooooooooo  ",
"  oOOOOOOOOOO++@o ",
" oOOOOOOOOOOOO#@o ",
" oO+++++++++XX#@o ",
" oO+++++++++++#@o ",
" oOoooooooooo+#@o$",
" oOOOOOOOOOOO+#@o$",
" o+###########@o$ ",
"  ooooooooooooo$  ",
"    $$$$$$$$$$$   "};
                                                                                                                                                                                           vim74/pixmaps/tb_save_all.xpm                                                                       0000644 0001750 0001750 00000001301 11373477654 015220  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_save_all_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s iconColor1	m black	c #000000",
".	s none	m none	c none",
"X	s iconGray2	m none	c #bdbdbd",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"              ....",
" X oooooooo o ....",
" X oooooooo   O...",
" X               .",
" X  X oooooooo o .",
" X  X oooooooo   O",
" X  X oooooooo X O",
" XX X oooooooo X O",
" XX X oooooooo X O",
" XX X oooooooo X O",
" XX XX        XX O",
" XX XXXXXXXXXXXX O",
" XX XX         X O",
".   XX      oo X O",
"..O XX      oo X O",
"... XX      oo X O",
"....             O",
".....OOOOOOOOOOOO."};
                                                                                                                                                                                                                                                                                                                               vim74/pixmaps/gen-inline-pixbufs.sh                                                                 0000644 0001750 0001750 00000000322 11373477654 016260  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   #! /bin/sh

prefix=stock_
list=

for file in "$@"
do
    name=`echo "$file" | sed 's|-|_|g; s|^.*/||; s|\..*$||'`
    list="$list $prefix$name $file"
done

gdk-pixbuf-csource --raw --static --build-list $list

                                                                                                                                                                                                                                                                                                              vim74/pixmaps/tb_cut.xpm                                                                            0000644 0001750 0001750 00000001167 11373477654 014237  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_cut_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 3 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s iconColor1	m black	c #000000",
"X	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"     .     .X     ",
"     .X    .X     ",
"      .   .X      ",
"      .X  .X      ",
"       . .X       ",
"       .X.X       ",
"        .X        ",
"       ...X       ",
"     X.X  .X      ",
"    ...X  ...     ",
"   .XX.X  .X .    ",
"   .  .X  .X .X   ",
"   .  .X  .X .X   ",
"    ..XX   ..X    ",
"    XX     XX     ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                                                                                                         vim74/pixmaps/tb_minwidth.xpm                                                                       0000644 0001750 0001750 00000001306 11373477654 015262  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_minwidth_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s topShadowColor	m none	c #DCDEE5",
"X	s iconColor1	m black	c #000000",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"                  ",
"     .XXXXXX      ",
"     .X...oX      ",
"     .X...oX      ",
"     .X...oX      ",
" X   .X.o.oXO   X ",
" XX  .X...oXO  XX ",
" XXX .X...oXO XXX ",
" XX  .X...oXO  XX ",
" X   .X...oXO   X ",
"     .X...oXO     ",
"     .X..ooXO     ",
"     .XooooXO     ",
"     .XXXXXXO     ",
"        OOOOO     ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                          vim74/pixmaps/tb_maxwidth.xpm                                                                       0000644 0001750 0001750 00000001306 11373477654 015264  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * tb_maxwidth_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"18 18 5 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s topShadowColor	m none	c #DCDEE5",
"X	s iconColor1	m black	c #000000",
"o	s iconColor2	m none	c #FFFFFF",
"O	s bottomShadowColor	m black	c #5D6069",
/* pixels */
"                  ",
"                  ",
"                  ",
"                  ",
".XXXXXXXXXXXXXXXX ",
".X.............oX ",
".X..X........X.oXO",
".X.XX........XXoXO",
".XXXX........XXXXO",
".X.XX........XXoXO",
".X..X........X.oXO",
".XooooooooooooooXO",
".XXXXXXXXXXXXXXXXO",
"   OOOOOOOOOOOOOOO",
"                  ",
"                  ",
"                  ",
"                  "};
                                                                                                                                                                                                                                                                                                                          vim74/pixmaps/info.xpm                                                                              0000644 0001750 0001750 00000003031 11373477654 013702  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   /* XPM */
static char * info_xpm[] = {
/* width height ncolors cpp [x_hot y_hot] */
"34 34 4 1 0 0",
/* colors */
" 	s none	m none	c none",
".	s bottomShadowColor	m black	c #5D6069",
"X	s iconColor2	m white	c #FFFFFF",
"o	s iconColor1	m black	c #000000",
/* pixels */
"                                  ",
"            ........              ",
"         ...XXXXXXXX...           ",
"       ..XXXXXXXXXXXXXX..         ",
"      .XXXXXXXXXXXXXXXXXX.        ",
"     .XXXXXXXXooooXXXXXXXXo       ",
"    .XXXXXXXXooooooXXXXXXXXo      ",
"   .XXXXXXXXXooooooXXXXXXXXXo     ",
"  .XXXXXXXXXXXooooXXXXXXXXXXXo    ",
"  .XXXXXXXXXXXXXXXXXXXXXXXXXXo.   ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXo.  ",
" .XXXXXXXXXXoooooooXXXXXXXXXXXo.  ",
" .XXXXXXXXXXXXoooooXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoooooXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoooooXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoooooXXXXXXXXXXXo.. ",
" .XXXXXXXXXXXXoooooXXXXXXXXXXXo.. ",
"  .XXXXXXXXXXXoooooXXXXXXXXXXo... ",
"  .XXXXXXXXXXXoooooXXXXXXXXXXo... ",
"   .XXXXXXXXXXoooooXXXXXXXXXo...  ",
"    oXXXXXXXoooooooooXXXXXXo....  ",
"     oXXXXXXXXXXXXXXXXXXXXo....   ",
"      oXXXXXXXXXXXXXXXXXXo....    ",
"       ooXXXXXXXXXXXXXXoo....     ",
"        .oooXXXXXXXXooo.....      ",
"         ...oooXXXXo.......       ",
"           ....oXXXo.....         ",
"              .oXXXo..            ",
"                oXXo..            ",
"                 oXo..            ",
"                  oo..            ",
"                   ...            ",
"                    ..            ",
"                                  "};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       vim74/vimdir.info                                                                                   0000755 0001750 0001750 00000001160 11373477654 012713  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                           B     "  "             d          'P       'y         
 <e n      'z     "         \ ?              B   x             @ ? <       < < < < < = ?             /  UW                            B   X             @ ? ?                                    O                                                                                                                                                                                                                                                                                                                                                                                                                                                  vim74/libs/                                                                                         0000755 0001750 0001750 00000000000 12201430753 011450  5                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   vim74/libs/arp.library                                                                              0000644 0001750 0001750 00000041314 11373477654 013647  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                                                p'NuJ      '	    M   Z     ARP Shell Process      ARP Background Shellarp.library  ArpLib 39.1 (cdh/sdb 4/9/89)
 dos.library intuition.library graphics.library environment Arp EnvLib
     ~       6"R`\  h048<@DHLPTX\`rd	4	X	^z\.P	%r$% $T$$$%j	V !#l##%%$''
Ftz,2,/'(>?z@(0r+d++@X~>>Z$%<  	   	    
   M      '        Z  &   '*     $  	   	   
                    .    HfTH!$*@+H z.<c E <tSB0; C p!N% W NQ @+h " "A < XB !H A LNpFa Jf
.<a N$@E +J ,p CLN m ,C6$IN$<    "<  N:"m ,#@ "g#B &#M *Nt L$NuaN2"@fRn   NuB / <  6Alr(,n 8NJ,_Nua !fSn  p NuJn  f   n ,"h "Jf"n <JgagH &*N,x  m , ( &g"h "N.E 0t"ZNbQ"m ,N"m ,Ca $- z"MN"Mp " 2- 0- N. LdNupb`2p\`.pV`*pP`&p>`"p8`p2`p,`p&`p `p`
p`p`p/,n 0N ,_Nup`p`p`p`p`p`p`p`p`p`p`p`p`p`0< a" Nug A"(  Nu0< `
0< `0<  x  h NuJg"X/ "<  /,x N:,_"Jg @  Nu 	g !/,x N.,_NuH NL Jg(H 2E $O&O/B/ B,x N O `LL NuJk>"+ gRA'A| Pe(Jg$H0L@
$NL@Jk'@BNuH 0&@E /,x N,_pJWFL NuNur  H@p/,x N,_g? p"N"@Jf0,x NLAp Nu3_ LH |  ,x #n /	J 
gN`A  XB !H L@Nu 	gH B,x J 
gN"Wp ) NLB N/G #K 
H '@ G r fBQ`&Q&_NuH jNS" .A$x (jE \"ON"O k ,x N , g @N` JN JN"@g
.<d  NL   )A N[LV NuN
T	VBRFE  H0p. '"HfZ< _EJgf* `BT`< Xf4v/t < _< k< 
m
< '< l
Q`S"JCo(WFLNuH,$H(z " fBAra .* g  (OO$ .BB/ "N./ Wfl @"/ "0"0( A`Q" :BJ g("N"NJg."BC fSJ g /`.L"gN 
 L4NuJ g"N`H0&<   $N" gN" br o B0LNup gZ<  cr< -fr`< +gS"H< 0e< 9c<  ca*@`$/p a r < 0k`"jDJNu/ x  h!@  _NuNQ  A 
NXONu%s
  
g $@Nu$n " * X@$@Nu"	g  H tN$ gr o a  | npp,N$@Jg\ o pRJf| NgD%@ ( o r)N%B  B%h  R $
 x R('N B $a :p `p`"Ja `p"$ N LGNuH 0$ x R('N&JNgNO O * (rPN"BNJO Rfp f,&"* N * ("@N"JNp a LNup`p`"@p    lR@AmB0  Nu"@p  gR@@nNu/$ p  n ""x R)'" Ab 0( gJg
Rg   ]a @$Nu"<   H@p ,x NLCg
    g/	CNu%s:  Sorry, no extra help available.  C !  RB) Jg  c Nur H_v  -f+ T $x | zag < ?fZJ( fT <   NJfp` |$@AvC $N JN
Jo ag < ?fJ( fCQJ g"o N`/H J $f$R o  "f
a Fk `N"o  "` @a L k /o   a g  k Rdp`    fB f(`"o pb Jg   b)  f)   g
"/I R`RX`a <k f fX RJg^f0z a k rfJf``RJgR   g
a kz `R(`p   b @*  g$` 2p   g "a Bk fp` $` Jg~ o $g
< ,fQFp o  `   b(  f BQJgU $ LNu~ L  $Jf  f|Jgv o ~RgX<  c< "gp JfJgB~`PJf(  cJf( =g( ;f`. '(fJf~`( "f` N"D(@"f~Nu< /f<a F< Af   < Kf  < Sf  < .f JJg~Nu(< ,f 8XBR` ./ o  p tgl<  c< "gt S"Hg6Jf<  c,Jf< =g"< ;fr `< "f. ')f)ftg kpB!JgR/I  JgN $JNuL  $"HfJ gpNuJ fJf< =g< /g< ,g`Aa FAa @ g`gJf< =g< ,fX`, DS0; A "o  "`  D U h     ARP WARNING! A program didn't free its resources!  Unmatched quotes Too many arguments Bad positional argument Keyword needs an argument Required argument missing Out of memory Bad Template or Internal error ***BREAK H0v &Ia k 
LNuH"x R)'"n ,"i ""	g&` < =g`N N gJf o Jf.  &f\J gV o $<  aXgH" o B$&N"( NJm,g( BB0H `$Jf/I  gS"/ g
 AWB `B aHL Nu <p6"O"ENV:Wf& x  h &(p "N C  <( Nup `/,x Nv,_NuH "x R)'&n ,"k "$IJg2 W< =gN N gJf`JfJf`ff`JfJf / g   @Jg  "
 "/RJf o RJfR + &dH   e"<  / ,x N:JgL$@"@ + & k "S"Q"k " + &N.'J "'_ &$_ " Wf| = o fBp.`PBa LNNu Nup Nu @"Ap"(  fS@"(  fS@"(  fS@NuDirectory Error topaz.font (dir)  <ASN>  File   Drawer   OK   Parent CANCEL Drives          ?   < g  
   < Z  
     1    t 8     t 8    U t 8     t 8    @  
   K  
  H?<$HB <  N*@Jg $+JAtCj0<v""BY" 2PIR@|vmAd+HD+H p!r *   g0< r~;@&;AJ+j @+j A@+HA+H;| A+HA+HAd * gS@` <    <,  0 B  
PH PH  RP * g @"h .+Ipi ;@/*  g
Adpa 	Ad,n 8N4&@Jg ",+ 2*  f * g @'h V V K < @hNj,W,n 4A6N+@bg @"FNpa p+ 7;@2-@WA;ArV*  f+ 7p4+ [B6+ 
WCa ,WtEf"Jpa >E ,Q m(  g Kpa H="*. 4p"<  ,x N:. g  pa p"FNEA`a EfAMa 0-U@r + 7t@6-ma HrVa H2+ 
UAa >r + 7a 4pa <0+ Y@a 2pa prtvEa p a prtva ECa ECa ~EnCa rEBCa fa  A"G2f4-6-a8A"G2f6-a("Gp,x N.LD k >pa a Afa `"F Gp rxz
Na  0->]@2 
H@Ao0J@lp ;@< k V,x NJf8,WSmDfa Jm@ga Jm@gpm>fa j` k V,x N`"@ ,g m(  g
 Ip@a &`N`$) $i +i Z+i  F+i $R+i (VN,W| g F| g  @  gt| g |  g| @f Bp 0* &" |vg S@g S@g S@g S@g S@g S@g  U@o m(  g Apa ~Jf ` ;| ^`@0-Pm`g.;@`g(tERB$R 
g m@NC Nn;B<p `$Sm^n pr-f v-f
p-g m<2->_AAm0;@<lBm<a 
a F` ba `   K/,n 8N,_Nup K/,n 8N,_Nup"K/,n 8N",_NuA"K/,n 8N2,_Nu m/( < g WBCa0-& WJW JJWS@n
Ca ` W"Ja pBm$ WJgRm$`XOCa jAa tCaa ` ~0-Z| if  JmBf ;m><ApNm>;| Baa Ja D` bHxm>n8-> <   8 A"Kpr t 4-<6->_CoHBBBHBv ,n 8zN,L@ Nu| hfpmFm|lpmHo| ElH 
? @E t6 
| /,n 4pa ,WrN:t,n 4pa ~,_"g $A* \J<  f HL JH J,n 8NJL@g J"m"i NJg2Cfa p  m h WCfa  Afa 
;mP`` pm\f  m.(  K"m#h  R )  "i ga  -bg
,n 4"@N,_a"MN L<Nu MN>"ma BNuCa l m h "Hg< /fC`< :fJfB m 	 ;@$;@,C` < m"Pa  A p	BQRm@RmDa0 m h "ONJ@ga`
 OCa   MNJ0`Jm@g MNDJg| gCaVBm@Nu m(  g M <   a JfrJ lr A CaHJg2->Rm>| lA A! `  $I/,n 8N,_"J m$P K/,n 8N,_Nup H@JfpRJf/ ^N"JgB&@ @ C  _QB!$WQO`$R g"@+ ) fA C Nl&$ LNu/N"_ 	fNuA0-<aQC p"a
Q;| D"g PNuH8:,n 4E xvt
Bpa  pa  p "FNp"\A"FN g2(@G , <  gA< gA< (gpa\`a a0 Ka"F4) $|lpaHQL\Nu"HpRJf"FNNup  m(  fpa"F) 
  N"FN"FNaa $<  "^Cad_CNuH0&Ipaprtva8prtva.pap r tva p apj r	j "FN KL` bj j j j 
@A"FN&SAtk p`r + 74 RB6+ 
UC`/p
rj "FN _a prtv`H"m") g"ANLANuH *n 8,x R.' W ( Vg( @NJg"@N`J g WB Vp NNjN WNNNNvLc NuH8<$ *Hx   x R('NNfa   L<Nu O * (rPN :B(H * f4  g gJ gr | ( "M ORDNJfx `| f grJ fr p `| f z g rr(`p:Jg`Jg< :g
< /g /fSHNuH0 $Hv t af  ; @N &A "p
 WNu]  *~[]#?()|%'`N`L``J`*`D`<`@`<`ag6SJ< '`0g(< ]f< ` ?gtv`RJ< `TB`UBvg| ft  ` f LNuJgg< oFgp NuJfpNuJgH aL fJf`af`r Jg fRA fSAl`@| N `````````p`0`H aL fr g< fRA< fSAJAf< f`H g.< f$H Ja NfL a Dg g/I `L ` DL ` 4g,Jg( g"g" -fRH(eegJg f`  Jg f`  <  S@k2 a  af(Wp NucpNupNu   < `c< zb<  Nu< c< @NuJg  H?0*,$INT&OS. (L$& B"DNJj` D"CNJj`d   B"C`Qf(`f(bc "ldg(&&.`dg&&*e vc.#*#` jp `pN\LNuH< &HB+  $@*O"M J(Ig< :f`"LNv $Lg8 /g< nJCf
 ga8*Lv  `(JJCg 
Sa*Lv ` 
a'S  K L<`  H  $   N$@Jg: MCgCgNSBnJg k  %H `JCg Ja P%@ f  `&'J  
LNu* f tNJg Jg
J lp NupNuH04&H$k pg+  f Jgt  gKpva Bg*@ `  "* g<af8"* NB "J$j 'J g0) gNB  `  *  g*  f* gZ0< ` "* tNJg"+ C N A "ONfA"ONP JgJgpJ o aDa  & g"a f"NN|Jf0< g  ` 2 g&$@%C 'J  ` A*  gA Nu "N$k A C p@ Q4+ g@$SK"MaSBoFf$R 
g(SIg) :gp/)gSB`XO'@ 0<0`
p r+ f$  Ka `0</HL,Nu/
$H g @"( gN"R$N`$_Nu"* g/N".a".N Nu"tN x R('"("n <` g"Q f"@/	a  NupN/ g"@A  X!H  x R('#h A <  H @!I `& ft a,"N,x  n!B  i 0Hhp?<N/?<"</?<,|/NbNfNuNgHB,x N:LB"g#A 3| 
NuN p Nu"	NgH B"A,x NLB "g3| NuNg/	N"_"g3| NuNg /	N`Ng/	N"_"g3| NuHpa"@JLfp NuH N2fN,g&$@pNJg"@A   H @!I pLNu <  N"@JgA #H A#H |  3| NuH $H`N2/ g "@ x R(' Q"i "!I a  "WN& Nu/
$I"j Jg
C N `"J$_N/
$j `"J$@a6 f$_NuH ",n *E <`a$RJfLD p Nu 	g  C i )  	f  H "$I*  g"J Q"i "!I p * gZ"* gT< bJ@"AN N`<N`6 * ,x N.`(```:`D`N`V`Z`d`h``z`h``  `fA N>B "JLD )  gNNu A"j N` A,n 8N`,x Nb`N` A,x N`Nd`N&`N`,n 4N`B  * g @fN``R) NuS)NuH?<a Z$g>  g8 Ag$A&| gA%nA|g
|ma "Bf`   g  "@ABp	QIp(m  RztN&<  m< fRoRBR`"| dm| da@E< fEtRoZR`"/a "JfS AU"a`"p "SaNu< 0H 
 HA Nu - g,"@"- m: <$a :R"HAa :"- m 2a - g
"@afp L<Nup` r  H@A0  ANu*H< :G - ~ - mpo~ O n 0 h "*( NuH?<aJg  E_t  S"JNJgJfR< 
m`@r < g.r< g&n""  H@H fm_`
n^`r *`   g   @E< -a  m  S< l     cn  pNl
| -n  pp rJg  m< fRRS`AH< fAV"Ip nNr Sm2`S* - g. @Ef< :a.m(rn"r<ll 2+C +B p L<Nup`~ x v t m:< fa<`atm2  n*Np`
`````(`&`$ g< fJ fNupNu/C ^r WpH@@NLJgVR< m Wa`
 WgfXJNur gg< 0m< 	n 
 `JNur`JanFebMarAprMayJunJulAugSepOctNovDec-------                                       
  )0Sunday Monday Tuesday Wednesday Thursday Friday Saturday Today Yesterday Tomorrow Future H0 4&HCHCBCH@H@B@L Nu/BJjDRDJjD
D a"JDgD(Nu/BJjDRDJjDa `H0 HAJAf HA64 B@H@" H@20BAHAL NuHA&" BAHAH@B@tbR@QL NuH?<tBQH(x l' Y(lK (* $, g 8&B* * <* J* R* X* * * r a Z, o . 'G <L  a H      R*+ 4a /@  j|/|   g (` N2g @R !o $ /H $` o   ( "  < /A *@'@  o  "<   N/M  / g o f*o 5 
  g
 
  R  g)@  / g)@ A J XB !H "o    H @!I ", $A/j  L/j  P/j  TNL! )o ( "%A %@ B H@:+B+)M (F&O.M,n 0Ld  *C$H /K &DN, f|.o L\/l  (.+ < f%o L %o P J g%o T E J/,x  JNJg @N`,_C 4)Y J)Y R)Y X)Y )Y )Q "/ $g ASh /h  $`"N)o ( 'o , 'o 0 < x o Y' O \L<NuO \tBgQ&OtBQl 	 & H  
'O E \/J $KNJk$a / fp)o  O RL<Nu/,x (n , g @N`E \ JN JNg
.<d  N,_NuH t g$ A`H t "x (i&l a  Jjp LNuH8 x NU$ .B"
tN& fN|   g$`F" $NJg4J j/  wf/  wf"
Nj( `x)|  1 `x)l  "N N]L NuHx `Hx t(, $H/gN.g @.  fd Jg< :g< /f< :gJf)| a 6Jf8< :g2&g&+ g C&"( a,f`)D A 8"NRJg", a)D LJfpNuN$ a / "N NuC:  /gN"JfNdXONuBHy  BHy  ?< O @( hJ f,"( g*Y" /a  _Jg   /h  gRo V< /F  O/,x N",_O  | Jk @h  f,( C !I 
NuARP_PMEN  %@    %@ $   %@ H8B  fC (	C $	%|   4%|   
 `Z + fp
%@ A $(+ g.pN& g$"4HN)8g )( $(4H `"CN(+ $+ %k 4 4B <B B%G 8%G 0 * $B4 "D j a"B j aLNup QNu%N>    CON:0/0/640/100/ARP Process * NIL:  *  f H?HzpBQO*  fa /@  k HH    x (h&l A \/H ** g*  g .Y` o dr a (/@  o * /@ ,.X/E </|  pN/@ Dg L  da H  0 *   a /@ k H P < @ ( $  <    /@ $   /@ ( @   @*  g" R/A H& !@  o d 0"<   N*C/M 8 / 4g o hf*C5 
  g
 
  R 4*o $j  	|  +o H 
+j  2f+l 2 2 BAL  ,H* ! !* !* H$&+B +B 6+B >+B :+B +E +l  +l  +l   n 0+h & ,, ", (MN)@ A J XB !H "o   H @!I A \!L P( A  XB !H *  f  *   g)j 
 )j  `t f * 
 f
 C  `\ * 
fA"$<  N/|  )@ g v  * fAv fAR"$<  N"f& /|  )@ g   * f g
 @)h  J f
A /H `Nt * $o ( o  ( a p( f B", gN(.", gN( fp,F  %G < 
)@ R"F o D )@ T   )o  A \"o "Rn  E G"L/,x N,_$a @ / O LL?Nu"/ ,N / $g(@* "* a@ / g @B / (g
 @$( gal / o @/,x N,_ / Dg"@N /  ` fJg
 gN", g
N f  f", gN", g
 gNNu&5( "5(N"BN$fNu*x *m&o (,o  /   gN"/ fA"$<  N+@ g  " N(Jg   -  @+h  Ap"$<  N+@ grL  H  8$- g(B)@ 8)@ 0)A )A  (k @"- g*$A/j  ,/j  0/j  4L  %A %@ B a",n 0Ld  *C$L	 NB '| "K/,x N,_pNu. ,o (x (lL  4H  ,, (, g n "BH ", g& 5 f+ (+ ,Jg+ 0$/ "/ a > , "@N , g&@$+ ga dJ g/k < "/ N$N x R(' / g$*@+G +l  +F A  "N@,x "MN,x Sj  N.<` N x R('*n "*U zJgRca .pNuFa $p Nu"	g
rJWF,<   c,pJWFV<    c <   NuNEWCON:0/0/640/100/NEWShell CON:0/0/640/100/NewCLI S:Shell-Startup S:CLI-Startup New Process %d.
 g&L gJf NuH?<*  f G~I*   a/ A*   gA/ Ia/  j G(Ka/ pBQa8g(A A "RN/o  Jf/| Ba   / O 4L<Nu /@ * (x (la /@ k  H   /| a  /@ gz  f/, )| a )_ AP fA^(L 
 aZ/| L $g2G'@ /@ B ", N/@ '@ B /l   /N $pNu"o N"/ gNp NuH >$<  *, ,n 0Ld  *   < "@pH >  (j NL| NupNJg&@X", R A&&B*n "& NupBQ/H 8pJWF/@ 4j  /j 
 $/j  (*  V 0fN/@ $J (fN/@ (/|  / 4<    0N"@/@ ,gFG , #@  o 8f"/ 4 
+#A a <gA * A "RN`"o ,N / O <L<NuH*A,- ((x (l , $@,m v~ x %F  %F Jm ,f6$<   - $A fC6"	N`
C("	N.   `$*-  g%E "N((  )s  .- $Jf  $<  C"	N. "N(F%@ , - &@a  - g%@ 4Jm ,fv Lg)A "f"* NH(x (l , $@*A,m "- ,$<  N, g" N(Jf0"N)|    &, LgHl \t p(j N&_'K 8"* N )s A&"$<  N. f"N`H  %F %F   - &@a  - g%@ 4"- $g $<  NJf,/- $"OA JNXO`F "- ($<  NB Jg%@  ?,  m  "ONTOB ,Lg)A "* NCannot open From file %s
 L:ASH L:Shell-Seg Ha^fRA"Nj* fA"Nj* g8pNJf"Nd`& x R(' @  +@ F  CLIa j &L  Nu/"<CLI - *@    0 g$0___f 0$NuH00&ab$HG H`A faP"CNJg$f" J LNua laJgh gSh ` @a RHz8A H g @ fNu"Hg< :g< /f I` NuH0a a rgx$&@"+ fA $a '@ g@ a >'@ `+   gJk n`
a $ fRk Jk k.Rk  `&v A`vA"$A a 8JgJf`L`~H< *a  /"H&<   pJWFgFH &<   a f6$    Nvg" g" @!_ A "_f B $@a  %@  
`Jg x  h!C p .EL</ A L/,x N,_ NuH@A L/,x N,_LNu/
aa <Jg $@p 0* f"A""* gNd"JNp $_` @ ( g>A p `("H"(Q/| `Q"`Yn"(gR A`NuHy>NU x  h.( jp `\ Ox&<  I aT g!H   
QB&<  C ~ 	a0C | 	a( G"OE <G p r $<  @vH,n 8NN]L|Nu    B BNuResident Program has a checksum error. can't be loaded. Retry Cancel                 
                                                                                                                                                                                                                                                                                                                                                                     vim74/vimtutor.com                                                                                  0000750 0001750 0001750 00000005523 12141607627 013124  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   $ !
$ !=====================================================================
$ !
$ !	VimTutor.com	version 29-Aug-2002
$ !
$ !	Author: Tom Wyant <Thomas.R.Wyant-III@usa.dupont.com>
$ !
$ !	This DCL command procedure executes the vimtutor command
$ !	(suprise, suprise!) which gives you a brief tutorial on the VIM
$ !	editor. Languages other than the default are supported in the
$ !	usual way, as are at least some of the command qualifiers,
$ !	though you'll need to play some fairly serious games with DCL
$ !	to specify ones that need quoting.
$ !
$ !	Copyright (c) 2002 E. I. DuPont de Nemours and Company, Inc
$ !
$ !	This program is free software; you can redistribute it and/or
$ !	modify it under the terms of the VIM license as available from
$ !	the vim 6.1 ":help license" command or (at your option) the
$ !	license from any later version of vim.
$ !
$ !	This program is distributed in the hope that it will be useful,
$ !	but WITHOUT ANY WARRANTY; without even the implied warranty of
$ !	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
$ !
$ !=====================================================================
$ !
$ !
$ !	Check for the existence of VIM, and die if it isn't there.
$ !
$	if f$search ("vim:vim.exe") .eqs. ""
$	then
$	    write sys$error "Error - Can't run tutorial. VIM not found."
$	    exit
$	endif
$ !
$ !
$ !	Pick up the argument, if any.
$ !
$	inx = 0
$ arg_loop:
$	inx = inx + 1
$	if f$type (p'inx') .nes. ""
$	then
$	    if p'inx' .nes. "" .and. f$locate ("-", p'inx') .ne. 0
$	    then
$		xx = p'inx'
$		assign/nolog "''xx'" xx
$		p'inx' = ""
$	    endif
$	    goto arg_loop
$	endif
$ !
$ !
$ !	Make sure we clean up our toys when we're through playing.
$ !
$	on error then goto exit
$ !
$ !
$ !	Create the VIM foreign command if needed
$ !
$	if f$type (vim) .eqs. "" then vim := $vim:vim
$ !
$ !
$ !	Build the name for our temp file.
$ !
$	tutfil = "sys$login:vimtutor_" + -
		f$edit (f$getjpi (0, "pid"), "trim") + "."
$	assign/nolog 'tutfil' TUTORCOPY
$ !
$ !
$ !	Copy the selected file to the temp file
$ !
$	assign/nolog/user nla0: sys$error
$	assign/nolog/user nla0: sys$output
$	vim -u "NONE" -c "so $VIMRUNTIME/tutor/tutor.vim"
$ !
$ !
$ !	Run the tutorial
$ !
$	assign/nolog/user sys$command sys$input
$	vim -u "NONE" -c "set nocp" 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' 'tutfil'
$ !
$ !
$ !	Ditch the copy.
$ !
$ exit:
$	if f$type (tutfil) .nes. "" .and. f$search (tutfil) .nes. "" then -
$	    delete 'tutfil';*
$	if f$type (xx) .nes. "" then deassign xx
$	deassign TUTORCOPY
$	exit
$ !
$ !=====================================================================
$ !
$ !		Modification history
$ !
$ !	29-Aug-2002	T. R. Wyant
$ !		Changed license to vim.
$ !		Fix error "input is not from a terminal"
$ !		Juggle documentation (copyright and contact to front,
$ !			modification history to end).
$ !	25-Jul-2002	T. R. Wyant
$ !		Initial version
                                                                                                                                                                             vim74/README_extra.txt                                                                              0000644 0001750 0001750 00000002655 12201421403 013420  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_extra.txt for version 7.4 of Vim: Vi IMproved.

These extra files of Vim are for special purposes.  This README explains what
the files are for.  For general information about Vim, see the "README.txt"
file.


farsi/*			Files for the Farsi (persian) language.  If you don't
			know what Farsi is, this is not for you.

src/if_sniff.*		Interface to SNiFF.  If you don't know what SNiFF is,
			this is not for you.

src/os_amiga.*		Files for the Amiga port.

src/gui_beos.*
src/os_beos.*		Files for the BeOS port.

src/os_msdos.*
src/os_dos.*		Files for the MS-DOS port.

src/gui_mac.*
src/os_mac.*		Files for the Mac port.

src/os_mint.8		Files for the Atari Mint port.

src/os_os2*		Files for the OS/2 port.
src/tee/*		Extra program for OS/2.

src/os_vms*		Files for the VMS port.

src/os_w32*
src/os_win32.*		Files for the Win32 port.

src/gui_w32.*		Files for the Win32 GUI.
src/gui_w48.*		Files for the Win32 and Win16 GUI.
src/Make_mvc.mak	MS Visual C++ makefile for the Win32 GUI.
runtime/rgb.txt		File with color definitions for the Win32 GUI.

src/if_ole.*		OLE automation interface, for MS Windows 95 and NT.

src/VisVim/*		Integration of Win32 GUI with MS Visual Developer
			Studio.

src/GvimExt/*		DLL for the "Edit with Vim" context menu entry

nsis/*			NSIS script to build the self-installing MS-Windows exe

runtime/doc/*.man	Preprocessed manual pages.

runtime/macros/file_select.vim	Vim script to browse directories (Unix only).
                                                                                   vim74/README_vms.txt                                                                                0000644 0001750 0001750 00000003502 12201421404 013073  0                                                                                                    ustar   mool                            mool                                                                                                                                                                                                                   README_vms.txt for version 7.4 of Vim: Vi IMproved.

This file explains the installation of Vim on VMS systems.
See "README.txt" in the runtime archive for information about Vim.


Most information can be found in the on-line documentation.  Use ":help vms"
inside Vim.  Or get the runtime files and read runtime/doc/os_vms.txt to find
out how to install and configure Vim with runtime files etc.

To compile Vim yourself you need three archives:
  vim-X.X-rt.tar.gz	runtime files
  vim-X.X-src.tar.gz	source files
  vim-X.X-extra.tar.gz	extra source files

Compilation is recommended, in order to make sure that the correct
libraries are used for your specific system.  Read about compiling in
src/INSTALLvms.txt.

To use the binary version, you need one of these archives:

  vim-XX-exe-ia64-gui.zip       IA64 GUI/Motif executables
  vim-XX-exe-ia64-gtk.zip       IA64 GUI/GTK executables
  vim-XX-exe-ia64-term.zip      IA64 console executables
  vim-XX-exe-axp-gui.zip	Alpha GUI/Motif executables
  vim-XX-exe-axp-gtk.zip	Alpha GUI/GTK executables
  vim-XX-exe-axp-term.zip       Alpha console executables
  vim-XX-exe-vax-gui.zip	VAX GUI executables
  vim-XX-exe-vax-term.zip       VAX console executables

and of course
  vim-XX-runtime.zip		runtime files

The binary archives contain: vim.exe, ctags.exe, xxd.exe files,
but there are also prepared "deploy ready" archives:

vim-XX-ia64.zip			GUI and console executables with runtime and
				help files for IA64 systems
vim-XX-axp.zip			GUI and console executables with runtime and
				help files for Alpha systems
vim-XX-vax.zip			GUI and console executables with runtime and
				help files for VAX systems

GTK builds need LIBGTK library installed.

These executables and up to date patches for OpenVMS system are downloadable
from http://www.polarhome.com/vim/ or ftp://ftp.polarhome.com/pub/vim/

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              